<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Selenium3 + Python3 自动化测试--环境搭建</title>
      <link href="/posts/e23ae58b.html"/>
      <url>/posts/e23ae58b.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-自动化测试简介"><a href="#1-自动化测试简介" class="headerlink" title="1. 自动化测试简介"></a>1. 自动化测试简介</h2><h3 id="1-1-自动化测试分类"><a href="#1-1-自动化测试分类" class="headerlink" title="1.1 自动化测试分类"></a>1.1 自动化测试分类</h3><p>从软件开发周期或分层角度分类：</p><ul><li><strong>单元自动化测试：</strong>自动完成对代码的类或方法的测试，关注代码实现细节和业务逻辑等方面。</li><li><strong>接口自动化测试：</strong>用于测试系统组件接口的请求与返回。接口稳定性高，更适合开展自动化测试。</li><li><strong>UI自动化测试：</strong>对图像化界面进行流程与功能等方面验证。</li></ul><p>从测试目的分类：</p><ul><li>功能自动化测试：主要检查实际功能是否符合用户的需求，以回归测试功能为主，涉及图形界面、数据库连接，以及其他比较稳定而不经常变化的元素。</li><li>性能自动化测试：依托自动化平台自动地执行性能测试、收集并分析测试结果。</li></ul><h3 id="1-2-自动化测试适用条件"><a href="#1-2-自动化测试适用条件" class="headerlink" title="1.2 自动化测试适用条件"></a>1.2 自动化测试适用条件</h3><ul><li>自动化测试前期投入较多，如人力、物力、时间等。</li><li>软件系统界面稳定、变动少。页面频繁变动会导致代码维护成本增加。</li><li>自动化测试的脚本可以重复使用。</li></ul><h2 id="2-Python-与-Selenium-环境搭建"><a href="#2-Python-与-Selenium-环境搭建" class="headerlink" title="2. Python 与 Selenium 环境搭建"></a>2. Python 与 Selenium 环境搭建</h2><p>Selenium 是非常受欢迎的自动化测试工具，它是免费开源的框架，支持多种浏览器，支持多种开发语言，而且还支持并发测试。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 自动化测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Selenium </tag>
            
            <tag> 自动化测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora中编辑数学公式</title>
      <link href="/posts/3ec761e7.html"/>
      <url>/posts/3ec761e7.html</url>
      
        <content type="html"><![CDATA[<p>Typora 对 LaTex 有很好的支持，本文学习利用 LaTex 进行公式编辑。</p><h2 id="1-常用公式代码"><a href="#1-常用公式代码" class="headerlink" title="1.常用公式代码"></a>1.常用公式代码</h2><h3 id="1-1-上下标"><a href="#1-1-上下标" class="headerlink" title="1.1 上下标"></a>1.1 上下标</h3><p><strong>上标：</strong>使用 <code>^</code>。例：$x^2$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">x^2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>下标：</strong>使用<code>_</code>。例：$x_2$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">x_2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>上下标组合：</strong>结合<code>^</code>和<code>_</code>。例：$x_1^2$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">x_1^2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果上下标的内容多于一个字符，需要用 <code>{}</code> 将这些内容括成一个整体。例：$x_{2n}$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">x_{2n}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-括号和分隔符"><a href="#1-2-括号和分隔符" class="headerlink" title="1.2 括号和分隔符"></a>1.2 括号和分隔符</h3><p><code>()</code>、<code>[]</code> 和 <code>|</code> 表示符号本身，使用 <code>\{\}</code> 来表示 <code>{}</code> 。当要显示大号的括号或分隔符时，要用 <code>\left</code> 和 <code>\right</code> 命令。例：$\left(x+y\right)$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\left(x+y\right)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-分式"><a href="#1-3-分式" class="headerlink" title="1.3 分式"></a>1.3 分式</h3><p>例：$\frac{a+c}{b+c}$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\frac{a+c}{b+c}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-4-省略号"><a href="#1-4-省略号" class="headerlink" title="1.4 省略号"></a>1.4 省略号</h3><p>例：$\cdots$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\cdots<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-5-占位符"><a href="#1-5-占位符" class="headerlink" title="1.5 占位符"></a>1.5 占位符</h3><p><strong>两个 quad 空格：</strong>$a\qquad b$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">a\qquad b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>一个 quad 空格：</strong>$a\quad b$</p><pre><code>a\quad b</code></pre><p><strong>大空格：</strong>$a\ b$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">a\ b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>中等空格：</strong>$a\;b$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">a\;b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>小空格：</strong>$a\,b$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">a\,b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-6-开根号"><a href="#1-6-开根号" class="headerlink" title="1.6 开根号"></a>1.6 开根号</h3><p>例：$\sqrt{2}$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\sqrt{2}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-7-加减乘除"><a href="#1-7-加减乘除" class="headerlink" title="1.7 加减乘除"></a>1.7 加减乘除</h3><p>加减：$x\pm y=z$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">x\pm y=z<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>叉乘、点乘、星乘：$x\times y=z$、$x\cdot y=z$、$x\ast y=z$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">x\times y=z、x\cdot y=z、x\ast y=z<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除：$x\div y=z$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">x\div y=z<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-8-累加累乘"><a href="#1-8-累加累乘" class="headerlink" title="1.8 累加累乘"></a>1.8 累加累乘</h3><p>累加：$\sum_{i=1}^{n}{a_i}$、$\sum \limits_{i=1}^n$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\sum_{i=1}^{n}{a_i}、\sum \limits_{i=1}^n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>累乘：$\prod_{i=1}^{n}{a_i}$、$\prod \limits_{i=1}^n$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\prod_{i=1}^{n}{a_i}、\prod \limits_{i=1}^n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-9-矢量"><a href="#1-9-矢量" class="headerlink" title="1.9 矢量"></a>1.9 矢量</h3><p>矢量：$\vec{a}$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\vec{a}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-10-积分微分"><a href="#1-10-积分微分" class="headerlink" title="1.10 积分微分"></a>1.10 积分微分</h3><p>积分：$\int_1^2x\,dx$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\int_1^2x\,dx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>微分：$\frac {\partial x}{\partial y}$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\frac {\partial x}{\partial y}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-11-极限"><a href="#1-11-极限" class="headerlink" title="1.11 极限"></a>1.11 极限</h3><p>极限：$\lim \limits_{n \to +\infty}\frac{1}{n(n+1)}$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\lim \limits_{n \to +\infty}\frac{1}{n(n+1)}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-12-三角函数"><a href="#1-12-三角函数" class="headerlink" title="1.12 三角函数"></a>1.12 三角函数</h3><p>三角函数：$\sin{\theta}$、$\cos{\theta}$、$\tan{\theta}$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\sin{\theta}、\cos{\theta}、\tan{\theta}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-13-关系运算"><a href="#1-13-关系运算" class="headerlink" title="1.13 关系运算"></a>1.13 关系运算</h3><p>大于：$a\gt b$ </p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">a\gt b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>大于等于：$a\geq b$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">a\geq b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>小于：$a\lt b$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">a\lt b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>小于等于：$a\leq b$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">a\leq b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不等于：$a\neq b$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex"><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>约等于：$a \approx b$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">a \approx b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-14-集合运算"><a href="#1-14-集合运算" class="headerlink" title="1.14 集合运算"></a>1.14 集合运算</h3><p>集合运算：$\emptyset、\in、\notin、\subset、\supset、\subseteq、\supseteq、\cup、\cap$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\emptyset、\in、\notin、\subset、\supset、\subseteq、\supseteq、\cup、\cap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-15-对数"><a href="#1-15-对数" class="headerlink" title="1.15 对数"></a>1.15 对数</h3><p>对数：$\log、\lg、\ln$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\log、\lg、\ln<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-16-箭头"><a href="#1-16-箭头" class="headerlink" title="1.16 箭头"></a>1.16 箭头</h3><p>箭头：$\overrightarrow{a+b}、\overleftarrow{a+b}$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\overrightarrow{a+b}、\overleftarrow{a+b}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-17-上下划线"><a href="#1-17-上下划线" class="headerlink" title="1.17 上下划线"></a>1.17 上下划线</h3><p>上划线、下划线：$\overline{a+b}、\underline{a+b}$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\overline{a+b}、\underline{a+b}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-18-上下大括号"><a href="#1-18-上下大括号" class="headerlink" title="1.18 上下大括号"></a>1.18 上下大括号</h3><p>上大括号、下大括号：$\overbrace{a+b}^{Sample}、\underbrace{a+b}_{Sample}$</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\overbrace{a+b}^{Sample}、\underbrace{a+b}_{Sample}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-19-希腊字母"><a href="#1-19-希腊字母" class="headerlink" title="1.19 希腊字母"></a>1.19 希腊字母</h3><div class="table-container"><table><thead><tr><th style="text-align:left">大写</th><th style="text-align:left">Latex代码</th><th style="text-align:left">小写</th><th style="text-align:left">Latex代码</th></tr></thead><tbody><tr><td style="text-align:left"><script type="math/tex">\Alpha</script></td><td style="text-align:left">\Alpha</td><td style="text-align:left">$\alpha$</td><td style="text-align:left">\alpha</td></tr><tr><td style="text-align:left">$\Beta$</td><td style="text-align:left">\Beta</td><td style="text-align:left">$\beta$</td><td style="text-align:left">\beta</td></tr><tr><td style="text-align:left">$\Gamma$</td><td style="text-align:left">\Gamma</td><td style="text-align:left">$\gamma$</td><td style="text-align:left">\gamma</td></tr><tr><td style="text-align:left">$\Delta$</td><td style="text-align:left">\Delta</td><td style="text-align:left">$\delta$</td><td style="text-align:left">\delta</td></tr><tr><td style="text-align:left">$\Epsilon$</td><td style="text-align:left">\Epsilon</td><td style="text-align:left">$\epsilon$</td><td style="text-align:left">\epsilon</td></tr><tr><td style="text-align:left">$\Zeta$</td><td style="text-align:left">\Zeta</td><td style="text-align:left">$\zeta$</td><td style="text-align:left">\zeta</td></tr><tr><td style="text-align:left">$\Eta$</td><td style="text-align:left">\Eta</td><td style="text-align:left">$\eta$</td><td style="text-align:left">\eta</td></tr><tr><td style="text-align:left">$\Lambda$</td><td style="text-align:left">\Lambda</td><td style="text-align:left">$\lambda$</td><td style="text-align:left">\lambda</td></tr><tr><td style="text-align:left">$\Mu$</td><td style="text-align:left">\Mu</td><td style="text-align:left">$\mu$</td><td style="text-align:left">\mu</td></tr><tr><td style="text-align:left">$\Xi$</td><td style="text-align:left">\Xi</td><td style="text-align:left">$\xi$</td><td style="text-align:left">\xi</td></tr><tr><td style="text-align:left">$\Pi $</td><td style="text-align:left">\Pi</td><td style="text-align:left">$\pi$</td><td style="text-align:left">\pi</td></tr><tr><td style="text-align:left">$\Rho$</td><td style="text-align:left">\Rho</td><td style="text-align:left">$\rho$</td><td style="text-align:left">\rho</td></tr><tr><td style="text-align:left">$\Sigma$</td><td style="text-align:left">\Sigma</td><td style="text-align:left">$\sigma$</td><td style="text-align:left">\sigma</td></tr><tr><td style="text-align:left">$\Tau$</td><td style="text-align:left">\Tau</td><td style="text-align:left">$\tau$</td><td style="text-align:left">\tau</td></tr><tr><td style="text-align:left">$\Phi$</td><td style="text-align:left">\Phi</td><td style="text-align:left">$\phi$</td><td style="text-align:left">\phi</td></tr><tr><td style="text-align:left">$\Psi$</td><td style="text-align:left">\Psi</td><td style="text-align:left">$\psi$</td><td style="text-align:left">\psi</td></tr><tr><td style="text-align:left">$\Omega$</td><td style="text-align:left">\Omega</td><td style="text-align:left">$\omega$</td><td style="text-align:left">\omega</td></tr></tbody></table></div><h3 id="1-20-矩阵"><a href="#1-20-矩阵" class="headerlink" title="1.20 矩阵"></a>1.20 矩阵</h3><p>使用<code>\begin{matrix}…\end{matrix}</code>生成， 每一行以<code>\\</code>结尾表示换行，元素间以<code>&amp;</code>间隔，使用<code>\tag{}</code>编号。</p><p>大括号：</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\left\{\begin{matrix}    1 & 2 & 3 \\    4 & 5 & 6 \\    7 & 8 & 9\end{matrix}\right\}\tag{1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">\left\{\begin{matrix}    1 & 2 & 3 \\    4 & 5 & 6 \\    7 & 8 & 9\end{matrix}\right\}\tag{1}</script><p>中括号：</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\left [\begin{matrix}    1 & 2 & 3 \\    4 & 5 & 6 \\    7 & 8 & 9\end{matrix}\right ]\tag{2}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">\left [\begin{matrix}    1 & 2 & 3 \\    4 & 5 & 6 \\    7 & 8 & 9\end{matrix}\right ] \tag{2}</script><p>小括号：</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\left (\begin{matrix}    1 & 2 & 3 \\    4 & 5 & 6 \\    7 & 8 & 9\end{matrix}\right )\tag{3}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">\left (\begin{matrix}    1 & 2 & 3 \\    4 & 5 & 6 \\    7 & 8 & 9\end{matrix}\right )\tag{3}</script><p> 包含希腊字母与省略号：行省略号<code>\cdots</code>，列省略号<code>\vdots</code>，斜向省略号（左上至右下）<code>\ddots</code>。</p><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\left\{\begin{matrix}     1      & 2        & \cdots & 5        \\     6      & 7        & \cdots & 10       \\     \vdots & \vdots   & \ddots & \vdots   \\     \alpha & \alpha+1 & \cdots & \alpha+4 \end{matrix}\right\}\tag{4}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">\left\{ \begin{matrix}     1      & 2        & \cdots & 5        \\     6      & 7        & \cdots & 10       \\     \vdots & \vdots   & \ddots & \vdots   \\     \alpha & \alpha+1 & \cdots & \alpha+4  \end{matrix} \right\}\tag{4}</script><h2 id="2-复杂公式编辑"><a href="#2-复杂公式编辑" class="headerlink" title="2.复杂公式编辑"></a>2.复杂公式编辑</h2><h3 id="2-1-分段函数"><a href="#2-1-分段函数" class="headerlink" title="2.1 分段函数"></a>2.1 分段函数</h3><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">f(n) =\begin{cases}     n/2,  & \text{if }n\text{ is even} \\    3n+1, & \text{if }n\text{ is odd}\end{cases}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">f(n) =\begin{cases}     n/2,  & \text{if }n\text{ is even} \\    3n+1, & \text{if }n\text{ is odd}\end{cases}</script><h3 id="2-2-方程组"><a href="#2-2-方程组" class="headerlink" title="2.2 方程组"></a>2.2 方程组</h3><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\begin{cases}    a_1x+b_1y+c_1z=d_1\\    a_2x+b_2y+c_2z=d_2\\    a_3x+b_3y+c_3z=d_3\end{cases}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">\begin{cases}    a_1x+b_1y+c_1z=d_1\\    a_2x+b_2y+c_2z=d_2\\    a_3x+b_3y+c_3z=d_3\end{cases}</script><h3 id="2-3-多行等式对齐"><a href="#2-3-多行等式对齐" class="headerlink" title="2.3 多行等式对齐"></a>2.3 多行等式对齐</h3><pre class="line-numbers language-lang-latex"><code class="language-lang-latex">\begin{aligned}a &= b + c \\  &= d + e + f \\  &= g + h + i + j\end{aligned}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><script type="math/tex; mode=display">\begin{aligned}a &= b + c \\  &= d + e + f \\  &= g + h + i + j\end{aligned}</script><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode数据库-题库（一）</title>
      <link href="/posts/1f4d87c2.html"/>
      <url>/posts/1f4d87c2.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-组合两个表"><a href="#1-组合两个表" class="headerlink" title="1. 组合两个表"></a><a href="https://leetcode-cn.com/problems/combine-two-tables/" target="_blank" rel="noopener">1. 组合两个表</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT p.FirstName, p.LastName, a.City, a.StateFROM Person pLEFT JOIN Address a ON p.PersonId = a.PersonId;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-第二高的薪水"><a href="#2-第二高的薪水" class="headerlink" title="2.第二高的薪水"></a><a href="https://leetcode-cn.com/problems/second-highest-salary" target="_blank" rel="noopener">2.第二高的薪水</a></h2><p>方法一：使用子查询和 <code>LIMIT</code> 子句</p><p><code>LIMIT m OFFSET n</code>：跳过n行记录，开始取m条记录。</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT (SELECT DISTINCT Salary    FROM Employee    ORDER BY Salary DESC    LIMIT 1 OFFSET 1) AS SecondHighestSalary;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：使用 <code>IFNULL</code> 和 <code>LIMIT</code> 子句</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT     IFNULL(        (SELECT DISTINCT Salary        FROM Employee        ORDER BY Salary DESC        LIMIT 1 OFFSET 1),    NULL) AS SecondHighestSalary<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>IFNULL</code>函数处理查询结果为<code>NULL</code>的情况。</p><p><code>IFNULL(expression, default_value)</code>：如果第一个参数的表达式 <code>expression</code> 为 <code>NULL</code>，则返回第二个默认值。</p><p>采用上面同样的方式我们可以获取第N高的情况。</p><h2 id="3-超过经理收入的员工"><a href="#3-超过经理收入的员工" class="headerlink" title="3.超过经理收入的员工"></a><a href="https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/" target="_blank" rel="noopener">3.超过经理收入的员工</a></h2><p>方法一：使用 <code>where</code></p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT a.Name AS EmployeeFROM    Employee AS a,    Employee AS bWHERE    a.ManagerId = b.Id        AND a.Salary > b.Salary<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：使用 <code>inner join</code></p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT     e1.Name AS EmployeeFROM Employee e1 INNER JOIN Employee e2     ON e1.ManagerId = e2.Id     AND e1.Salary > e2.Salary;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-查找重复的电子邮箱"><a href="#4-查找重复的电子邮箱" class="headerlink" title="4.查找重复的电子邮箱"></a><a href="https://leetcode-cn.com/problems/duplicate-emails/" target="_blank" rel="noopener">4.查找重复的电子邮箱</a></h2><p>方法一：使用 <code>GROUP BY</code> 和临时表</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">select Email from(  select Email, count(Email) as cnt  from Person  group by Email) tempwhere cnt > 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：使用 <code>GROUP BY</code> 和 <code>HAVING</code></p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT EmailFROM PersonGROUP BY EmailHAVING COUNT(Email) > 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-从不订购的客户"><a href="#5-从不订购的客户" class="headerlink" title="5.从不订购的客户"></a><a href="https://leetcode-cn.com/problems/customers-who-never-order/" target="_blank" rel="noopener">5.从不订购的客户</a></h2><p>方法一：使用子查询和 NOT IN</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT Name AS CustomersFROM CustomersWHERE Id NOT IN (    SELECT CustomerId    FROM Orders) ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：使用 LEFT JOIN</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT c.Name AS CustomersFROM Customers c LEFT JOIN Orders o    ON c.Id = o.CustomerIdWHERE o.CustomerId IS NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-删除重复的电子邮箱"><a href="#6-删除重复的电子邮箱" class="headerlink" title="6.删除重复的电子邮箱"></a>6.删除重复的电子邮箱</h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">DELETE p1 FROM Person p1,     Person p2WHERE    p1.Email = p2.Email AND p1.Id > p2.Id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-上升的温度"><a href="#7-上升的温度" class="headerlink" title="7.上升的温度"></a><a href="https://leetcode-cn.com/problems/rising-temperature/" target="_blank" rel="noopener">7.上升的温度</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT w1.IdFROM Weather w1 JOIN Weather w2     ON DATEDIFF(w1.RecordDate, w2.RecordDate) = 1     AND w1.Temperature > w2.Temperature;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>MySQL 使用 <code>DATEDIFF</code> 来比较两个日期类型的值。</p><h2 id="8-游戏玩法分析I"><a href="#8-游戏玩法分析I" class="headerlink" title="8.游戏玩法分析I"></a><a href="https://leetcode-cn.com/problems/game-play-analysis-i/" target="_blank" rel="noopener">8.游戏玩法分析I</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT player_id, MIN(event_date) AS first_loginFROM ActivityGROUP BY player_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="9-游戏玩法分析II"><a href="#9-游戏玩法分析II" class="headerlink" title="9.游戏玩法分析II"></a><a href="https://leetcode-cn.com/problems/game-play-analysis-ii/" target="_blank" rel="noopener">9.游戏玩法分析II</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">select player_id, device_idfrom Activitywhere (player_id, event_date) in (select player_id, min(event_date)                                  from Activity                                  group by player_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-员工奖金"><a href="#10-员工奖金" class="headerlink" title="10.员工奖金"></a><a href="https://leetcode-cn.com/problems/employee-bonus/submissions/" target="_blank" rel="noopener">10.员工奖金</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT e.name, b.bonusFROM Employee e LEFT JOIN Bonus b    ON e.empId = b.empIdWHERE b.bonus < 1000    OR b.bonus IS NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-寻找用户推荐人"><a href="#11-寻找用户推荐人" class="headerlink" title="11.寻找用户推荐人"></a><a href="https://leetcode-cn.com/problems/find-customer-referee/" target="_blank" rel="noopener">11.寻找用户推荐人</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT nameFROM customerWHERE referee_id <> 2 OR referee_id IS NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="12-订单最多的客户"><a href="#12-订单最多的客户" class="headerlink" title="12.订单最多的客户"></a><a href="https://leetcode-cn.com/problems/customer-placing-the-largest-number-of-orders/solution/yong-chuang-kou-han-shu-jie-jue-bing-lie-di-yi-de-/" target="_blank" rel="noopener">12.订单最多的客户</a></h2><p>需考虑并列存在的情况</p><p>方法一：使用子查询</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT customer_numberFROM ordersGROUP BY customer_numberHAVING COUNT(order_number) = (    SELECT COUNT(order_number)    FROM orders    GROUP BY customer_number    ORDER BY COUNT(order_number) DESC    LIMIT 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：使用窗口函数</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT customer_numberFROM (        SELECT customer_number, RANK() (ORDER BY COUNT(order_number) DESC) AS order_rank    FROM orders    GROUP BY customer_number) tempWHERE order_rank = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-大的国家"><a href="#13-大的国家" class="headerlink" title="13.大的国家"></a><a href="https://leetcode-cn.com/problems/big-countries/" target="_blank" rel="noopener">13.大的国家</a></h2><p>方法一：使用 WHERE 子句和 OR</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT name, population, areaFROM WorldWHERE population > 25000000 OR area > 3000000;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>方法二：使用 WHERE 子句和 UNION</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT name, population, areaFROM WorldWHERE area > 3000000UNIONSELECT name, population, areaFROM WorldWHERE population > 25000000;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-超过5名学生的课"><a href="#14-超过5名学生的课" class="headerlink" title="14.超过5名学生的课"></a><a href="https://leetcode-cn.com/problems/classes-more-than-5-students/" target="_blank" rel="noopener">14.超过5名学生的课</a></h2><p>方法一：使用 <code>GROUP BY</code> 子句和子查询</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT classFROM(    SELECT class, COUNT(DISTINCT student) AS stu_num    FROM courses    GROUP BY class) tempWHERE stu_num >= 5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：使用 GROUP BY 和 HAVING</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT classFROM coursesGROUP BY classHAVING COUNT(DISTINCT student) >= 5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-好友申请-I-：总体通过率"><a href="#15-好友申请-I-：总体通过率" class="headerlink" title="15.好友申请 I ：总体通过率"></a><a href="https://leetcode-cn.com/problems/friend-requests-i-overall-acceptance-rate" target="_blank" rel="noopener">15.好友申请 I ：总体通过率</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECTROUND(    IFNULL(    (SELECT COUNT(DISTINCT requester_id, accepter_id) FROM request_accepted)    /    (SELECT COUNT(DISTINCT sender_id, send_to_id ) FROM friend_request),    0)    , 2) AS accept_rate;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-连续空余座位"><a href="#16-连续空余座位" class="headerlink" title="16.连续空余座位"></a><a href="https://leetcode-cn.com/problems/consecutive-available-seats" target="_blank" rel="noopener">16.连续空余座位</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT DISTINCT c1.seat_idFROM cinema c1 JOIN cinema c2     ON abs(c1.seat_id - c2.seat_id) = 1    AND c1.free = 1 AND c2.free = 1ORDER BY c1.seat_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="17-销售员"><a href="#17-销售员" class="headerlink" title="17.销售员"></a><a href="https://leetcode-cn.com/problems/sales-person" target="_blank" rel="noopener">17.销售员</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT nameFROM salespersonWHERE sales_id NOT IN(    SELECT o.sales_id    FROM orders o LEFT JOIN company c        ON o.com_id = c.com_id    WHERE c.name = 'RED');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="18-判断三角形"><a href="#18-判断三角形" class="headerlink" title="18.判断三角形"></a><a href="https://leetcode-cn.com/problems/triangle-judgement" target="_blank" rel="noopener">18.判断三角形</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT x, y, z,     CASE WHEN x + y > z AND x + z > y AND z + y > x THEN 'Yes'     ELSE 'No' END AS 'triangle'FROM triangle;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-直线上的最近距离"><a href="#19-直线上的最近距离" class="headerlink" title="19.直线上的最近距离"></a><a href="https://leetcode-cn.com/problems/shortest-distance-in-a-line" target="_blank" rel="noopener">19.直线上的最近距离</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT min(abs(p1.x - p2.x)) AS shortestFROM point p1 JOIN point p2    ON p1.x <> p2.x;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="20-只出现一次的最大数字"><a href="#20-只出现一次的最大数字" class="headerlink" title=" 20.只出现一次的最大数字"></a><a href="https://leetcode-cn.com/problems/biggest-single-number" target="_blank" rel="noopener"> 20.只出现一次的最大数字</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT IFNULL(    (SELECT num    FROM my_numbers    GROUP BY num     HAVING COUNT(num) = 1    ORDER BY num DESC    LIMIT 1), null) AS num;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="21-有趣的电影"><a href="#21-有趣的电影" class="headerlink" title=" 21.有趣的电影"></a><a href="https://leetcode-cn.com/problems/not-boring-movies" target="_blank" rel="noopener"> 21.有趣的电影</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT id, movie, description, ratingFROM cinemaWHERE description <> 'boring' AND id % 2 <> 0ORDER BY rating DESC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="22-交换工资"><a href="#22-交换工资" class="headerlink" title="22.交换工资"></a><a href="https://leetcode-cn.com/problems/swap-salary" target="_blank" rel="noopener">22.交换工资</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">UPDATE salary    SET        sex = CASE WHEN sex = 'm' THEN 'f'        ELSE 'm'        END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="23-合作过至少三次的演员和导演"><a href="#23-合作过至少三次的演员和导演" class="headerlink" title="23.合作过至少三次的演员和导演"></a><a href="https://leetcode-cn.com/problems/actors-and-directors-who-cooperated-at-least-three-times" target="_blank" rel="noopener">23.合作过至少三次的演员和导演</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT     actor_id AS ACTOR_ID,     director_id AS DIRECTOR_ID FROM ActorDirectorGROUP BY actor_id, director_idHAVING COUNT(*) >= 3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="24-产品销售分析-I"><a href="#24-产品销售分析-I" class="headerlink" title="24.产品销售分析 I"></a><a href="https://leetcode-cn.com/problems/product-sales-analysis-i" target="_blank" rel="noopener">24.产品销售分析 I</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT p.product_name, s.year, s.priceFROM Sales s LEFT JOIN Product p     ON s.product_id = p.product_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="25-产品销售分析-II"><a href="#25-产品销售分析-II" class="headerlink" title="25.产品销售分析 II"></a><a href="https://leetcode-cn.com/problems/product-sales-analysis-ii" target="_blank" rel="noopener">25.产品销售分析 II</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT product_id, SUM(quantity) AS total_quantityFROM SalesGROUP BY product_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="26-项目员工-I"><a href="#26-项目员工-I" class="headerlink" title="26.项目员工 I"></a><a href="https://leetcode-cn.com/problems/project-employees-i" target="_blank" rel="noopener">26.项目员工 I</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT     p.project_id,     ROUND(AVG(e.experience_years), 2) AS average_yearsFROM     Project p     LEFT JOIN Employee e         ON p.employee_id = e.employee_idGROUP BY p.project_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="27-项目员工II"><a href="#27-项目员工II" class="headerlink" title="27.项目员工II"></a><a href="https://leetcode-cn.com/problems/project-employees-ii" target="_blank" rel="noopener">27.项目员工II</a></h2><p>方法一：</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT project_idFROM ProjectGROUP BY project_idHAVING COUNT(employee_id) = (    SELECT COUNT(employee_id) AS num    FROM Project    GROUP BY project_id    ORDER BY num DESC    LIMIT 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法二：</p><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT project_idFROM ProjectGROUP BY project_idHAVING COUNT(employee_id) >= ALL(    SELECT COUNT(employee_id) AS num    FROM Project    GROUP BY project_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="28-销售分析-I"><a href="#28-销售分析-I" class="headerlink" title=" 28.销售分析 I "></a><a href="https://leetcode-cn.com/problems/sales-analysis-i" target="_blank" rel="noopener"> 28.销售分析 I </a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT seller_idFROM SalesGROUP BY  seller_idHAVING SUM(price) >= ALL(    SELECT SUM(price)    FROM Sales    GROUP BY seller_id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="29-销售分析-II"><a href="#29-销售分析-II" class="headerlink" title="29.销售分析 II"></a><a href="https://leetcode-cn.com/problems/sales-analysis-ii" target="_blank" rel="noopener">29.销售分析 II</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT DISTINCT s.buyer_idFROM     Sales s    LEFT JOIN Product p         ON s.product_id = p.product_idWHERE p.product_name = 'S8'AND s.buyer_id NOT IN(    SELECT DISTINCT s.buyer_id    FROM Sales s        LEFT JOIN Product p ON s.product_id = p.product_id    WHERE p.product_name = 'iPhone');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="30-销售分析III"><a href="#30-销售分析III" class="headerlink" title="30.销售分析III"></a><a href="https://leetcode-cn.com/problems/sales-analysis-iii" target="_blank" rel="noopener">30.销售分析III</a></h2><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT DISTINCT p.product_id, p.product_nameFROM Sales s LEFT JOIN Product p     ON s.product_id = p.product_idWHERE p.product_id NOT IN(    SELECT product_id    FROM Sales     WHERE sale_date NOT BETWEEN '2019-01-01' AND '2019-03-31');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="31-报告的记录"><a href="#31-报告的记录" class="headerlink" title="31.报告的记录"></a><a href="https://leetcode-cn.com/problems/reported-posts" target="_blank" rel="noopener">31.报告的记录</a></h2><h2 id="32-查询近30天活跃用户数"><a href="#32-查询近30天活跃用户数" class="headerlink" title="32.查询近30天活跃用户数"></a><a href="https://leetcode-cn.com/problems/user-activity-for-the-past-30-days-i" target="_blank" rel="noopener">32.查询近30天活跃用户数</a></h2><h2 id="33-过去30天的用户活动-II"><a href="#33-过去30天的用户活动-II" class="headerlink" title="33.过去30天的用户活动 II"></a><a href="https://leetcode-cn.com/problems/user-activity-for-the-past-30-days-ii" target="_blank" rel="noopener">33.过去30天的用户活动 II</a></h2><h2 id="34-文章浏览-I"><a href="#34-文章浏览-I" class="headerlink" title="34.文章浏览 I"></a><a href="https://leetcode-cn.com/problems/article-views-i" target="_blank" rel="noopener">34.文章浏览 I</a></h2><h2 id="35-即时食物配送-I"><a href="#35-即时食物配送-I" class="headerlink" title="35.即时食物配送 I"></a><a href="https://leetcode-cn.com/problems/immediate-food-delivery-i" target="_blank" rel="noopener">35.即时食物配送 I</a></h2><h2 id="36-重新格式化部门表"><a href="#36-重新格式化部门表" class="headerlink" title="36.重新格式化部门表"></a><a href="https://leetcode-cn.com/problems/reformat-department-table" target="_blank" rel="noopener">36.重新格式化部门表</a></h2><h2 id="37-查询结果的质量和占比"><a href="#37-查询结果的质量和占比" class="headerlink" title="37.查询结果的质量和占比"></a><a href="https://leetcode-cn.com/problems/queries-quality-and-percentage" target="_blank" rel="noopener">37.查询结果的质量和占比</a></h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习之路--数据结构基础</title>
      <link href="/posts/de246d4c.html"/>
      <url>/posts/de246d4c.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><p><strong>数组：</strong>有限个相同类型的变量所组成的有序集合，数组中的每一个变量称为元素。</p><p><strong>数组特点：</strong>数组中的每一个元素都有自己的<strong>下标</strong>，下标从0开始，一直到数组长度-1。数组的另一个特点是在内存中<strong>顺序存储</strong>。</p><p>内存是由一个个连续的内存单元组成的，每一个内存都有自己的地址。数组中的每一个元素都存储在一个个小小的内存单元中，并且元素之间紧密排列。</p><h3 id="1-1-数组的基本操作"><a href="#1-1-数组的基本操作" class="headerlink" title="1.1 数组的基本操作"></a>1.1 数组的基本操作</h3><h4 id="1-1-1-读取元素"><a href="#1-1-1-读取元素" class="headerlink" title="1.1.1 读取元素"></a>1.1.1 读取元素</h4><p>由于数组在内存中顺序存储，所以只要给出一个数组下标，就可以快速读取到对应的元素。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">lst = [3, 1, 2, 4, 6, 5, 7]print(lst[3])# 输出4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>时间复杂度为 $O(1)$。</strong></p><h4 id="1-1-2-更新元素"><a href="#1-1-2-更新元素" class="headerlink" title="1.1.2 更新元素"></a>1.1.2 更新元素</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">lst = [3, 1, 2, 4, 6, 5, 7]lst[2] = 10print(lst)# 输出[3, 1, 10, 4, 6, 5, 7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>时间复杂度为 $O(1)$。</strong></p><h4 id="1-1-3-插入元素"><a href="#1-1-3-插入元素" class="headerlink" title="1.1.3 插入元素"></a>1.1.3 插入元素</h4><p>插入数组元素的操作存在3种情况：尾部插入、中间插入、超范围插入。</p><ul><li>尾部插入</li></ul><p>直接将元素放在数组尾部，等同于更新数组元素的操作。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">lst = [3, 1, 2, 4, 6, 5, 7]lst.append(8)print(lst)# 输出[3, 1, 2, 4, 6, 5, 7, 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>中间插入</li></ul><p>在数组中间插入元素时，需要<u>先把插入位置及其后面的元素向后移动</u>，腾出位置，再<u>把要插入的元素放到对应的数组位置上</u>。</p><p>在 python 中 insert() 函数可以实现元素插入。为了理解数组工作方式，我们实现一段插入操作的代码。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class MyArray():    def __init__(self, capacity):        self.array = [None] * capacity        self.size = 0    def insert(self, index, element):        # 判断访问下标是否超出范围        if index < 0 or index > self.size:            raise Exception('超出数组实际元素范围！')        # 依次将插入位置右侧的元素向右移动一位        for i in range(self.size-1, index-1, -1):            if i >= len(self.array)-1:                raise Exception('数组索引超出范围')            else:                self.array[i+1] = self.array[i]        # 腾出的位置放入新元素        self.array[index] = element        self.size += 1    def output(self):        print(self.array)array = MyArray(5)array.insert(0, 5)array.insert(0, 6)array.insert(0, 7)array.insert(0, 8)array.insert(0, 9)array.output()# 输出[9, 8, 7, 6, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码中的size为实际元素的数量。</p><ul><li>超范围插入</li></ul><p>如果数组中已装满了元素，还想继续插入元素，需要对数据进行扩容。可以创建一个新数组，长度是旧数组的2倍，再把旧数组中的元素复制过去，实现数组的扩容。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class MyArray():    def __init__(self, capacity):        self.array = [None] * capacity        self.size = 0    def insert_v2(self, index, element):        # 判断访问下标是否超出范围        if index < 0 or index > self.size:            raise Exception('超出数组实际元素范围！')        # 如果实际元素达到数组容量上限，数组扩容        if self.size >= len(self.array):            self.resize()        # 依次将从右向左的元素向右移动一位        for i in range(self.size-1, index-1, -1):            if i >= len(self.array)-1:                raise Exception('数组索引超出范围')            else:                self.array[i+1] = self.array[i]        # 腾出的位置放入新元素        self.array[index] = element        self.size += 1    def resize(self):        array_new = [None] * len(self.array) * 2        # 从旧数组复制到新数组        for i in range(self.size):            array_new[i] = self.array[i]        self.array = array_new    def output(self):        print(self.array)array = MyArray(4)array.insert_v2(0, 5)array.insert_v2(0, 6)array.insert_v2(0, 7)array.insert_v2(0, 8)array.insert_v2(0, 9)array.output()# 输出[9, 8, 7, 6, 5, None, None, None]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>数组扩容的时间复杂度是 $O(n)$，插入并移动的时间复杂度也是 $O(n)$，综合起来插入操作的时间复杂度是 $O(n)$。</strong></p><h4 id="1-1-4-删除元素"><a href="#1-1-4-删除元素" class="headerlink" title="1.1.4 删除元素"></a>1.1.4 删除元素</h4><p>如果删除的元素位于数组中间，其后的元素都要向前挪动一位。在 Python中，已经在底层实现了删除操作，使用 remove() 函数。</p><p><strong>删除操作只涉及元素的移动，时间复杂度是 $O(n)$。</strong></p><h3 id="1-2-数组的优劣势"><a href="#1-2-数组的优劣势" class="headerlink" title="1.2 数组的优劣势"></a>1.2 数组的优劣势</h3><p>优势：数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素。二分查找就是利用这个优势。</p><p>劣势：由于数组是连续紧密地存储在内存中，插入、删除元素都会导致大量元素被迫移动，影响效率。</p><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h2><p>链表是一种在物理上非连续、非顺序的数据结构，由若干节点（node）组成。</p><p><strong>单向链表：</strong>每一个节点包含两部分，一部分是存放数据的变量 data，另一部分是指向下一个节点的指针 next。链表的第一个节点为头节点，最后一个节点为尾节点，尾节点的 next指针指向空。</p><p><strong>双向链表：</strong>每一个节点除了有 data 和 next 指针，还有指向前置节点的 prev指针。</p><p>链表存储：链表在内存中的存储方式是随机存储，采用了见缝插针的方式，链表的每一个节点分布在内存的不同位置，依靠 next 指针进行关联。这样可以有效地利用零散地内存空间。</p><h3 id="2-1-链表的基本操作"><a href="#2-1-链表的基本操作" class="headerlink" title="2.1 链表的基本操作"></a>2.1 链表的基本操作</h3><h4 id="2-1-1-查找节点"><a href="#2-1-1-查找节点" class="headerlink" title="2.1.1 查找节点"></a>2.1.1 查找节点</h4><p>在查找元素时，从链表的头节点开始向后一个个节点逐一查找。链表中的数据只能按顺序进行访问，最坏的时间复杂度是 $O(n)$。</p><h4 id="2-1-2-更新节点"><a href="#2-1-2-更新节点" class="headerlink" title="2.1.2 更新节点"></a>2.1.2 更新节点</h4><p>如果不考虑查找节点的过程，链表的更新很简单，直接把旧数据替换成新数据即可。</p><p>链表更新的时间复杂度为 $O(1)$。</p><h4 id="2-1-3-插入节点"><a href="#2-1-3-插入节点" class="headerlink" title="2.1.3 插入节点"></a>2.1.3 插入节点</h4><p>在链表中插入节点时，分为3种情况：尾部插入、头部插入、中间插入。</p><ul><li>尾部插入</li></ul><p>把最后一个节点的 next 指针指向新插入的节点即可。</p><ul><li>头部插入</li></ul><p>第一步是把新节点的 next 指针指向原先的头节点，第二步是把新节点变为链表的头节点。</p><ul><li>中间插入</li></ul><p>第一步是把新节点的 next 指针指向插入位置的节点，第二步是插入位置前置节点的 next 指针指向新节点。</p><p>存粹的插入操作，时间复杂度为 $O(1)$。</p><h4 id="2-1-4-删除节点"><a href="#2-1-4-删除节点" class="headerlink" title="2.1.4 删除节点"></a>2.1.4 删除节点</h4><p>链表的删除操作分为3种情况：尾部删除、头部删除、中间删除。</p><ul><li>尾部删除</li></ul><p>把倒数第2个节点的 next 指针指向空即可。</p><ul><li>头部删除</li></ul><p>把原先头节点的 next 指针指向的节点设为链表的头节点。</p><ul><li>中间删除</li></ul><p>把链表要删除节点的前置节点的 next 指针，指向要删除元素的下一个节点。</p><p>在 Python 中，有自动化的垃圾回收机制，所以不用刻意去释放被删除的节点。只要没有外部引用指向它们，被删除的节点会被自动回收。</p><p>存粹的删除操作，时间复杂度为 $O(1)$。</p><h3 id="2-2-链表的代码实现"><a href="#2-2-链表的代码实现" class="headerlink" title="2.2 链表的代码实现"></a>2.2 链表的代码实现</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Node():    def __init__(self, data):        self.data = data        self.next = Noneclass LinkedList():    def __init__(self):        self.size = 0        self.head = None        self.last = None    def get(self, index):        if index < 0 or index >= self.size:            raise Exception('超出链表的节点范围！')        p = self.head        for i in range(index):            p = p.next        return p    def insert(self, data, index):        if index < 0 or index > self.size:            raise Exception('超出链表的节点范围！')        node = Node(data)        if self.size == 0:            # 空链表            self.head = node            self.last = node        elif index == 0:            # 插入头部            node.next = self.head            self.head = node        elif self.size == index:            # 插入尾部            self.last.next  = node            self.last = node        else:            # 插入中间            prev_node = self.get(index-1)            node.next = prev_node.next            prev_node.next = node         self.size += 1    def remove(self, index):        if index < 0 or index >= self.size:            raise Exception('超出链表的节点范围！')        if index == 0:            # 删除头节点            removed_node = self.head            self.head = self.head.next        elif index == self.size - 1:            # 删除尾节点            prev_node = self.get(index-1)            removed_node = prev_node.next            prev_node.next = None            self.last = prev_node        else:            # 删除中间节点            prev_node = self.get(index-1)            next_node = prev_node.next.next             removed_node = prev_node.next            prev_node.next = next_node        self.size -= 1        return removed_node    def output(self):        p = self.head        while p is not None:            print(p.data)            p = p.nextlinkedList = LinkedList()linkedList.insert(3, 0)linkedList.insert(4, 0)linkedList.insert(6, 2)linkedList.insert(1, 1)linkedList.remove(0)linkedList.output()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-链表与数组的比较"><a href="#2-2-链表与数组的比较" class="headerlink" title="2.2 链表与数组的比较"></a>2.2 链表与数组的比较</h3><p>数组和链表都属于线性数据结构。两者的时间复杂度如下表：</p><div class="table-container"><table><thead><tr><th></th><th>查找</th><th>更新</th><th>插入</th><th>删除</th></tr></thead><tbody><tr><td>数组</td><td>$O(1)$</td><td>$O(1)$</td><td>$O(n)$</td><td>$O(n)$</td></tr><tr><td>链表</td><td>$O(n)$</td><td>$O(1)$</td><td>$O(1)$</td><td>$O(1)$</td></tr></tbody></table></div><p>数组的优势在于能够快速定位元素，对于<strong>读操作多、写操作少</strong>的场景来说，用数组更合适。</p><p>链表的优势在于能够灵活地插入和删除操作，如果需要<strong>频繁的插入、删除元素</strong>，用链表更合适一些。</p><p>常用的数据结构有很多，但大多都是以数组或链表作为存储方式。数组和链表可以被看做是数据存储的<strong>物理结构</strong>。除了物理结构，还有一类依赖物理结构而存在的结构，即<strong>逻辑结构</strong>。</p><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_img//%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" style="zoom: 25%;"></p><h2 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h2><h3 id="3-1-什么是栈"><a href="#3-1-什么是栈" class="headerlink" title="3.1 什么是栈"></a>3.1 什么是栈</h3><p><strong>栈：</strong>线性数据结构，元素只能<strong>先进后出</strong>。最早进入的元素存放的位置为<strong>栈底</strong>，最后进入的元素存放的位置叫做<strong>栈顶</strong>。栈这种数据结构既可以用数组来实现，也可以用链表来实现。</p><p>栈的数组实现示意结构：</p><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_img//%E6%A0%88%E7%9A%84%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84.png" style="zoom: 25%;"></p><p>栈的链表实现示意结构：</p><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_img//%E6%A0%88%E7%9A%84%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" style="zoom:25%;"></p><h3 id="3-2-栈的基本操作"><a href="#3-2-栈的基本操作" class="headerlink" title="3.2 栈的基本操作"></a>3.2 栈的基本操作</h3><ul><li><strong>入栈：</strong>把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会称为新的栈顶。</li><li><strong>出栈：</strong>把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将成为新的栈顶。</li></ul><p>在 Python 语言中，列表很好地实现了栈地功能，append 方法相当于入栈，pop 方法相当于出栈。</p><p><strong>入栈和出栈地时间复杂度都是 $O(1)$。</strong></p><h2 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h2><h3 id="4-1-什么是队列"><a href="#4-1-什么是队列" class="headerlink" title="4.1 什么是队列"></a>4.1 什么是队列</h3><p><strong>队列：</strong>一种线性数据结构，元素只能<strong>先进先出</strong>。队列的出口端叫作<strong>队头</strong>，队列的入口端叫作<strong>队尾</strong>。</p><p>队列的数组结构：</p><p>用数组实现队列时，为了入队操作的方便，把队尾位置规定尾最后入队元素的<strong>下一个位置</strong>。</p><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_img//%E9%98%9F%E5%88%97%E7%9A%84%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84.png" style="zoom:25%;"></p><p>队列的链表结构：</p><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_img//%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" style="zoom:25%;"></p><h3 id="4-2-队列地基本操作"><a href="#4-2-队列地基本操作" class="headerlink" title="4.2 队列地基本操作"></a>4.2 队列地基本操作</h3><ul><li><strong>入队：</strong>把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为队尾。</li><li><strong>出队：</strong>把新元素移出队列，只允许在队头一侧移出元素，出队元素的后一个位置将会成为新的队头。</li></ul><h3 id="4-3-循环队列"><a href="#4-3-循环队列" class="headerlink" title="4.3 循环队列"></a>4.3 循环队列</h3><p>用数组实现队列时，如果左侧不断出队，队头左侧的空间将失去作用，队列的容量也越来越小。为了维持对量容量的恒定，我们可以采用<strong>循环队列</strong>的方式。</p><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_img//%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png" style="zoom:25%;"></p><p>在数组不做扩容的前提下，当有新元素入队时，我们可以利用已出队元素留下的空间，让队尾指针重新指回数组的首位。在物理结构上，队尾的位置可以在队头之前。当再有元素入队时，将其放在上一个队尾位置，队尾继续后移。一直到<strong><u>（队尾的下标+1）%数组长度 = 队头下标</u></strong>时，代表此队列已满。需要注意，队尾的指针指向的位置永远空出一位，所以队列最大容量比数组长度小1。</p><p>在 Python 中提供了多种队列工具，如 collections.deque，queue.Queue等。为了加深理解，自己尝试实现一个队列：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class MyQueue():    def __init__(self, capacity):        self.list = [None] * capacity        self.front = 0        self.rear = 0    def enqueue(self, element):        if (self.rear + 1) % len(self.list) == self.front:            raise Exception("队列已满!")        self.list[self.rear] = element        self.rear = (self.rear + 1) % len(self.list)    def dequeue(self):        if (self.rear + 1) % len(self.list) == self.front:            raise Exception("队列已满!")        dequeue_element = self.list[self.front]        self.front = (self.front + 1) % len(self.list)        return dequeue_element    def output(self):        i = self.front        while i != self.rear:            print(self.list[i])            i = (i + 1) % len(self.list)myQueue = MyQueue(6)myQueue.enqueue(3)myQueue.enqueue(6)myQueue.enqueue(9)myQueue.dequeue()myQueue.enqueue(5)myQueue.output()# 输出695<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>入队和出队的时间复杂度为$O(1)$。</strong></p><h2 id="5-哈希表"><a href="#5-哈希表" class="headerlink" title="5.哈希表"></a>5.哈希表</h2><p><strong>哈希表：</strong>也叫做散列表，这种数据结构提供了<strong>键</strong>和<strong>值</strong>的映射关系。</p><h3 id="5-1-哈希函数"><a href="#5-1-哈希函数" class="headerlink" title="5.1 哈希函数"></a>5.1 哈希函数</h3><p>哈希函数：将哈希表键通过某种方式转换为数组下标。</p><p>在 Python 语言中， 哈希表对应的集合叫作<strong>字典</strong>。在 Python 及大多数面向对象的语言中，每一个对象都有属于自己的 hash 值，这个 hash 值是区分不同对象的标识。无论对象自身的类型是什么，它们 hash 值都是一个整型变量。将键转化为数组下标最简单的方式是按照数组长度取模运算：</p><p>index = hash(key) % size</p><p>实际上，Python 中的哈希函数没有直接利用取模运算，而是利用了位运算的方式来优化性能。</p><p>示例：我们想根据 Key2 获取到对应的值 Value2。首先，利用哈希函数将 Key2 转化为数组下标 2，然后根据下标从数组中获取对应下标的值。</p><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_img//%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0.png" style="zoom:25%;"></p><h3 id="5-2-哈希表的读写操作"><a href="#5-2-哈希表的读写操作" class="headerlink" title="5.2 哈希表的读写操作"></a>5.2 哈希表的读写操作</h3><h4 id="5-2-1-写操作"><a href="#5-2-1-写操作" class="headerlink" title="5.2.1 写操作"></a>5.2.1 写操作</h4><p>写操作就是在哈希表中插入新的键值对。</p><p>第1步，通过哈希函数，把 Key 转化成数组下标。</p><p>第2步，如果数组下标对应的位置没有元素，就把这个这个 Entry 填充到数组下标对应的位置。</p><p>但是，由于数组长度是有限的，当插入的 Entry 越来越多时，不同的 Key 通过哈希函数获得的下标有可能是相同的。这种情况，就叫作<strong>哈希冲突</strong>。</p><p><strong>解决哈希冲突的方法主要有两种：一种是开放寻址法，一种是链表法。</strong></p><p><strong>开放寻址法的基本思路：</strong>当一个 Key 通过哈希函数获得对应的数组下标已被占用，则寻找下一个空档位置，直至找到没有被占用的位置。</p><p><strong>链表法基本思路：</strong>哈希表数组的每一个元素不仅是一个 Entry 对象，还是一个链表的头节点。每一个 Entry 对象通过 next 指针指向它的下一个 Entry 节点。当新来的 Entry 映射到与之冲突的数组位置时，只需要插入对应的链表中即可。</p><h4 id="5-2-2-读操作"><a href="#5-2-2-读操作" class="headerlink" title="5.2.2 读操作"></a>5.2.2 读操作</h4><p>以链表法为例：</p><p>第1步，通过哈希函数，把 Key 转化成数组下标。</p><p>第2步，找到数组下标对应的元素，如果这个元素的 Key 是要找到就结束；如果这个 Key 不是要找的也没关系，由于数组的每一个元素都与一个链表对应，我们可以顺着这个链表继续往下找，看看能否找到与 Key 相匹配的节点。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习之路--算法概述</title>
      <link href="/posts/a33ab33c.html"/>
      <url>/posts/a33ab33c.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-算法与数据结构"><a href="#1-1-算法与数据结构" class="headerlink" title="1.1 算法与数据结构"></a>1.1 算法与数据结构</h2><p><strong>算法（Algorithm）：</strong>在计算机科学领域，算法指一系列程序指令，用于解决特定的运算和逻辑问题。</p><p>衡量算法好坏的重要标准有两个：<strong>时间复杂度和空间复杂度。</strong></p><p>算法应用场景多种多样：运算、查找、排序、最优决策等。</p><p><strong>数据结构（data structure）：</strong>是数据的组织、管理和存储格式，其使用的目的是高效地访问和修改数据。数据结构是算法的基石。</p><p>数据结构的组成方式：</p><ul><li>线性结构：数组、链表、栈、队列、哈希表等。</li><li>数：二叉树、二叉堆等。</li><li>图：图是更复杂的数据结构，呈现多对多的关联关系。</li><li>其他：由基本数据结构变形而来，用于解决某些特定问题，如跳表、哈希链表、位图等。</li></ul><p>在解决问题时，不同的算法会选用不同的数据结构。</p><h2 id="1-2-时间复杂度"><a href="#1-2-时间复杂度" class="headerlink" title="1.2 时间复杂度"></a>1.2 时间复杂度</h2><p><strong>时间复杂度：</strong>是对一个算法运行时间长短的度量。</p><h3 id="1-2-1-程序的基本操作执行次数"><a href="#1-2-1-程序的基本操作执行次数" class="headerlink" title="1.2.1 程序的基本操作执行次数"></a>1.2.1 程序的基本操作执行次数</h3><p>设 T(n) 为程序基本操作执行次数的函数（也可认为是相对执行时间函数），n 为输入规模。以下是程序中常见的4种执行方式：</p><ul><li>执行次数是线性的，如 T(n) = 3n</li><li>执行次数是对数，如 T(n) = 5logn（底数为2）</li><li>执行次数为常量，如 T(n) = 2</li><li>执行次数是多项式，如 T(n) = 0.5n^2 + 0.5n </li></ul><h3 id="1-2-2-渐进时间复杂度"><a href="#1-2-2-渐进时间复杂度" class="headerlink" title="1.2.2 渐进时间复杂度"></a>1.2.2 渐进时间复杂度</h3><p>若存在函数 f(n)，使得当 n 趋近于无穷大时，T(n)/f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数。记作 T(n) = O(f(n))，称为 O(f(n))，O 为算法的渐进时间复杂度，简称为时间复杂度。</p><p>推导时间复杂度的几个原则：</p><ul><li>如果运行时间是常数量级，则用常数1表示。</li><li>只保留时间函数中的最高阶项。</li><li>如果高阶项存在，则省去最高阶项前面的系数。</li></ul><p>示例：</p><ul><li>T(n) = 3n，时间复杂度为 T(n) = O(n)</li><li>T(n) = 5logn，时间复杂度为 T(n) = O(logn)</li><li>T(n) = 2，时间复杂度为 T(n) = O(1)</li><li>T(n) = 0.5$n^2$ + 0.5n，时间复杂度为 T(n) = O($n^2$) </li></ul><p>当 n 的取值足够大时，可以得到如下结论：</p><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(n^2) </p><h2 id="1-3-空间复杂度"><a href="#1-3-空间复杂度" class="headerlink" title="1.3 空间复杂度"></a>1.3 空间复杂度</h2><p><strong>空间复杂度：</strong>对一个算法在运行过程中临时占用存储空间大小的度量，用大 O 表示，记作 S(n)=O(f(n))，其中 n 为问题的规模，f(n) 为算法所占存储空间的函数。</p><p>常见的空间复杂度计算有以下情形：</p><ul><li>常量空间</li></ul><p>当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作 O(1)。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def fun1(n):    i = 3    # do something<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>线性空间</li></ul><p>当算法分配的空间是一个线性的集合（如列表），并且集合大小和输入规模 n 成正比时，空间复杂度记作 O(n)。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def fun2(n):    array = [[0] * n]    # do something<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>二维空间</li></ul><p>当算法分配的空间是一个二维列表集合，并且集合的长度和宽度都与输入规模 n 成正比时，空间复杂度记作 O($n^2$)。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def fun3(n):    matrix = [[0] * n] * n    # do something<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>递归空间</li></ul><p>递归是一个特殊的场景。在执行程序时，会专门分配一块内存，用来存储“函数调用栈”。“函数调用栈”包括<strong>进栈和出栈</strong>两个行为。当进入一个新函数时，执行入栈操作，把调用的函数和参数信息压入栈中。当函数返回时，执行出栈操作，把调用的函数和参数信息从栈中弹出。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def fun4(n):    if n > 0:        fun4(n-1)    # do something<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>递归算法的空间复杂度和递归深度成正比，如果递归深度是 n，则空间复杂度为 O(n)。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sphinx + GitHub + ReadtheDocs 创建电子书</title>
      <link href="/posts/38fc55dd.html"/>
      <url>/posts/38fc55dd.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建电子书"><a href="#1-创建电子书" class="headerlink" title="1. 创建电子书"></a>1. 创建电子书</h2><h3 id="1-1-安装Sphinx"><a href="#1-1-安装Sphinx" class="headerlink" title="1.1 安装Sphinx"></a>1.1 安装Sphinx</h3><p><a href="http://sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>是一个基于Python的文档生成项目，最早只是用来生成 Python 官方文档。随着工具的完善， 越来越多的知名的项目采用Sphinx来作为文档写作工具，甚至完全可以用来写电子书。</p><pre><code>pip install sphinx sphinx-autobuild sphinx_rtd_theme -i https://pypi.doubanio.com/simple --trusted-host pypi.doubanio.com</code></pre><p>使用国内镜像源安装比较快。</p><h3 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2 初始化"></a>1.2 初始化</h3><ul><li>新建项目文件夹：Project_Name</li></ul><ul><li>切换到到项目文件夹，执行命令：<code>sphinx-quickstart</code></li></ul><p>会进入一个设置向导，根据向导一步一步设置文档项目，其实必填项只有项目名称，作者和版本，其他设置都可以一路回车：</p><p>Separate source and build directories (y/n) [n]: y</p><p>Project name: Project_Name</p><p>Author name(s): lin</p><p>Project release []: 1.0.0</p><p>Project language [en]: zh-CN</p><h3 id="1-3-更换主题"><a href="#1-3-更换主题" class="headerlink" title="1.3 更换主题"></a>1.3 更换主题</h3><p>打开config.py，修改<code>html_theme</code></p><pre><code>html_theme = 'alabaster'替换为html_theme = 'sphinx_rtd_theme'html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]</code></pre><h3 id="1-4-支持markdown编写"><a href="#1-4-支持markdown编写" class="headerlink" title="1.4 支持markdown编写"></a>1.4 支持markdown编写</h3><pre class="line-numbers language-lang-undefined"><code class="language-lang-undefined">pip install recommonmark<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置文件config.py中添加</p><pre><code>extensions = ['recommonmark']source_suffix = ['.rst', '.md']</code></pre><h3 id="1-5-其他配置"><a href="#1-5-其他配置" class="headerlink" title="1.5 其他配置"></a>1.5 其他配置</h3><p>在config.py文件中添加：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">master_doc = 'index'pygments_style = 'sphinx'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-6-编译文件"><a href="#1-6-编译文件" class="headerlink" title="1.6 编译文件"></a>1.6 编译文件</h3><p>source目录就是存放文档源代码的目录，默认的索引页面为index.rst。在项目根目录下执行：</p><pre><code>make clean   # 清空 make html    # 构建文档</code></pre><p>编译后，进入<code>build/html</code>目录后用浏览器打开<code>index.html</code>即可看到生成的文档。</p><h3 id="1-7-托管到Github并发布到Read-the-Docs"><a href="#1-7-托管到Github并发布到Read-the-Docs" class="headerlink" title="1.7 托管到Github并发布到Read the Docs"></a>1.7 托管到Github并发布到Read the Docs</h3><p>将本地新建的项目push到Github上，然后再发布到Read the Docs上。</p><p>具体操作步骤可参考：<a href="https://github.com/readthedocs/readthedocs.org" target="_blank" rel="noopener">https://github.com/readthedocs/readthedocs.org</a></p><h2 id="2-reStructuredText-文档写作"><a href="#2-reStructuredText-文档写作" class="headerlink" title="2. reStructuredText 文档写作"></a>2. reStructuredText 文档写作</h2><p>reStructuredText是一种轻量级的文本标记语言，，是扩展名为.rst的纯文本文件，简称为：RST或reST。RST是Python编程语言的Docutils项目的一部分，能够从Python程序中提取注释和信息，格式化成程序文档，现也在被广泛的用于其他项目程序的文档撰写。</p><h3 id="2-1-章节标题"><a href="#2-1-章节标题" class="headerlink" title="2.1 章节标题"></a>2.1 章节标题</h3><p>章节标题用特殊字符构成的下划线（或上划线）来创建，其中下划线的长度不能小于文本的长度。可以表示标题的符号有 <code>=、-、:、'、"、^、#、~</code>等。</p><ul><li>对于同一符号创建的标题，有上划线的为一级标题，没有上划线的为二级标题。</li></ul><pre class="line-numbers language-lang-rst"><code class="language-lang-rst">==================这是一级标题==================这是二级标题==================<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果想表示不同级别的标题H1-H6，可使用不同符号构成的下划线：</li></ul><pre class="line-numbers language-lang-rst"><code class="language-lang-rst">这是一级标题===================这是二级标题-------------------这是三级标题###################这是四级标题~~~~~~~~~~~~~~~~~~~这是五级标题'''''''''''''''''''这是六级标题^^^^^^^^^^^^^^^^^^^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果想表示同级别的标题，可使用同一符号构成的下划线：</li></ul><pre class="line-numbers language-lang-rst"><code class="language-lang-rst">3.1章节 -------------------3.2章节-------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-段落"><a href="#2-2-段落" class="headerlink" title="2.2 段落"></a>2.2 段落</h3><p>段落是由<strong>空行分隔</strong>的一段文本，同一段落的所有行必须左对齐而且是同一级缩进。</p><h3 id="2-3-行内标记"><a href="#2-3-行内标记" class="headerlink" title="2.3 行内标记"></a>2.3 行内标记</h3><ul><li>斜体</li></ul><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">*text*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>粗体</li></ul><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">**text**<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>等宽</li></ul><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">``text``<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-4-列表"><a href="#2-4-列表" class="headerlink" title="2.4 列表"></a>2.4 列表</h3><h4 id="2-4-1-符号列表"><a href="#2-4-1-符号列表" class="headerlink" title="2.4.1 符号列表"></a>2.4.1 符号列表</h4><p>符号列表可以使用<code>-、*、+</code> 来表示。不同的符号结尾需要加上空行，下级列表需要有空格缩进。</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">符号列表：------------------- 符号列表1- 符号列表2  + 二级符号列表1  - 二级符号列表2  * 二级符号列表3* 符号列表3* 符号列表4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_card_img//image-20200816192112646.png" style="zoom: 50%;"></p><h4 id="2-4-2-顺序列表"><a href="#2-4-2-顺序列表" class="headerlink" title="2.4.2 顺序列表"></a>2.4.2 顺序列表</h4><p>可以使用不同的符号来表示列表：</p><ul><li><p>阿拉伯数字: 1, 2, 3, … </p></li><li><p>大写字母: A-Z</p></li><li><p>小写字母: a-z</p></li><li><p>大写罗马数字: I, II, III, IV, …</p></li><li><p>小写罗马数字: i, ii, iii, iv, …</p></li></ul><p>可以使用符号 <code>#</code> 自动加序号。</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">1. 顺序列表1#. 顺序列表2#. 顺序列表3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-4-3-定义列表"><a href="#2-4-3-定义列表" class="headerlink" title="2.4.3 定义列表"></a>2.4.3 定义列表</h4><p>条目和解释各占一行，解释要有缩进。</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">功能    这是一个功能描述注意事项    这是注意事项描述<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_card_img//image-20200816195325461.png" style="zoom:50%;"></p><h4 id="2-4-4-字段列表"><a href="#2-4-4-字段列表" class="headerlink" title="2.4.4 字段列表"></a>2.4.4 字段列表</h4><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">个人简介：:姓名: xxx:职业: xxx:年龄: xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_card_img//image-20200816200025138.png" style="zoom:50%;"></p><h4 id="2-4-5-选项列表"><a href="#2-4-5-选项列表" class="headerlink" title="2.4.5 选项列表"></a>2.4.5 选项列表</h4><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">-a  列出所有条目-l  列出详细信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_card_img//image-20200816200329834.png" style="zoom:50%;"></p><h3 id="2-5-块"><a href="#2-5-块" class="headerlink" title="2.5 块"></a>2.5 块</h3><ul><li><h4 id="文字块"><a href="#文字块" class="headerlink" title="文字块"></a>文字块</h4></li></ul><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">::    使用::开头。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>行块</li></ul><p>行块是以 <strong>|</strong> 开头，每一个行块可以是多段文本。</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">下面是行块内容： | 这是一段行块内容。 | 这同样也是行块内容。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>块引用</li></ul><p>块引用是通过缩进来实现的，引用块要在前面的段落基础上缩进。</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">下面是引用的内容：    引用内容        ---出处<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_card_img//image-20200816211215709.png" style="zoom:50%;"></p><h3 id="2-6-表格"><a href="#2-6-表格" class="headerlink" title="2.6 表格"></a>2.6 表格</h3><p>reStructuredText提供两种表格：网格表（Grid Tables），简单表（Simple Tables）。</p><h4 id="2-6-1-网格表"><a href="#2-6-1-网格表" class="headerlink" title="2.6.1 网格表"></a>2.6.1 网格表</h4><p>网格表中使用的符号有：<code>-、=、|、+</code>。<strong>-</strong> 用来分隔行， <strong>=</strong> 用来分隔表头和表体行，<strong>|</strong> 用来分隔列，<strong>+</strong> 用来表示行和列相交的节点。</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">+------------+------------+-----------+ | Header 1   | Header 2   | Header 3  | +============+============+===========+ |    row 1   | column 2   | column 3  | +------------+------------+-----------+ |    row 2   | Cells may span columns.| +------------+------------+-----------+ |    row 3   | Cells may  | - Cells   | +------------+ span rows. | - contain | |    row 4   |            | - blocks. | +------------+------------+-----------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_card_img//image-20200816213001464.png" style="zoom:50%;"></p><h4 id="2-6-2-简单表"><a href="#2-6-2-简单表" class="headerlink" title="2.6.2 简单表"></a>2.6.2 简单表</h4><p>简单表相对于网格表，少了 <code>|</code> 和 <code>+</code> 两个符号，只用 <code>-</code> 和 <code>=</code>表示。</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">=====  =====  ======    Inputs     Output ------------  ------   A      B    A or B =====  =====  ====== False  False  False True   False  True False  True   True True   True   True =====  =====  ======<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_card_img//image-20200816213439088.png" style="zoom:50%;"></p><h3 id="2-7-分隔线"><a href="#2-7-分隔线" class="headerlink" title="2.7 分隔线"></a>2.7 分隔线</h3><p>分隔线由至少4个<code>-</code>组成，上下需要添加换行。</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">上面部分------------下面部分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-8-引用"><a href="#2-8-引用" class="headerlink" title="2.8 引用"></a>2.8 引用</h3><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">引用参考，[cite001]_, [cite002]_.. [cite001] 引用内容一.. [cite002] 引用内容二<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_card_img//image-20200816220111951.png" style="zoom:50%;"></p><h3 id="2-9-脚注"><a href="#2-9-脚注" class="headerlink" title="2.9 脚注"></a>2.9 脚注</h3><p>可使用手工序号（1, 2, …）、自动序号(填入#号会自动填充序号)。</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">脚注参考 [1]_，这是第二个脚注 [#]_。..  [1] 这是第一个注记的信息..  [#] 这是第二个注记的信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_card_img//image-20200816221508117.png" style="zoom:50%;"></p><h3 id="2-10-替换"><a href="#2-10-替换" class="headerlink" title="2.10 替换"></a>2.10 替换</h3><p>替换引用就是用定义的指令替换对应的文字或图片。</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">这是 |text|, 修改后的图片 |img|。.. |text| replace:: 替换后的文本.. |img| image:: 图片路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-11-超链接"><a href="#2-11-超链接" class="headerlink" title="2.11 超链接"></a>2.11 超链接</h3><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">这个是第一个超链接， 百度_...  _百度: http://www.baidu.com这是第二个超链接，`知乎 <https://www.zhihu.com/>`_。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-12-图像"><a href="#2-12-图像" class="headerlink" title="2.12 图像"></a>2.12 图像</h3><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">.. image:: 图像路径<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-13-强调"><a href="#2-13-强调" class="headerlink" title="2.13 强调"></a>2.13 强调</h3><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">.. attention::  这是attention.. caution::  这是caution .. danger:: 这是danger.. error::  这是error.. hint:: 这是hint.. important:: 这是important.. note:: 这是note.. tip:: 这是tip.. warning:: 这是warning<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_card_img//image-20200816225119930.png" style="zoom:33%;"></p><h3 id="2-14-注释"><a href="#2-14-注释" class="headerlink" title="2.14 注释"></a>2.14 注释</h3><p>注释以 <strong>..</strong> 开头，后面接注释内容即可，可以是多行内容，多行时每行开头要加一个空格。</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">.. 这是一个注释。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-15-代码块"><a href="#2-15-代码块" class="headerlink" title="2.15 代码块"></a>2.15 代码块</h3><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">.. code-block:: bash    代码块内容.. code-block:: python    代码块内容.. code-block:: json    代码块内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-15-Sphinx标记结构"><a href="#2-15-Sphinx标记结构" class="headerlink" title="2.15 Sphinx标记结构"></a>2.15 Sphinx标记结构</h3><h4 id="2-15-1-toctree"><a href="#2-15-1-toctree" class="headerlink" title="2.15.1 toctree"></a>2.15.1 toctree</h4><p>RST本身并不支持同时与多个文档进行交互，或者说将一个文档保存到多个文件中。Sphinx提供了自定义指令toctree来支持实现这个功能。</p><p><strong>.. toctree::</strong></p><p>这个指令会在当前位置插入文档的目录树。关联文档的路径可以使用相对路径或者绝对路径。 相对路径是指相对于toctree指令所在文件的路径。</p><p>首先，介绍几个重要参数：</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">:maxdepth:2             设置最大深度:numbered:              自动编号:name:                  名字:titlesonly:            只显示标题:glob:                  通配符:reversed:              反向编号:hidden:                隐藏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">.. toctree::    :maxdepth: 2    :glob:    preface       chapters/*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用通配符*将chapters目录下所有的文档都插入到目录中。</p><h4 id="2-15-2-显示代码"><a href="#2-15-2-显示代码" class="headerlink" title="2.15.2 显示代码"></a>2.15.2 显示代码</h4><ul><li>显示行号</li></ul><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">.. code-block:: python    :linenos:    代码块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>突出特定行</li></ul><pre class="line-numbers language-lang-reStructuredText"><code class="language-lang-reStructuredText">.. code-block:: python   :emphasize-lines: 5,10   代码块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>参考：<a href="https://my-study-restructuredtext.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">https://my-study-restructuredtext.readthedocs.io/en/latest/index.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 电子书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Sphinx </tag>
            
            <tag> ReadtheDocs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL必知必会</title>
      <link href="/posts/8cd1b536.html"/>
      <url>/posts/8cd1b536.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-关系数据库与表"><a href="#1-关系数据库与表" class="headerlink" title="1. 关系数据库与表"></a>1. 关系数据库与表</h2><h3 id="1-1-关系数据库结构"><a href="#1-1-关系数据库结构" class="headerlink" title="1. 1 关系数据库结构"></a>1. 1 关系数据库结构</h3><p>关系数据库是应用非常广泛的数据库，和Excel工作表类似，采用由行和列组成的二维表来管理数据。用来关系数据库的计算机系统称为关系数据库管理系统（RDBMS）。RDBMS常见的系统结构是客户端/服务器类型（C/S）：</p><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_card_img//rdbms.png" style="zoom:35%;"></p><h3 id="1-2-表的结构"><a href="#1-2-表的结构" class="headerlink" title="1.2 表的结构"></a>1.2 表的结构</h3><p>关系数据库中的数据表为二维表，<strong>表的列称为字段</strong>，<strong>表的行称为记录</strong>。关系数据库<strong>必须以行为单位进行数据读写</strong>。</p><h2 id="2-SQL概述"><a href="#2-SQL概述" class="headerlink" title="2. SQL概述"></a>2. SQL概述</h2><p>SQL：操作数据库的语言，用关键字、表名、列名等组合而成的语句来描述操作的内容。SQL语句根据功能可以分为：</p><ul><li>数据定义语言（Data Definition Language, DDL）：创建或删除数据库或表。</li></ul><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">CREATE # 创建数据库和表DROP   # 删除数据库和表ALTER  # 修改数据库和表结构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>数据操作语言（Data Manipulation Language, DML）：查询或修改表中的记录。</li></ul><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">SELECT # 查询表中的数据INSERT # 向表中插入数据UPDATE # 更新表中的数据DELETE # 删除表中的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>数据控制语言（Data Control Language, DCL）：用来确认或取消对数据库中数据进行的变更。</li></ul><pre class="line-numbers language-lang-mysql"><code class="language-lang-mysql">COMMIT   # 确认对数据库中数据的变更ROLLBACK # 取消对数据库中数据的变更GRANT    # 赋予用户操作权限REVOKE   # 取消用户的操作权<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>SQL基本的书写规则：</p><ul><li>SQL语句要以分号（;）结尾。</li><li>SQL语句关键字不区分大小写。</li></ul><h2 id="3-表的创建与更新"><a href="#3-表的创建与更新" class="headerlink" title="3. 表的创建与更新"></a>3. 表的创建与更新</h2><h3 id="3-1-创建表"><a href="#3-1-创建表" class="headerlink" title="3.1 创建表"></a>3.1 创建表</h3><p>在创建表之前要先创建数据库：CREATE DATABASE &lt;数据库名称&gt;</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">CREATE DATABASE shop;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建数据表：</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">CREATE TABLE <表名>(<列名1> <数据类型> <列约束>, <列名1> <数据类型> <列约束>, ...<表的约束1>, <表的约束2>);--示例CREATE TABLE Product(product_id      CHAR(4)      NOT NULL, product_name    VARCHAR(100) NOT NULL, product_type    VARCHAR(32)  NOT NULL, sale_price      INTEGER , purchase_price  INTEGER , regist_date     DATE , PRIMARY KEY (product_id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>数据库、表与字段的命名规则：</strong>只能使用字母、数字、下划线命名，且必须以字母开头。同一个数据库中表名不能相同，同一个表中字段名也不能相同。</li><li><strong>字段数据类型：</strong>表中所有列必须指定数据类型。<ul><li>INTEGER型：指定存储整数的列的数据类型。</li><li>CHAR型：用来指定存储字符串的列的数据类型。CHAR(N)，N可存储字符串的最大长度。字符串以定长字符串形式存储，即当字符串长度不到N时，自动用空格补足。</li><li>VARCHAR型：指定存储字符串的列的数据类型。VARCHAR(N)，字符串以可变长字符串形式存储，即当字符串长度不足时，不自动补足。</li></ul></li><li><strong>约束设置</strong>：NOT NULL约束表示字段不能为空，PRIMARY KEY()将指定列设为主键。</li></ul><h3 id="3-2-更新表"><a href="#3-2-更新表" class="headerlink" title="3.2 更新表"></a>3.2 更新表</h3><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">--添加多列ALTER TABLE <tbl_name> ADD COLUMN (col_name1 col_type, col_name2 col_type, ...);ALTER TABLE <tbl_name> ADD (col_name1 col_type, col_name2 col_type, ...);ALTER TABLE <tbl_name> ADD col_name1 col_type, ADD col_name2 col_type, ...);--修改多列ALTER TABLE <tbl_name> change col_name1 col_name3 col_type, change col_name2 col_name4 col_type;ALTER TABLE <tbl_name> change COLUMN col_name1 col_name3 col_type, change COLUMN col_name2 col_name4 col_type;--修改字段名ALTER TABLE <tbl_name> change `original_field_name` changed_field_name field_type;--删除多列ALTER TABLE <tbl_name> DROP col_name1, DROP col_name2;ALTER TABLE <tbl_name> DROP COLUMN col_name1, DROP COLUMN col_name2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-删除表"><a href="#3-3-删除表" class="headerlink" title="3.3 删除表"></a>3.3 删除表</h3><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">DROP TABLE <tbl_name>;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-4-重命名表"><a href="#3-4-重命名表" class="headerlink" title="3.4 重命名表"></a>3.4 重命名表</h3><p>不同的DBMS对表重命名的支持有所不同，在Mysql中使用RENAME进行操作。</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">RENAME TABLE <original_tbl_name> <renamed_tbl_name><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-数据更新"><a href="#4-数据更新" class="headerlink" title="4. 数据更新"></a>4. 数据更新</h2><h3 id="4-1-数据插入"><a href="#4-1-数据插入" class="headerlink" title="4.1 数据插入"></a>4.1 数据插入</h3><p>使用INSERT语句向表中插入数据，基本语法：</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">INSERT INTO <表名> (列1, 列2, ...) VALUES (值1, 值2, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将列名和值用逗号隔开，分别括在 ( ) 内，这种形式称为<strong>清单</strong>。列名组成的为<strong>列清单</strong>，值组成的为<strong>值清单</strong>。原则上，执行一次INSERT语句会插入一行数据。</p><p>目前，大多数RDBMS都支持一次插入多行数据，如在Mysql中插入多行数据：</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">INSERT INTO <表名> VALUES (val1, val2, ...),                        (val3, val4, ...);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-1-1-省略列清单"><a href="#4-1-1-省略列清单" class="headerlink" title="4.1.1 省略列清单"></a>4.1.1 省略列清单</h4><p><strong>当对表的全列进行INSERT操作时，可以省略列清单</strong>，这时VALUES子句的值默认按照从左到右的顺序赋值给每一列。</p><h4 id="4-1-2-插入NULL"><a href="#4-1-2-插入NULL" class="headerlink" title="4.1.2 插入NULL"></a>4.1.2 插入NULL</h4><p>如果想给某一列赋值NULL，可直接在值清单中写入NULL，前提是相应列不能设置NOT NULL约束。</p><h4 id="4-1-3-插入默认值"><a href="#4-1-3-插入默认值" class="headerlink" title="4.1.3 插入默认值"></a>4.1.3 插入默认值</h4><p>如果在CREATE创建表时设置了DEFAULT约束，在我们INSERT操作时可以插入默认值。</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">CREATE TABLE Product(product_id      CHAR(4)      NOT NULL, product_name    VARCHAR(100) NOT NULL, product_type    VARCHAR(32)  NOT NULL, sale_price      INTEGER      DEFAULT 0, purchase_price  INTEGER , regist_date     DATE , PRIMARY KEY (product_id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入默认值有显式和隐式两种：</p><ul><li>显式方法：在VALUES子句中指定DEFAULT关键字。</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">INSERT INTO <tbl_name> (col_name1, col_name2, ...) VALUES (val1, DEFAULT, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>隐式方法：在列清单和值清单中省略默认值的列。</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">INSERT INTO <tbl_name> (col_name1, col_name3, ...) VALUES (val1, val3, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>实际使用时，建议使用显式方法。</p><h4 id="4-1-4-从其他表复制数据"><a href="#4-1-4-从其他表复制数据" class="headerlink" title="4.1.4 从其他表复制数据"></a>4.1.4 从其他表复制数据</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">INSERT INTO <tbl_name> (col1, col2, ...)SELECT col1, col2, ...FROM <tbl_name1><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>INSERT语句的SELECT语句中，可以使用WHERE子句或GROUP BY子句等。</p><h3 id="4-2-数据更新"><a href="#4-2-数据更新" class="headerlink" title="4.2 数据更新"></a>4.2 数据更新</h3><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">UPDATE <tbl_name>    SET <col_name1> = <expression1>,        <col_name2> = <expression2>,        <col_name3> = NULL,        ...    WHERE <condition_expr>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当更新多列时，将SET后的<code>列=值</code>间用逗号分隔。</li><li>使用WHERE指定筛选条件，这种指定更新对象的UPDATE语句为搜索型UPDATE语句。</li><li>当将列更新为NULL时，直接将列赋值为NULL。</li></ul><h3 id="4-3-数据删除"><a href="#4-3-数据删除" class="headerlink" title="4.3 数据删除"></a>4.3 数据删除</h3><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">DELETE FROM <tbl_name> WHERE <condition>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以通过WHERE子句指定对象条件来删除部分数据，如果不使用WHERE指定删除条件，则删除表的全部行。</p><h2 id="5-数据查询基础"><a href="#5-数据查询基础" class="headerlink" title="5. 数据查询基础"></a>5. 数据查询基础</h2><h3 id="5-1-SELECT查询基础"><a href="#5-1-SELECT查询基础" class="headerlink" title="5.1 SELECT查询基础"></a>5.1 SELECT查询基础</h3><h4 id="5-1-1-查询部分列数据"><a href="#5-1-1-查询部分列数据" class="headerlink" title="5.1.1 查询部分列数据"></a>5.1.1 查询部分列数据</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT col_name1, col_name2, ...FROM tbl_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="5-1-2-查询表的所有列"><a href="#5-1-2-查询表的所有列" class="headerlink" title="5.1.2 查询表的所有列"></a>5.1.2 查询表的所有列</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT *FROM tbl_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="5-1-3-为列设置别名"><a href="#5-1-3-为列设置别名" class="headerlink" title="5.1.3 为列设置别名"></a>5.1.3 为列设置别名</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT col_name AS aliasFROM <tbl_name>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>别名可以使用中文，需要使用双引号（” “）括起来。</p><h4 id="5-1-4-查询不重复的行"><a href="#5-1-4-查询不重复的行" class="headerlink" title="5.1.4 查询不重复的行"></a>5.1.4 查询不重复的行</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT DISTINCT col_name1, col_name2, ...FROM <tbl_name>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用DISTINCT删除重复的行，只能用在第一个列名之前，但是作用于后面所有的列。在使用DISTINCT时，NULL也被视为一类数据。</p><h4 id="5-1-5-返回部分记录"><a href="#5-1-5-返回部分记录" class="headerlink" title="5.1.5 返回部分记录"></a>5.1.5 返回部分记录</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT *FROM <tbl_name># 第一种方式LIMIT m OFFSET n;   # m为查询的行数，n为偏移量，即从第几行开始查询# 第二种方式LIMIT n, m;  # n为查询结果的索引值(默认从0开始)，当i=0时可省略；m为查询结果返回的数量。LIMIT 5 等价于 LIMIT 0, 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-数据过滤"><a href="#5-2-数据过滤" class="headerlink" title="5.2 数据过滤"></a>5.2 数据过滤</h3><p>很多时候我们并不需要查询出全部数据，只需要通过设定一些过滤条件来查询部分数据。</p><h4 id="5-2-1-使用WHERE子句"><a href="#5-2-1-使用WHERE子句" class="headerlink" title="5.2.1 使用WHERE子句"></a>5.2.1 使用WHERE子句</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT <列名>, ...FROM <表名>WHERE <条件表达式>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>首先通过WHERE子句查询出符合指定条件的记录，然后再选取出SELECT指定的列。注意：WHERE子句要紧跟在FROM子句之后。条件表达式中：</p><ul><li>大小比较：可以使用<code>&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;、!=</code>等操作符。</li><li>范围值检查：使用<code>BETWEEN...AND...</code>。</li><li>空值检查：使用<code>IS NULL, IS NOT NULL</code>。</li></ul><p>在实际应用时，条件表达式可能不仅仅只有一个条件，这时可以使用组合WHERE子句，即以AND子句或OR子句的方式使用。</p><ul><li>AND操作符</li></ul><p>WHERE子句中，使用AND连接多个条件，用来查询满足所有给定条件的记录。</p><ul><li>OR操作符</li></ul><p>使用OR操作符，用来检索匹配任一给定条件的记录。</p><ul><li>求值顺序</li></ul><p>WHERE子句中也可以同时包含任意数目的AND和OR操作符，允许两者结合进行复杂、高级的过滤。注意：任何时候使用具有AND和OR操作符的WHERE子句，都应该使用<strong>圆括号</strong>明确地进行分组。</p><h4 id="5-2-2-IN-操作符"><a href="#5-2-2-IN-操作符" class="headerlink" title="5.2.2 IN 操作符"></a>5.2.2 IN 操作符</h4><p>IN是OR的简便用法，用来指定条件范围，范围内的每个条件都可以进行匹配。</p><p>示例：筛选出多个价格的记录</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql"># 使用ORSELECT product_name, product_priceFROM ProductsWHERE product_price = 150OR product_price = 180OR product_price = 200;# 使用INSELECT product_name, product_priceFROM ProductsWHERE product_price IN (150, 180, 200);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果想筛选不包含指定条件时，可使用<code>NOT IN</code>来实现。</p><h4 id="5-2-3-NOT操作符"><a href="#5-2-3-NOT操作符" class="headerlink" title="5.2.3 NOT操作符"></a>5.2.3 NOT操作符</h4><p>用于否定NOT后所跟的任何条件。</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT product_name, product_priceFROM ProductsWHERE NOT product_price = 250;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="5-2-4-LIKE操作符"><a href="#5-2-4-LIKE操作符" class="headerlink" title="5.2.4 LIKE操作符"></a>5.2.4 LIKE操作符</h4><p>当需要进行字符串部分一致查询时可使用LIKE操作符。</p><ul><li>前方一致</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT *FROM <tbl_name>WHERE col_name LIKE 'STR%';  # 匹配字段col_name以字符串STR开头的记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>中间一致</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT *FROM <tbl_name>WHERE col_name LIKE '%STR%';  # 匹配字段col_name包含字符串STR的记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>后方一致</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT *FROM <tbl_name>WHERE col_name LIKE '%STR';  # 匹配字段col_name以字符串STR结束的记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-3-聚合与排序"><a href="#5-3-聚合与排序" class="headerlink" title="5.3 聚合与排序"></a>5.3 聚合与排序</h3><h4 id="5-3-1-聚合查询"><a href="#5-3-1-聚合查询" class="headerlink" title="5.3.1 聚合查询"></a>5.3.1 聚合查询</h4><p>使用聚合函数对表中数据进行操作或计算。常用的5各聚合函数：COUNT、SUM、AVG、MAX、MIN。</p><ul><li>COUNT：统计表中记录的行数</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">COUNT(*) # 统计表中所有的记录数，包含字段值为NULL的记录COUNT(1) # 统计表中所有的记录数，包含字段值为NULL的记录COUNT(<列名>) # 统计指定列的记录数，除字段值为NULL的记录COUNT(DISTINCT <列名>) # 统计指定列的不同值的记录数，会忽略字段值为NULL的记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果表中没有主键，<code>count(1)</code>效率优于<code>count(*)</code>；如果表中存在主键，<code>count(主键列名)</code>效率最优；如果列为主键，<code>count(列名)</code>效率优于<code>count(1)</code>；如果列不为主键，<code>count(1)</code>效率优于<code>count(列名)</code>；如果表中只有一列，则<code>count(*)</code>效率最优。</p><ul><li>SUM：计算合计值</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT SUM(<col_name>)FROM <tbl_name>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>SUM聚合函数会将NULL排除在外，即如果待统计的字段col_name中有NULL，则不会被统计。</p><ul><li>AVG：计算多行数据的平均值</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT AVG(<col_name>)FROM <tbl_name>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>AVG也会将NULL排除在外。</p><ul><li>MAX/MIN：计算多条记录中的最大值/最小值</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT MIN(<col_name1>), MAX(<col_name2>)FROM <tbl_name>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>MAX/MIN函数几乎适用于所有数据类型的列，而SUM/AVG函数只适用于数值类型的列。</p><h4 id="5-3-2-分组"><a href="#5-3-2-分组" class="headerlink" title="5.3.2 分组"></a>5.3.2 分组</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT <列名1>, <列名2>, ...FROM <表名>WHERE <条件>GROUP BY <列名1>, <列名2>, ...;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>GROUP BY 子句中指定的列为<strong>聚合键</strong>或<strong>分组列</strong>。使用GROUP BY的子句书写顺序：</p><p><code>SELECT --&gt; FROM --&gt; WHERE --&gt; GROUP BY</code></p><p>会先根据WHERE子句指定的条件进行过滤，再进行汇总处理。SELECT语句的执行顺序：</p><p><code>FROM --&gt; WHERE --&gt; GROUP BY --&gt; SELECT</code></p><p>在使用GROUP BY 时，有些常见错误需要注意：</p><ul><li>在SELECT子句中有多余的列：SELECT子句中不能出现聚合键之外的列名，</li><li>在GROUP BY子句中不能使用SELECT子句中定义的别名：主要是由于执行顺序决定的，先执行GROUP BY，再执行SELECT。</li><li>GROUP BY子句结果的显示是无序的。</li><li>GROUP BY子句中不能使用聚合函数，只有SELECT子句、HAVING子句和ORDER BY子句中可以使用聚合函数。</li></ul><p>如果在使用GROUP BY分组后，想进一步过滤分组，可以使用HAVING。</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT <列名1>, <列名2>, ...FROM <表名>WHERE <条件>GROUP BY <列名1>, <列名2>, ...HAVING <分组结果对应的条件>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：从按照商品种类分组后的结果中，取出数量大于2的分组</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT product_type, COUNT(*)FROM ProductGROUP BY product_typeHAVING COUNT(*) > 2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在HAVING子句中可以使用以下三种要素：常数、聚合函数、GROUP BY子句中指定的列名（即聚合键）。</p><p>WHERE和HAVING子句中都可以指定筛选条件，但是有区别的：</p><ul><li>WHERE子句中是指定行所对应的条件</li><li>HAVING子句中式指定组所对应的条件</li></ul><p>GROUP BY子句中的聚合键所对应的条件不应写在HAVING子句中，而应写在WHERE子句中。</p><h4 id="5-3-3-排序"><a href="#5-3-3-排序" class="headerlink" title="5.3.3 排序"></a>5.3.3 排序</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT <列名1>, <列名2>, ...FROM <表名>WHERE <条件>GROUP BY <列名1>, <列名2>, ...HAVING <分组结果对应的条件>ORDER BY <排序基准列1>, <排序基准列2> DESC;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ORDER BY子句后的列名为排序键，默认为升序排序，可通过DESC指定为降序排序。如果排序键中包含NULL，则会在开头或末尾进行汇总。此外，在ORDER BY子句中可以使用SELECT子句中未使用的列和聚合函数。</p><p>以上基本介绍了常用的子句，完整的书写顺序如下：</p><p><code>SELECT子句 --&gt; FROM子句 --&gt; WHERE子句 --&gt; GROUP BY子句 --&gt; HAVING子句 --&gt; ORDER BY子句</code></p><p>粗略的执行顺序（不同的DBMS可能执行顺序不同）：</p><p><code>FROM --&gt; WHERE --&gt; GROUP BY --&gt; HAVING --&gt; SELECT --&gt; ORDER BY</code></p><h2 id="6-复杂查询"><a href="#6-复杂查询" class="headerlink" title="6. 复杂查询"></a>6. 复杂查询</h2><h3 id="6-1-视图"><a href="#6-1-视图" class="headerlink" title="6.1 视图"></a>6.1 视图</h3><p>视图可以理解为虚拟的表，只包含使用时动态检索数据的查询。<strong>表中存储的是实际数据，而视图中保存的是从表中取出数据所使用的SELECT语句。</strong></p><p>视图的优点：</p><ul><li>由于视图无需保存数据，可以节省存储设备的容量。</li><li>将经常使用的SELECT语句做成视图，不用每次都重新书写。而且，视图中的数据会随着原表的变化而自动更新。</li></ul><p><strong>创建视图：</strong></p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">CREATE VIEW 视图名称(<视图列名1>, <视图列名2>, ...)AS<SELECT 语句><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>使用视图的查询：首先执行定义视图的SELECT语句，然后根据执行的结果，再执行FROM子句中使用视图的SELECT语句。</p><p>注意：多重视图会降低SQL的性能，我们应该避免在视图的基础上创建视图。</p><p><strong>删除视图：</strong></p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">DROP VIEW 视图名称(<视图列名1>, <视图列名2>, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-2-子查询"><a href="#6-2-子查询" class="headerlink" title="6.2 子查询"></a>6.2 子查询</h3><p>子查询可以理解为一次性视图，就是将用来定义视图的SELECT语句直接用于FROM子句中。</p><p>示例：</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT product_type, cnt_productFROM (SELECT product_type, COUNT(*) AS cnt_product      FROM Product      GROUP BY product_type) ProductSum;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>FROM后的为子查询，原则上子查询必须设定名称。子查询作为内层查询会首先被执行。</p><p><strong>标量子查询：</strong>就是返回单一值的子查询。</p><p>示例：查询出销售单价高于全部商品平均单价的商品</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT product_id, product_name, sale_priceFROM ProductWHERE sale_price > (SELECT AVG(sale_price)                  FROM Product);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>标量子查询的书写位置不仅仅局限于WHERE子句中，通常任何可使用单一值的位置都可以使用。也就是说，能够使用常数或者列名的地方，无论是在SELECT子句、GROUP BY子句，还是ORDER BY子句中。</p><h3 id="6-3-关联子查询"><a href="#6-3-关联子查询" class="headerlink" title="6.3 关联子查询"></a>6.3 关联子查询</h3><p>在细分的组内进行比较时，需要使用关联子查询。</p><p>示例：按照商品种类查询出高于平均售价的商品</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT product_id, product_name, sale_priceFROM Product AS P1WHERE sale_price > (SELECT AVG(sale_price)                   FROM Product AS P2                   WHERE P1.product_type = P2.product_type);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-集合运算"><a href="#7-集合运算" class="headerlink" title="7. 集合运算"></a>7. 集合运算</h2><h3 id="7-1-表的加减法"><a href="#7-1-表的加减法" class="headerlink" title="7.1 表的加减法"></a>7.1 表的加减法</h3><h4 id="7-1-1-表的加法—UNION"><a href="#7-1-1-表的加法—UNION" class="headerlink" title="7.1.1 表的加法—UNION"></a>7.1.1 表的加法—UNION</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT <col_name1>, <col_name2>FROM <tbl_name1>UNIONSELECT <col_name1>, <col_name2>FROM <tbl_name2>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>UNION集合运算会除去重复的记录。如果想保留重复行，只需要在UNION后添加ALL即可。</p><p>集合运算的注意事项：</p><ul><li>作为运算对象的记录的列数必须相同</li><li>作为运算对象的记录中列的类型必须一致</li><li>可以使用任何SELECT语句，但ORDER BY子句只能在最后一次使用</li></ul><h4 id="7-1-2-选取表中公共部分—INTERSECT"><a href="#7-1-2-选取表中公共部分—INTERSECT" class="headerlink" title="7.1.2 选取表中公共部分—INTERSECT"></a>7.1.2 选取表中公共部分—INTERSECT</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT <col_name1>, <col_name2>FROM <tbl_name1>INTERSECTSELECT <col_name1>, <col_name2>FROM <tbl_name2>ORDER BY <col_name1>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果希望保留重复行，需要使用INTERSECT ALL。</p><h4 id="7-1-3-记录的减法—EXCEPT"><a href="#7-1-3-记录的减法—EXCEPT" class="headerlink" title="7.1.3 记录的减法—EXCEPT"></a>7.1.3 记录的减法—EXCEPT</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT <col_name1>, <col_name2>FROM <tbl_name1>EXCEPTSELECT <col_name1>, <col_name2>FROM <tbl_name2>ORDER BY <col_name1>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-联结表"><a href="#7-2-联结表" class="headerlink" title="7.2 联结表"></a>7.2 联结表</h3><h4 id="7-2-1-内联结—INNER-JOIN"><a href="#7-2-1-内联结—INNER-JOIN" class="headerlink" title="7.2.1 内联结—INNER JOIN"></a>7.2.1 内联结—INNER JOIN</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT *FROM <tbl_name1> tn1INNER JOIN <tbl_name2> tn2ON tn1.<col_name> = tn2.<col_name>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-2-2-外联结—OUTER-JOIN"><a href="#7-2-2-外联结—OUTER-JOIN" class="headerlink" title="7.2.2 外联结—OUTER JOIN"></a>7.2.2 外联结—OUTER JOIN</h4><ul><li>左联结—LEFT JOIN</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT *FROM <tbl_name1> tn1LEFT JOIN <tbl_name2> tn2ON tn1.<col_name> = tn2.<col_name>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>右联结—RIGHT JOIN</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT *FROM <tbl_name1> tn1RIGHT JOIN <tbl_name2> tn2ON tn1.<col_name> = tn2.<col_name>;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>外联结中使用LEFT、RIGHT来指定主表。</p><h2 id="8-函数与CASE表达式"><a href="#8-函数与CASE表达式" class="headerlink" title="8. 函数与CASE表达式"></a>8. 函数与CASE表达式</h2><h3 id="8-1-函数"><a href="#8-1-函数" class="headerlink" title="8.1 函数"></a>8.1 函数</h3><p>介绍MySQL支持的一些函数。</p><h4 id="8-1-1-算术函数"><a href="#8-1-1-算术函数" class="headerlink" title="8.1.1 算术函数"></a>8.1.1 算术函数</h4><ul><li>ABS(x)：绝对值</li><li>CEIL(x)：向上取整，返回大于或等于 x 的最小整数</li><li>FLOOR(x)：向下取整，返回返回小于或等于 x 的最大整数</li><li>ROUND(x)：四舍五入函数</li><li>MOD(x)：取模函数</li></ul><h4 id="8-1-2-字符串函数"><a href="#8-1-2-字符串函数" class="headerlink" title="8.1.2 字符串函数"></a>8.1.2 字符串函数</h4><ul><li>CONCAT(s1,s2…sn)：将多个字符串合并为一个字符串</li><li>FIND_IN_SET(s1,s2)：返回在字符串s2中与s1匹配的字符串的位置</li><li>LOCATE(s1,s)：从字符串 s 中获取 s1 的开始位置</li><li>LOWER(s)/UPPER(s)：将字符串转换为小写/大写</li><li>LENGTH(s)：返回字符串长度</li><li>REPLACE(s,s1,s2)：将对象字符串s中的字符串s1替换为s2</li><li>SUBSTRING(s, start, length)：从字符串 s 的 start 位置截取长度为 length 的子字符串</li></ul><h4 id="8-1-3-日期函数"><a href="#8-1-3-日期函数" class="headerlink" title="8.1.3 日期函数"></a>8.1.3 日期函数</h4><ul><li>ADDDATE(d,n)：计算起始日期 d 加上 n 天的日期</li><li>CURDATE()/CURRENT_DATE()：返回当前日期</li><li>DATEDIFF(d1,d2)：计算日期 d1与d2 之间相隔的天数</li><li>CURRENT_TIMESTAMP()：返回当前日期和时间</li><li>CURRENT_TIME()/CURTIME()：返回当前时间</li><li>DATE()：从日期或日期时间表达式中提取日期值</li><li>DATE_FORMAT(d, f)：按表达式 f 的要求显示日期 d，如DATE_FORMAT(d, “%Y-%m-%d”)</li><li>DATE_ADD(d，INTERVAL expr type)：计算起始日期 d 加上一个时间段后的日期，如type默认为天，可指定为MINUTE等</li><li>DATE_SUB(date,INTERVAL expr type)：从日期减去指定的时间间隔expr </li><li>MONTH(d)/DAY(d)/HOUR(t)/MINUTE(t)/SECOND(t)：返回月份/天/小时/分钟/秒</li><li>NOW()：返回当前日期和时间</li><li>WEEKDAY(d)：返回日期 d 是星期几</li></ul><h3 id="8-2-CASE表达式"><a href="#8-2-CASE表达式" class="headerlink" title="8.2 CASE表达式"></a>8.2 CASE表达式</h3><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">CASE WHEN <求值表达式> THEN <表达式>     WHEN <求值表达式> THEN <表达式>     ...     ELSE <表达式>END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CASE表达式后的END是不能省略的。</p><h2 id="9-SQL高级处理—窗口函数"><a href="#9-SQL高级处理—窗口函数" class="headerlink" title="9. SQL高级处理—窗口函数"></a>9. SQL高级处理—窗口函数</h2><h3 id="9-1-窗口函数简介"><a href="#9-1-窗口函数简介" class="headerlink" title="9.1 窗口函数简介"></a>9.1 窗口函数简介</h3><p>窗口函数也称为OLAP（Online Analytical Processing），意思是对数据库数据进行实时分析处理。</p><p>窗口函数的语法：</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql"><窗口函数> OVER ([PARTITION BY <列清单>]                    ORDER BY <排序用的列清单>)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>能够作为窗口函数使用的函数：</p><ul><li>能够作为窗口函数的聚合函数，如SUM、AVG、COUNT、MAX、MIN等。</li><li>专用窗口函数：RANK、DENSE_RANK、ROW_NUMBER等。</li></ul><h3 id="9-2-专业窗口函数"><a href="#9-2-专业窗口函数" class="headerlink" title="9.2 专业窗口函数"></a>9.2 专业窗口函数</h3><h4 id="9-2-1-RNAK函数"><a href="#9-2-1-RNAK函数" class="headerlink" title="9.2.1 RNAK函数"></a>9.2.1 RNAK函数</h4><p>RNAK函数是用来计算记录排序。</p><p>示例：创建了一个学生成绩表grade，由学号（Number）、班级（Class）、考试成绩（Score）构成。需求：按照学生所在班级，对考试成绩进行排序。</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT Number, Class, Score,RANK() OVER (PARTITION BY Class             ORDER BY Score DESC) AS rankingFROM grade;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>PARTITION BY能够设定排序的对象范围，用来对表进行分组。ORDER BY能够指定按哪一字段、何种顺序进行排序，默认是升序（ASC）排序，可通过ASC/DESC指定升序和降序。</p><p>窗口函数兼具分组和排序两种功能，即我们之前学过的GROUP BY子句的分组功能和ORDER BY子句的排序功能。但是，PARTITION BY子句并不具备GROUP BY子句的汇总功能。因此，使用RANK函数并不会减少原表中记录的行数。</p><p>窗口：通过PARTITION BY分组后的记录集合。</p><p>注意：窗口函数只能在SELECT子句中使用，不能在WHERE子句或GROUP BY子句中使用。</p><h4 id="9-2-2-代表性的专用窗口函数"><a href="#9-2-2-代表性的专用窗口函数" class="headerlink" title="9.2.2 代表性的专用窗口函数"></a>9.2.2 代表性的专用窗口函数</h4><ul><li>RANK函数</li></ul><p>计算排序时，如果存在相同位次的记录，则会跳过之后的位次。例如：1位、1位、3位……</p><ul><li>DENSE_RANK函数</li></ul><p>计算排序时，即使存在相同位次的记录，也不会跳过之后的位次。例如：1位、1位、2位……</p><ul><li>ROW_NUMBER函数</li></ul><p>不考虑相同位次，赋予唯一的连续位次…….</p><h3 id="9-3-聚合函数作为窗口函数"><a href="#9-3-聚合函数作为窗口函数" class="headerlink" title="9.3 聚合函数作为窗口函数"></a>9.3 聚合函数作为窗口函数</h3><p>所有聚合函数都能用作窗口函数，其语法和专业窗口函数相同，只需要把聚合函数写在窗口函数的位置即可，但是函数后面括号里面不能为空，需要指定聚合的列名。</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT product_id, product_name, sale_price,    SUM(sale_price) OVER (ORDER BY product_id) AS current_sumFROM Product;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="9-3-1-计算移动平均"><a href="#9-3-1-计算移动平均" class="headerlink" title="9.3.1 计算移动平均"></a>9.3.1 计算移动平均</h4><p>窗口函数就是将表以窗口为单位进行分割，并在其中进行排序的函数。其中还包含在窗口中指定更加详细的汇总范围的备选功能，该备选功能中的汇总范围称为<strong>框架</strong>。</p><p>指定框架（汇总范围）：</p><p>使用ROWS和PRECEDING两个关键字可以将框架指定为“截止到之前的~行”。使用FOLLOWING指定“截止到之后的~行”。由于框架是根据当前记录来确定的，因此和固定窗口不同，其范围会随着当前记录的变化而变化。</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT product_id, product_name, sale_price,    AVG(sale_price) OVER ( ORDER BY product_id                          ROWS BETWEEN 2 PRECEDING AND                          2 FOLLOWING) AS moving_avgFROM Product;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7下重新安装Python与yum</title>
      <link href="/posts/15b17ed5.html"/>
      <url>/posts/15b17ed5.html</url>
      
        <content type="html"><![CDATA[<p>1.查看内核版本</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">cat /etc/redhat-release<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2.删除现有Python</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">rpm -qa|grep python|xargs rpm -ev --allmatches --nodepswhereis python |xargs rm -frvwhereis python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3.删除现有的yum</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">rpm -qa|grep yum|xargs rpm -ev --allmatches --nodepswhereis yum |xargs rm -frv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4.下载Python和yum程序包及其依赖包</p><p><a href="http://vault.centos.org/" target="_blank" rel="noopener">http://vault.centos.org/</a></p><p><a href="http://mirrors.163.com/centos/" target="_blank" rel="noopener">http://mirrors.163.com/centos/</a></p><p>5.安装python以及yum的rpm包</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">rpm -Uvh --replacepkgs lvm2-python-libs*.rpm --nodeps --forcerpm -Uvh --replacepkgs libxml2-python*.rpm --nodeps --forcerpm -Uvh --replacepkgs python*.rpm --nodeps --forcerpm -Uvh --replacepkgs rpm-python*.rpm yum*.rpm --nodeps --force<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩转Git</title>
      <link href="/posts/afa3f4a0.html"/>
      <url>/posts/afa3f4a0.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-集中式与分布式VCS"><a href="#1-集中式与分布式VCS" class="headerlink" title="1. 集中式与分布式VCS"></a>1. 集中式与分布式VCS</h2><h3 id="1-1-集中式VCS（CVCS）"><a href="#1-1-集中式VCS（CVCS）" class="headerlink" title="1.1 集中式VCS（CVCS）"></a>1.1 集中式VCS（CVCS）</h3><p>集中式版本控制系统（Centralized Version Control System，简称 CVCS），有集中管理的服务器，保存所有文件的修订版本，必须通过客户端连到管理服务器，获取最新的文件或者提交更新。SVN是一个典型的CVCS。</p><ul><li><p>有集中的版本管理服务器</p></li><li><p>具备文件版本管理和分支管理能力</p></li><li><p>客户端必须时刻和服务器相连。</p></li></ul><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//CVCS.png" style="width:300px;"></p><h3 id="1-2-分布式VCS"><a href="#1-2-分布式VCS" class="headerlink" title="1.2 分布式VCS"></a>1.2 分布式VCS</h3><p>分布式版本控制系统（Distributed Version Control System，简称 DVCS），客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。Git是一个典型的DVCS。</p><ul><li><p>服务端和客户端都有完整的版本库</p></li><li><p>脱离服务端，客户端照样可以管理版本</p></li><li><p>查看历史和版本比较等多数操作，都不需要访问服务器，比集中式VCS更能提高版本管理效率。</p></li></ul><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//DVCS.png" style="width:400px;"></p><h2 id="2-Git安装与配置"><a href="#2-Git安装与配置" class="headerlink" title="2. Git安装与配置"></a>2. Git安装与配置</h2><h3 id="2-1-Git安装"><a href="#2-1-Git安装" class="headerlink" title="2.1 Git安装"></a>2.1 Git安装</h3><p>CentOS7下安装Git：<a href="https://www.linwang93.cn/posts/c6c40a41.html">https://www.linwang93.cn/posts/c6c40a41.html</a></p><p>win10下安装Git：下载地址：<a href="https://git-scm.com/download/win，选择合适版本的Git" target="_blank" rel="noopener">https://git-scm.com/download/win，选择合适版本的Git</a> for Windows Setup。</p><h3 id="2-2-Git配置"><a href="#2-2-Git配置" class="headerlink" title="2.2 Git配置"></a>2.2 Git配置</h3><p>Git自带Git config命令查配置信息。config有三个作用域：local、global和system。</p><ul><li>git config —local：只对某个仓库有效，读取当前使用仓库的 Git 目录中的 config 文件（即 <code>.git/config</code>）。</li></ul><ul><li>git config —global：对当前用户的所有仓库有效，读取<code>~/.gitconfig</code>中的配置信息。</li></ul><ul><li>git config —system：对系统所有登录的用户有效（不常用），读取的是<code>/etc/gitconfig</code> 文件中的配置信息。</li></ul><p>要想显示config的配置，加<code>--list</code>，如<code>git config --global --list</code>。</p><p>示例：配置user信息：user.name和user.email</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 配置全局用户git config --global user.name 'your_name'git config --global user.email 'your_email'# 删除全局配置$ git config --global --unset alias.xxx$ git config --global --unset user.xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Git基础"><a href="#3-Git基础" class="headerlink" title="3. Git基础"></a>3. Git基础</h2><h3 id="3-1-Git简介"><a href="#3-1-Git简介" class="headerlink" title="3.1 Git简介"></a>3.1 Git简介</h3><p>Git与其他版本控制系统（如Subversion, CVS）最大的区别就是对待数据的方法，<strong>Git是直接记录快照，而非差异比较</strong>。</p><p>大部分版本控制系统是以文件变更列表的方式存储信息，将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （通常称作<strong>基于差异</strong>的版本控制）。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//1-1594560709722.png" style="zoom:50%;"></p><p> 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件<strong>创建一个快照并保存这个快照的索引</strong>。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个快照流。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//2.png" style="zoom:50%;"></p><p>Git 中所有的数据在存储前都<strong>计算校验和</strong>，然后以校验和来引用。Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组 成的字符串，基于 Git 中文件的内容或目录结构计算出来。 Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p><p>Git仓库中的对象：<strong>提交（commit）</strong>对象、<strong>树（tree）</strong>对象和<strong>blob</strong>对象（保存着文件快照）。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//3.png" style="zoom: 50%;"></p><p>上图是执行commit操作后，Git仓库中对象的示意图。在进行提交操作时，Git 会保存一个提交对象（哈希值：98ca9），该对象会包含指向树对象的指针、作者信息、父对象等信息。树对象（92ec2）记录着目录结构和blob对象索引，blob对象会保存着文件快照。注意：首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象。</p><p>当再次修改后提交，产生的提交对象会包含一个指向上次提交对象（父对象）的指针。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//4-1594566565272.png" style="zoom:50%;"></p><p>Git的特点：最优的存储能力、非凡的性能、开源、很容易做备份、支持离线操作、很容易定制工作流程。</p><h3 id="3-2-创建Git仓库的场景"><a href="#3-2-创建Git仓库的场景" class="headerlink" title="3.2 创建Git仓库的场景"></a>3.2 创建Git仓库的场景</h3><ul><li>将已有的项目代码纳入Git管理</li></ul><pre><code>cd 项目代码所在文件夹git init</code></pre><p>执行<code>git init</code>命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有初始化Git 仓库中所有的必须文件。此时项目目录中的文件还未纳入跟踪管理，</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git status  # 查看状态# 输出On branch masterNo commits yetnothing to commit (create/copy files and use "git add" to track)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行<code>git add、git commit</code>命令，将文件纳入跟踪：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">touch readme.md  # 新建一个readme.md文件git add readme.md  # 添加到暂存区git commit -m 'readme' # 添加到本地仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>克隆现有的仓库</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git clone <url># 在克隆远程仓库时，自定义本地仓库名git clone <url> new_directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-3-Git三大分区"><a href="#3-3-Git三大分区" class="headerlink" title="3.3 Git三大分区"></a>3.3 Git三大分区</h3><p> Git 有三种状态，文件可能处于其中之一： 已提交（committed）、已修改（modified） 和 已暂存（staged）。</p><ul><li>已修改：表示修改了文件，但还没保存到数据库中。</li><li>已暂存：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li><li>已提交：表示数据已经安全地保存在本地数据库中。</li></ul><p>这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 Git仓库。</p><ul><li>工作区：本地项目代码目录</li><li>暂存区：英文叫stage或index，是一个文件，保存了将要提交的文件列表信息，在.git目录下。</li><li>本地库：用来保存项目的元数据和对象数据库。</li></ul><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//image-20200707234337713.png" style="zoom:50%;"></p><p>基本的 Git 工作流程如下：</p><ul><li>在工作区中编辑修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ul><h3 id="3-4-提交更新"><a href="#3-4-提交更新" class="headerlink" title="3.4 提交更新"></a>3.4 提交更新</h3><ul><li>提交到暂存区</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git add file1 file2 ...  # 添加指定文件到暂存区（追踪新增的指定文件）git add folder  # 添加指定目录到暂存区，包括子目录git add .  # 添加当前目录的所有文件到暂存区（追踪所有新增的文件）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>提交到本地仓库</li></ul><p>提交前，需要确认是否有修改或新建的文件尚未<code>git add</code>添加到暂存区的，否则提交时不会记录这些尚未暂存的变化。每次提交前，执行git status检查，然后再提交。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git status  # 检查git commit -m '提交信息说明' # 提交暂存区的文件git commit -am '提交信息说明' # 提交暂存区或跟踪过的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-5-删除文件"><a href="#3-5-删除文件" class="headerlink" title="3.5 删除文件"></a>3.5 删除文件</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git rm filename  # 删除工作区和暂存区的文件git rm --cached filename # 只删除暂存区的文件，不删除工作区的文件rm filename  # 仅删除工作区的文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：<code>rm</code>仅仅是物理删除，并没有将其从 git 的记录中剔除，而<code>git rm</code>删除文件的同时，还会将这个删除操作记录下来。</p><h3 id="3-6-重命名文件"><a href="#3-6-重命名文件" class="headerlink" title="3.6 重命名文件"></a>3.6 重命名文件</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git mv file-original file-renamed<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-7-查看提交历史"><a href="#3-7-查看提交历史" class="headerlink" title="3.7 查看提交历史"></a>3.7 查看提交历史</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git log --online  # 将日志记录一行行显示git log --num     # 显示最近num次提交历史git log --all     # 将所有记录都详细的显示出来git log --graph   # 图形化显示git log -p        # 按补丁格式显示每个提交引入的差异git log --pretty=format:"xxx" # 自定义显示格式git log --stat    # 显示每次提交的文件修改统计信息git log --online --all git log --all --graph<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过图形界面工具查看版本历史：<code>gitk --all</code></p><h3 id="3-8-撤销操作"><a href="#3-8-撤销操作" class="headerlink" title="3.8 撤销操作"></a>3.8 撤销操作</h3><ul><li>git commit —amend</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git commit --amend   # 编辑器会弹出上一次提交的信息，可以在这里修改提交信息git commit --amend -m '本次提交说明'  # 修复提交，同时修改提交信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>git reset HEAD file</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git reset HEAD file_name  # 取消暂存的某个文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-9-远程仓库"><a href="#3-9-远程仓库" class="headerlink" title="3.9 远程仓库"></a>3.9 远程仓库</h3><h4 id="3-9-1-查看远程仓库"><a href="#3-9-1-查看远程仓库" class="headerlink" title="3.9.1 查看远程仓库"></a>3.9.1 查看远程仓库</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git remote  # 查看已经配置的远程仓库服务器git remote -v # 显示需要读写远程仓库使用的Git保存的简写与其对应的URL。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 如果是克隆的仓库，使用<code>git remote</code>可以看到 origin，即克隆的仓库服务器的默认名字。如果想要查看某一个远程仓库的更多信息，可以使用以下命令：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git remote show <remote>  # <remote>为远程仓库名git remote show origin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-9-2-添加远程仓库"><a href="#3-9-2-添加远程仓库" class="headerlink" title="3.9.2 添加远程仓库"></a>3.9.2 添加远程仓库</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"> git remote add <shortname> <url><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意，本地库可能关联多个远程库，远程库的简写名shortname不能重复。有了shortname，后续拉取和推送数据，</p><h4 id="3-9-3-推送到远程仓库"><a href="#3-9-3-推送到远程仓库" class="headerlink" title="3.9.3 推送到远程仓库"></a>3.9.3 推送到远程仓库</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 将本地仓库的文件推送到远程分支# 如果远程仓库没有这个分支，会新建一个同名的远程分支# 如果省略远程分支名，则表示两者同名git push <远程主机名> <本地分支名>:<远程分支名> git push origin brancename# 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。git push origin :master# 将本地所有分支推送到远程仓库git push --all origin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-9-4-从远程仓库拉取"><a href="#3-9-4-从远程仓库拉取" class="headerlink" title="3.9.4 从远程仓库拉取"></a>3.9.4 从远程仓库拉取</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 从远程仓库下载新分支与数据git fetch  <remote> # 从远端仓库提取数据并尝试合并到当前分支git merge <remote> /branchName# 拉取并合并项目的一个分支git fetch origin branchNamegit merge origin/branchName# 等价于git pull origin branchname# 拉取所有远程分支到本地仓库中git pull<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>必须注意 git fetch 命令只会将数据下载到你的本地仓库，它并不会自动合并或修改你当前的工作。如果想合并，需要通过git merge命令。</p><h4 id="3-9-5-远程仓库重命名与移除"><a href="#3-9-5-远程仓库重命名与移除" class="headerlink" title="3.9.5 远程仓库重命名与移除"></a>3.9.5 远程仓库重命名与移除</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 远程仓库重命名git remote rename <原仓库名> <重命名的仓库名># 移除远程仓库git remote remove <仓库名>git remote rm <仓库名><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-10-打标签"><a href="#3-10-打标签" class="headerlink" title="3.10 打标签"></a>3.10 打标签</h3><h4 id="3-10-1-列出标签"><a href="#3-10-1-列出标签" class="headerlink" title="3.10.1 列出标签"></a>3.10.1 列出标签</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 列出所有标签git tag# 查看单个标签具体信息git show <tagname># 查找指定模式匹配的标签git tag l 'v1.1*'  # 查看所有1.1开头的标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-10-2-创建标签"><a href="#3-10-2-创建标签" class="headerlink" title="3.10.2 创建标签"></a>3.10.2 创建标签</h4><p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p><ul><li>创建附注标签</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"> # -a指定标签名，-m指定说明文字 git tag -a v1.0 -m "version 1.0 released" git show   # 查看标签信息和与之对应的提交信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>创建轻量标签</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git tag v1.1  #<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>后期打标签</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 可以对过去的commit打标签，需指定commit idgit tag -a v1.3 <commit id><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-10-3-共享标签"><a href="#3-10-3-共享标签" class="headerlink" title="3.10.3 共享标签"></a>3.10.3 共享标签</h4><p>默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到 共享服务器上。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 推送一个本地标签到远程git push origin <tagname>#  推送全部未推送过的本地标签到远程git push origin --tags<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-10-4-删除标签"><a href="#3-10-4-删除标签" class="headerlink" title="3.10.4 删除标签"></a>3.10.4 删除标签</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 删除本地标签git tag -d <tagname># 删除远程标签# 方式一：先删除本地，再删除远程git tag -d <tagname>git push <remote> :refs/tags/<tagname> #将冒号前面的空值推送到远程标签名，从而高效地删除它# 方式二：直接删除远程标签git push <remote> --delete <tagname><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-11-Git别名"><a href="#3-11-Git别名" class="headerlink" title="3.11 Git别名"></a>3.11 Git别名</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">$ git config --global alias.co checkout$ git config --global alias.ss status$ git config --global alias.cm commit$ git config --global alias.br branch$ git config --global alias.rg reflog$ git config --global alias.last 'log -1 HEAD'  # 执行git last 即可查看最后一次提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，Git 只是简单地将别名替换为对应的命令。 然而，如果想要执行外部命令，需要在命令前面加入 <code>!</code> 符号。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"> git config --global alias.visual '!gitk' git visual # 打开gitk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-12-对比文件差异"><a href="#3-12-对比文件差异" class="headerlink" title="3.12 对比文件差异"></a>3.12 对比文件差异</h3><ul><li>比较暂存区与HEAD文件差异</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 比较暂存区与HEAD文件的差异，即与当前分支最新提交的对比git diff --cached/--staged<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>比较工作区与暂存区</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 查看工作区和暂存区所有文件的对比git diff# 查看工作区和暂存区单个文件的对比git diff -- filename查看工作区和暂存区所有文件的对比，并显示出所有有差异的文件列表git diff --stat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：如果修改了某个文件，但是没有提交到暂存区，这时候会有对比的内容。但是修改内容一旦提交到暂存区，就不会有对比的内容(因为暂存区已经更新)。如果你新建了一个文件，但是没有提交到暂存区，这时候 diff 是没有结果的。</p><ul><li>查看工作区与HEAD的对比</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git diff HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看工作区与最新提交到本地仓库的快照的对比</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git diff branchname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>不同提交的文件差异比较</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 查看两个本地分支中某一个文件的对比git diff branchname1 branchname2 -- filename# 查看两个 commit中某一文件的对比git diff commit1 commit2 -- filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>不同分支比较</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 查看两个本地分支所有的对比git diff branchname1 branchname2# 查看远程分支和本地分支的对比git diff origin/branchname branchname<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-13-文件恢复与取消"><a href="#3-13-文件恢复与取消" class="headerlink" title="3.13 文件恢复与取消"></a>3.13 文件恢复与取消</h3><ul><li>暂存区恢复成和HEAD一样</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 恢复暂存区git reset HEAD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>工作区文件恢复成和暂存区一样</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 恢复工作区的文件git checkout -- filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>取消暂存区部分文件的更改</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git reset HEAD -- filename1 filename2 ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>取消最近几次提交</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git reset --hard <commit_id>  # 慎用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-Git分支"><a href="#4-Git分支" class="headerlink" title="4. Git分支"></a>4. Git分支</h2><h3 id="4-1-分支简介"><a href="#4-1-分支简介" class="headerlink" title="4.1 分支简介"></a>4.1 分支简介</h3><p><strong>Git分支</strong>：本质上是指向提交对象的可变指针。Git默认分支名字是 master，会在每次提交时自动向前移动，指向最后的提交对象。注意：master分支并不是一个特殊分支，和其他分支完全没有区别，之所以几乎每一 个仓库都有 master 分支，是因为<code>git init</code> 命令默认创建它。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 创建新分支git branch testing  # 在当前所在的提交对象上创建一个指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//5.png" style="zoom: 30%;"></p><p>从上图可以看到，master和testing都指向同一个commit对象，<strong>HEAD指向的分支为当前所在的分支</strong>。我们可以通过 git log 命令查看各个分支当前所指的对象：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git log --oneline --decorate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要切换到一个已存在的分支，你需要使用 git checkout 命令：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git checkout testing  # HEAD指向testing分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//image-20200712233210665.png" alt="image-20200712233210665"></p><p>上图左图是在testing分支上再次提交，右图是再次切换回master分支。从左图可以看到testing分支向前移动，而master没有。右图可以看到切回master后，HEAD指向了master。注意，切换到master后，将工作目录恢复成 master 分支所指向的快照内容。 也就是说，现在做修改的话，项目将始于一个较旧的版本。<u>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支， 你的工作目录会恢复到该分支最后一次提交时的样子。</u> </p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//8.png" style="zoom:50%;"></p><p>上图展示的是在master分支上修改文件后再次提交，产生了分叉历史。我们可以使用 git log 命令查看分叉历史：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git log --oneline --decorate --graph --all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2-新建分支"><a href="#4-2-新建分支" class="headerlink" title="4.2 新建分支"></a>4.2 新建分支</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"> # 在创建一个新分支后立即切换过去 git checkout -b <branchname> # 等价于以下两个命令 git branch <branchname> git checkout <branchname><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在别的分支下新建一个分支，新分支会复制当前分支的内容。注意：如果当前分支有修改，但是没有提交到仓库，此时修改的内容是不会被复制到新分支的。</p><h3 id="4-3-删除分支"><a href="#4-3-删除分支" class="headerlink" title="4.3 删除分支"></a>4.3 删除分支</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 删除本地分支,会阻止删除包含未合并更改的分支$ git brnach -d branchname# 强制删除一个本地分支，即使包含未合并更改的分支$ git branch -D branchname# 删除远程分支$ git push origin  :远程分支名  # 推送一个空分支到远程分支，其实就相当于删除远程分支$ git push origin --delete 远程分支名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-分支合并"><a href="#4-4-分支合并" class="headerlink" title="4.4 分支合并"></a>4.4 分支合并</h3><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git merge <brancename><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有时在合并时会遇到冲突，此时可以通过<code>git status</code>命令查看因包含合并冲突而处于未合并 （unmerged）状态的文件。任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。解决文件合并冲突方式：</p><ul><li>可手动合并这些冲突内容，在解决了所有文件的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。</li><li>使用图形化工具来解决冲突，执行 <code>git mergetool</code>。</li></ul><h3 id="4-5-查看分支"><a href="#4-5-查看分支" class="headerlink" title="4.5 查看分支"></a>4.5 查看分支</h3><ul><li>查看所有分支列表</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 查看本地分支git branch  # # 如果分支前有*号，则表示当前所在分支git branch -l# 查看远程分支git branch -r# 查看所有分支（本地分支+远程分支）git branch -a# 查看每一个分支的最后一次提交git branch -v # 查看所有分支并带上最新的提交信息git branch -av# 查看本地分支对应的远程分支git branch -vv<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查看合并与未合并的分支</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git branch --merged   # 查看已经合并到当前分支的所有分支git branch  --no-merged # 查看所有包含未合并工作的分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-6-分支开发工作流"><a href="#4-6-分支开发工作流" class="headerlink" title="4.6 分支开发工作流"></a>4.6 分支开发工作流</h3><h4 id="4-6-1-长期分支"><a href="#4-6-1-长期分支" class="headerlink" title="4.6.1 长期分支"></a>4.6.1 长期分支</h4><p>在整个项目开发周期的不同阶段，我们可以同时拥有多个开放的分支，可以定期把某些主题分支合并到其他分支中。比如，在项目开发中，在master分支上保留完全稳定的代码（可能仅 仅是已经发布或即将发布的代码），而在develop分支上做后续的一些开发，develop分支不能保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//1-1594650692073.png" style="zoom:50%;"></p><p>随着你的提交而不断右移的指针， 稳定分支的指针总是在提交历史中落后一大截， 而前沿分支的指针往往比较靠前。注意：使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一 个非常庞大或者复杂的项目中工作时。</p><h4 id="4-6-2-主题分支"><a href="#4-6-2-主题分支" class="headerlink" title="4.6.2 主题分支"></a>4.6.2 主题分支</h4><p>主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来<strong>实现单一特性或其相关工作</strong>。在一些主题分支上提交一些更新后，可以合并入主干分支，并删除它们。</p><h3 id="4-7-远程分支"><a href="#4-7-远程分支" class="headerlink" title="4.7 远程分支"></a>4.7 远程分支</h3><p>远程引用是对远程仓库的引用（指针），包括分支、标签等等。<strong>远程跟踪分支</strong>是远程分支状态的引用，以 <code>&lt;remote&gt;/&lt;branch&gt;</code> 的形式命名。</p><p>示例：从一个Git服务器（ git.ourcompany.com）克隆项目，<code>clone</code> 命令会自动将其命名为 <code>origin</code>，拉取它的所有数据， 创建一个指向它的 <code>master</code> 分支的指针，并且在本地将其命名为<code>origin/master</code>。 Git 也会给你一个与 <code>origin</code> 的 <code>master</code> 分支在指向同一个地方的本地 <code>master</code> 分支。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//1-1594655195620.png" style="zoom: 40%;"></p><p>如果在本地做了一些修改，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，我们同步远程仓库数据后，产生两个不同走向的分支。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//2-1594655337945.png" style="zoom:40%;"></p><h4 id="4-7-1-推送分支"><a href="#4-7-1-推送分支" class="headerlink" title="4.7.1 推送分支"></a>4.7.1 推送分支</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">git push <remote> <branch>git push <remote> <local_brance>:<remote_branch> # 将本地local_brance分支推送到远程remote_branch分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-7-2-跟踪分支"><a href="#4-7-2-跟踪分支" class="headerlink" title="4.7.2 跟踪分支"></a>4.7.2 跟踪分支</h4><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”。跟踪分支是与远程分支有直接关系的本地分支。当克隆一个仓库时，它通常会自动地创建一个跟踪 <code>origin/master</code> 的 <code>master</code> 分支。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"> # 创建一个跟踪分支 git checkout -b <branch> <remote>/<branch>  git checkout --track <remote>/<branch> git branch -vv # 查看跟踪分支，即查看本地分支对应的远程分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-7-3-拉取数据"><a href="#4-7-3-拉取数据" class="headerlink" title="4.7.3 拉取数据"></a>4.7.3 拉取数据</h4><p> <code>git fetch</code> 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容，只会获取数据然 后让你自己合并。 <code>git pull</code>则相当于 <code>git fetch</code>和<code>git merge</code>，会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。</p><h4 id="4-7-4-删除远程分支"><a href="#4-7-4-删除远程分支" class="headerlink" title="4.7.4 删除远程分支"></a>4.7.4 删除远程分支</h4><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"> git push <remote> --delete <branch><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-8变基"><a href="#4-8变基" class="headerlink" title="4.8变基"></a>4.8变基</h3><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//1-1594734805333.png" style="zoom:40%;"></p><p>在 Git 中整合来自不同分支的修改主要有两种方法：<code>merge</code> 以及 <code>rebase</code>。 如果我们想将分支master和experiment的更新合并，常用的一种方式是使用<code>merge</code>合并，即把两个分支的最新快照（C3 和 C4）以及二者最近的 共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交），如下图所示。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//2-1594734977961.png" style="zoom:50%;"></p><p>除了上面这种方式，还有一种方式：提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次，这种操作叫<strong>变基（rebase）</strong>。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//image-20200714220118779.png" alt="image-20200714220118779"></p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 以检出 experiment 分支，然后将它变基到 master 分支上git checkout experimentgit rebase master# 在回到 master 分支，进行一次快进合并git checkout mastergit merge experiment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>未完待续。。。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora+PicGo+Github/Gitee搭建免费图床</title>
      <link href="/posts/9b15a04a.html"/>
      <url>/posts/9b15a04a.html</url>
      
        <content type="html"><![CDATA[<p>从2020年开始了写博客之旅，并利用Hexo和Github搭建了个人博客，这里记录一下自认为比较好写文章的工具：使用Typora编写markdown博客文章，使用Github/Gitee作为图床，并使用新版本Typora联合PicGo软件实现图片自动上传。</p><h2 id="1-安装与配置PicGo"><a href="#1-安装与配置PicGo" class="headerlink" title="1. 安装与配置PicGo"></a>1. 安装与配置PicGo</h2><h3 id="1-1-安装PicGo"><a href="#1-1-安装PicGo" class="headerlink" title="1.1 安装PicGo"></a>1.1 安装PicGo</h3><p>PicGo是一个用于快速上传图片并获取图片URL链接的工具，选择合适的版本进行<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">下载</a>，可访问PicGo的<a href="https://picgo.github.io/PicGo-Doc/zh/guide/" target="_blank" rel="noopener">官方文档</a>进一步了解其功能和用法。这里我是win10系统，下载的是<a href="https://github.com/Molunerfinn/PicGo/releases/download/v2.3.0-beta.0/PicGo-Setup-2.3.0-beta.0.exe" target="_blank" rel="noopener">最新的版本</a>。下载可能会很慢，可借助迅雷进行下载。下载后双击进行安装，注意不要安装在C盘。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//ImgHosting-1.png" style="width:600px"></p><h3 id="1-2-配置PicGo"><a href="#1-2-配置PicGo" class="headerlink" title="1.2 配置PicGo"></a>1.2 配置PicGo</h3><p>这里仅介绍PicGo的几种配置，详细的可以参考<a href="https://picgo.github.io/PicGo-Doc/zh/guide/" target="_blank" rel="noopener">官方指南</a>。</p><ul><li>自定义快捷键</li></ul><p>在Windows中，快捷上传的快捷键是<code>Ctrl+Shift+P</code>，点击PicoGo左侧栏的PicGo设置和修改快捷键设置，可以按自己喜好修改快捷键。此外，PicGo有快速截图并上传的功能，在插件设置中搜索quick-capture，然后进行安装，默认的快捷键是<code>Ctrl+Shift+0</code>，也可以进行修改。</p><ul><li>上传前重命名</li></ul><p>如果你想在图片上传前能够有机会改动你的图片名，我们可以在PicGo中打开上传前重命名开关，这样之后在上传的时候就会弹出一个小窗口让你重命名文件。如果你不想重命名，点击确定、取消或者直接关闭这个窗口都是可以的。如果你想要重命名就在输入框里输入想要更改的名字，然后点击确定即可。</p><h2 id="2-搭建仓库图床"><a href="#2-搭建仓库图床" class="headerlink" title="2. 搭建仓库图床"></a>2. 搭建仓库图床</h2><p>PicGo支持的图床很多，如七牛图床、腾讯云COS、阿里云OSS、Github图床、Gitee图床等等，这里我们介绍基于Github和Gitee来搭建免费的图床。</p><h3 id="2-1-搭建Github图床"><a href="#2-1-搭建Github图床" class="headerlink" title="2.1 搭建Github图床"></a>2.1 搭建Github图床</h3><h4 id="2-1-1-新建Github仓库并生成Token"><a href="#2-1-1-新建Github仓库并生成Token" class="headerlink" title="2.1.1 新建Github仓库并生成Token"></a>2.1.1 新建Github仓库并生成Token</h4><ul><li>注册Github用户</li><li>在Github上新建一个用于存储的仓库，点击New repository创建一个新仓库。</li></ul><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//ImgHosting-2.png" style="width:600px"></p><p>之前已创建了一个名为ImgHosting的仓库，这里仓库的名为ImgHosting_new避免冲突。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//ImgHosting-3.png" style="width:600px"></p><ul><li>生成一个Personal access tokens</li></ul><p>在Github中依次点击<u>Settings-&gt;Developer settings-&gt;Personal access tokens-&gt;Generate new token</u>，勾选repo权限，填写描述，然后点击<code>Generate token</code>按钮，生成token。由于生成的token只会在第一次显示，建议保存下来备用，否则后续只能重新生成token。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//ImgHosting-4.png" style="width:600px"></p><h4 id="2-1-2-PicGo配置Github图床"><a href="#2-1-2-PicGo配置Github图床" class="headerlink" title="2.1.2 PicGo配置Github图床"></a>2.1.2 PicGo配置Github图床</h4><p>打开PicGo，点击图床设置，对Github图床进行设置。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//ImgHosting-5.png" style="width:600px"></p><p>配置说明如下：</p><ul><li>设定仓库名：按照照“用户名/仓库名”的格式填写，比如我的weylin/ImgHosting。</li><li>设定分支名：默认主分支master即可。</li><li>设定Token：将之前生成的token复制粘贴到这里。</li><li>指定存储路径：图床仓库目录下的子目录，默认是根目录。</li><li>设定自定义域名：自定义域名的作用是在上传图片后成功后，PiGo将以“自定义域名+子目录名+图片名”生成访问连接。这里我们的自定义域名为：<u><a href="https://cdn.jsdelivr.net/gh/用户名/仓库名" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/用户名/仓库名</a></u>，用的是cdn.jsdelivr.net提升图片的加载速度。</li></ul><h3 id="2-2-搭建Gitee图床"><a href="#2-2-搭建Gitee图床" class="headerlink" title="2.2 搭建Gitee图床"></a>2.2 搭建Gitee图床</h3><h4 id="2-2-1-新建Gitee仓库并生成个人token"><a href="#2-2-1-新建Gitee仓库并生成个人token" class="headerlink" title="2.2.1 新建Gitee仓库并生成个人token"></a>2.2.1 新建Gitee仓库并生成个人token</h4><ul><li>注册Gitee账号</li><li>在Gitee上新建一个仓库，点击右上角+号新建仓库。</li></ul><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//ImgHosting-6.png" style="width:600px"></p><p>填写好新建仓库的信息，点击创建即可。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//ImgHosting-7.png" style="width:600px"></p><ul><li>生成个人token</li></ul><p>在个人主页，找到安全设置栏的私人令牌，点击生成新令牌，填写描述信息，提交生成私人令牌。与Github生成token一样，只会显示依次，要注意保存备用。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//ImgHosting-8.png" style="width:600px"></p><h4 id="2-2-2-PicGo配置Gitee图床"><a href="#2-2-2-PicGo配置Gitee图床" class="headerlink" title="2.2.2 PicGo配置Gitee图床"></a>2.2.2 PicGo配置Gitee图床</h4><p>PicGo图床配置默认是没有Gitee图床的，需要我们安装Gitee插件。在PicGo插件设置搜索Gitee，两个插件可以选择一个安装。注意：安装插件前本机需要已安装node.js，插件下载需要使用到 node.js 的npm。windows环境下安装node.js可以参考：安装node.js，参考：<a href="https://jingyan.baidu.com/article/48b37f8dd141b41a646488bc.html。" target="_blank" rel="noopener">https://jingyan.baidu.com/article/48b37f8dd141b41a646488bc.html。</a></p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//ImgHosting-9.png" style="width:600px"></p><p>返回到图床设置，开始设置Gitee图床。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//ImgHosting-10.png" style="width:600px"></p><p>配置说明如下：</p><ul><li>url：gitee地址，即<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a></li><li>owner：gitee用户名。</li><li>repo：图床仓库名。</li><li>path：图床仓库中的子目录，默认是根目录。</li><li>token：之前生成的私人令牌。</li><li>message：信息说明，可以不填。</li></ul><p>在完成上述图床搭建操作后，我们就可以使用PicGo来上传图片到Github或Gitee，并生成图片访问链接了。我平时是使用Typora这个Markdown编辑器来写博客文章，之前插入图片是使用 PicGo上传到图床，然后将地址粘贴到Typora中。目前新版本的Typora已支持PicGo服务，可以通过设置Typora实现快速插入图片。</p><h2 id="3-Typora配置PicGo"><a href="#3-Typora配置PicGo" class="headerlink" title="3. Typora配置PicGo"></a>3. Typora配置PicGo</h2><h3 id="3-1-Typora图像配置"><a href="#3-1-Typora图像配置" class="headerlink" title="3.1 Typora图像配置"></a>3.1 Typora图像配置</h3><p>依次打开Typora的文件-&gt;偏好设置-&gt;图像，进行配置：</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//ImgHosting-11.png" style="width:600px"></p><p>然后，点击<u>验证图片上传选项</u>验证配置是否正确，由于我PicGo中PicGo-Server设置中的监听端口默认为36686，与下图中的36677不一致而验证失败，将PicGo中的端口设置为36677验证成功。</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//ImgHosting-12.png" style="width:600px"></p><p>到这里，我们已经成功将Typora+PicGo+Github/Gitee配置好了，可以愉快的文章写作啦！将图片复制到Typora中，点击上传图片，即可将图片上传到Gitee图床仓库中。</p><h2 id="4-可能遇到的问题"><a href="#4-可能遇到的问题" class="headerlink" title="4. 可能遇到的问题"></a>4. 可能遇到的问题</h2><ul><li>出现 Failed to fetch</li></ul><p>确认在PicGo中打开了Server服务，监听端口与typora检验端口保持一致</p><ul><li>上传图片出现{“success”,false}</li></ul><p>常常是由于文件名冲突引起的。如果不是，可重启服务和电脑尝试解决。</p><p><strong>本文参考：</strong></p><p><a href="https://www.a2data.cn/posts/36204.html" target="_blank" rel="noopener">最快图床搭建</a></p><p><a href="https://www.jianshu.com/p/a1e2cf01e05f" target="_blank" rel="noopener">Typora+PicGo+Github/Gitee搭建免费稳定的图床</a></p><p><a href="https://blog.csdn.net/qq_38013157/article/details/105837607" target="_blank" rel="noopener">github+picgo+typora搭建图床</a></p><p><a href="https://www.jianshu.com/p/f6ccdae3c95c" target="_blank" rel="noopener">使用Typora+PicGo+gitee快速编辑</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图床 </tag>
            
            <tag> Typora </tag>
            
            <tag> Gitee </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（十六）：并发编程</title>
      <link href="/posts/a3085160.html"/>
      <url>/posts/a3085160.html</url>
      
        <content type="html"><![CDATA[<p>在我们计算机中，我们可以同时运行多个软件，比如一边听音乐一遍浏览网页。这些看似很正常，但仔细想想，为什么计算机可以做到这么多软件同时运行呢？这就涉及到计算机中的两个重要概念：多进程和多线程。</p><h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h2><h3 id="1-1-进程与多进程"><a href="#1-1-进程与多进程" class="headerlink" title="1.1 进程与多进程"></a>1.1 进程与多进程</h3><p><strong>进程（Process）：是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。</strong>比如打开一个浏览器，这就开启了一个浏览器进程。</p><p><strong>进程是线程的集合，由一个或多个线程构成的，线程是操作系统进行运算调度的最小单位，是进程中的一个最小运行单元。</strong>比如在浏览器中，我们可以在多个选项卡中打开多个页面，有的页面在播放音乐，有的页面在播放视频等等，它们可以同时运行，互不干扰。这一个个任务实际上就对应着一个个线程的执行。</p><p><strong>多进程，顾名思义，就是启用多个进程同时运行</strong>，比如打开浏览器进程，同时打开文本编辑器进程等。多进程的运行意味着有大于或等于进程数量的线程在运行。</p><h3 id="1-2-并发与并行"><a href="#1-2-并发与并行" class="headerlink" title="1.2 并发与并行"></a>1.2 并发与并行</h3><p>我们知道，一个程序在计算机中运行，其底层是处理器通过运行一条条的指令来实现的。</p><p><strong>并发：</strong>指在同一时刻只能有一条指令执行，但多个线程的指令被快速的轮换执行。由于处理器执行指令的速度和切换的速度非常非常快，人完全感知不到计算机在这个过程中有多个线程切换上下文执行的操作，这就使得宏观上看起来多个线程在同时运行。但在微观上并不是同时执行的，只是把时间分成若干段，使多个线程快速交替的执行。</p><p><strong>并行：</strong>指同一时刻，有多条指令在多个处理器上同时执行，并行必须要依赖于多个处理器。不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的。</p><p>并行只能在多处理器系统中存在，如果我们的计算机处理器只有一个核，那就不可能实现并行。而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。</p><h3 id="1-3-多进程的优势"><a href="#1-3-多进程的优势" class="headerlink" title="1.3 多进程的优势"></a>1.3 多进程的优势</h3><p>在一个进程中，由于GIL（全局解释器锁）的存在，导致不论是在单核还是多核条件下，在同一时刻只能运行一个线程，导致 Python 多线程无法发挥多核并行的优势。</p><p>GIL最初设计是出于数据安全而考虑的。在 Python 多线程下，每个线程的执行方式如下：获取 GIL、执行对应线程的代码、释放 GIL。在一个 Python 进程中，由于GIL 只有一个，即使是多核条件下，一个 Python 进程下的多个线程，同一时刻也只能执行一个线程。</p><p>对于多进程来说，<strong>每个进程都有属于自己的 GIL</strong>，所以，在多核处理器下，多进程的运行是不会受 GIL 的影响的。因此，多进程能更好地发挥多核的优势。</p><p>对于爬虫这种 IO 密集型任务来说，多线程和多进程影响差别并不大。对于计算密集型任务来说，Python 的多进程相比多线程，其多核运行效率会有成倍的提升。总的来说，Python 的多进程整体来看是比多线程更有优势的。所以，在条件允许的情况下，能用多进程就尽量用多进程。</p><h3 id="1-4-Python中多进程的实现"><a href="#1-4-Python中多进程的实现" class="headerlink" title="1.4 Python中多进程的实现"></a>1.4 Python中多进程的实现</h3><p>在 Python 中有内置的库 <code>multiprocessing</code>来实现多进程，提供了一系列的组件，如 Process（进程）、Queue（队列）、Semaphore（信号量）、Pipe（管道）、Lock（锁）、Pool（进程池）等。</p><h4 id="1-4-1-直接使用Process类创建进程"><a href="#1-4-1-直接使用Process类创建进程" class="headerlink" title="1.4.1 直接使用Process类创建进程"></a>1.4.1 直接使用Process类创建进程</h4><p>multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={})</p><p>参数说明：</p><ul><li>group：分组，实际很少用，默认为None。</li><li>target ：表示调用对象，你可以传入方法的名字。</li><li>name：进程名称。</li><li>args： 表示被调用对象的位置参数元组，如target是函数func，有参数m, n，那么args传入(m, n)即可。</li><li>kwargs：表示调用对象的关键字参数字典。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">import multiprocessingimport timedef task(index):    time.sleep(2)    print(f'Process: {index}')if __name__ == '__main__':    print('Main Process Start')    print(f'CPU number: {multiprocessing.cpu_count()}')    for i in range(3):        p = multiprocessing.Process(target=task, args=(i,))        p.start()    for p in multiprocessing.active_children():        print(f'Child process name: {p.name} id: {p.pid}')    print('Main Process End')# 输出Main Process StartCPU number: 8Child process name: Process-2 id: 4200Child process name: Process-1 id: 11332Child process name: Process-3 id: 7680Main Process End<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面示例中创建了3个子进程。<code>multiprocessing .cpu_count()</code>用来获取当前机器 CPU 的核心数量。<code>multiprocessing.active_children</code> 方法用来获取当前还在运行的所有进程。我们要获取进程的名字和ID，可通过进程实例<code>p. name</code>和<code>p.pid</code>获取。</p><h4 id="1-4-2-继承-Process-类来创建进程"><a href="#1-4-2-继承-Process-类来创建进程" class="headerlink" title="1.4.2 继承 Process 类来创建进程"></a>1.4.2 继承 Process 类来创建进程</h4><p>通过继承的方式创建一个进程类，进程的基本操作在子类的 run 方法中实现。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from multiprocessing import Processimport timeclass MyProcess(Process):    def __init__(self, loop):        Process.__init__(self)        self.loop = loop    def run(self):        for num in range(self.loop):            time.sleep(1)            print(f'Pid: {self.pid} Name: {self.name} LoopCount: {num}')if __name__ == '__main__':    for i in range(1, 3):        p = MyProcess(i)        p.start()# 输出Pid: 2956 Name: MyProcess-1 LoopCount: 0Pid: 8912 Name: MyProcess-2 LoopCount: 0Pid: 8912 Name: MyProcess-2 LoopCount: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-3-守护进程"><a href="#1-4-3-守护进程" class="headerlink" title="1.4.3 守护进程"></a>1.4.3 守护进程</h4><p>如果一个进程被设置为守护进程，则在主进程执行结束后，如果子进程仍未执行完则会自动被终止。在Python中，我们可以通过设置 daemon 属性来控制是否为守护进程。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import multiprocessingimport timedef task(index):    time.sleep(2)    print(f'Process: {index}')if __name__ == '__main__':    print('Main Process Start')    for i in range(3):        p = multiprocessing.Process(target=task, args=(i,))        p.daemon = True        p.start()    print('Main Process End')# 输出Main Process StartMain Process End<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-4-进程等待"><a href="#1-4-4-进程等待" class="headerlink" title="1.4.4 进程等待"></a>1.4.4 进程等待</h4><p>如果我们想子进程执行结束后，父进程再结束，可以使用<code>join()</code>方法。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from multiprocessing import Processimport timeclass MyProcess(Process):    def __init__(self, loop):        Process.__init__(self)        self.loop = loop    def run(self):        for num in range(self.loop):            time.sleep(1)            print(f'Pid: {self.pid} Name: {self.name} LoopCount: {num}')# 不设置进程等待if __name__ == '__main__':    print('Main Process Start')    for i in range(1, 3):        p = MyProcess(i)        p.daemon = True        p.start()    print('Main Process End')# 输出Main Process StartMain Process End# 设置进程等待if __name__ == '__main__':    print('Main Process Start')    processes = []    for i in range(1, 3):        p = MyProcess(i)        processes.append(p)        p.daemon = True        p.start()    for p in processes:        p.join()    print('Main Process End')# 输出Main Process StartPid: 5920 Name: MyProcess-1 LoopCount: 0Pid: 17836 Name: MyProcess-2 LoopCount: 0Pid: 17836 Name: MyProcess-2 LoopCount: 1Main Process End<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<code>join()</code>方法有一个可选的<code>timeout</code>参数，默认为None。默认情况下，如果有子进程没有运行完毕，主进程会一直等待。但是，如果子进程出现问题陷入了死循环，主进程也会无限等待下去。为解决这个问题，可以给 join 方法传递一个超时参数<code>timeout</code>，代表最长等待秒数。如果子进程没有在这个指定秒数之内完成，会被强制返回，主进程不再会等待。</p><h4 id="1-4-5-中止进程"><a href="#1-4-5-中止进程" class="headerlink" title="1.4.5 中止进程"></a>1.4.5 中止进程</h4><p>如果我们想终止某个子进程，可以使用<code>terminate</code> 方法。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import multiprocessingimport timedef task():    time.sleep(2)if __name__ == '__main__':    p = multiprocessing.Process(target=task)    print('Before:', p, p.is_alive())    p.start()    print('During:', p, p.is_alive())    p.terminate()    print('Terminate:', p, p.is_alive())    p.join()    print('Joined:', p, p.is_alive())# 输出Before: <Process(Process-1, initial)> FalseDuring: <Process(Process-1, started)> TrueTerminate: <Process(Process-1, started)> TrueJoined: <Process(Process-1, stopped[SIGTERM])> False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在进程运行不同的阶段，我们可以通过 <code>is_alive</code> 方法判断当前进程是否还在运行。注意：在调用 terminate 方法之后，记得要调用一下 join 方法，这里调用 join 方法可以为进程提供时间来更新对象状态，用来反映出最终的进程终止效果。</p><h4 id="1-4-6-进程互斥锁"><a href="#1-4-6-进程互斥锁" class="headerlink" title="1.4.6 进程互斥锁"></a>1.4.6 进程互斥锁</h4><p>进程之间数据隔离，但是共享一套文件系统，当多个进程同时修改同一块数据时，可能会产生异常。当有多个进程同时读写同一个文件时，为了避免数据读写产生异常，我们需要为正在操作的进程加上<code>互斥锁</code>。</p><p>示例一：不加互斥锁</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from multiprocessing import Process, Lockimport timeimport randomclass MyProcess(Process):    def __init__(self, index):        Process.__init__(self)        self.index = index    def run(self):        print(f'{self.index}, Pid: {self.pid} is running')        time.sleep(random.random())        print(f'{self.index}, Pid: {self.pid} is done')if __name__ == '__main__':    for i in range(1, 5):        p = MyProcess(i)        p.start()# 输出2, Pid: 17572 is running2, Pid: 17572 is done3, Pid: 17892 is running3, Pid: 17892 is done4, Pid: 14376 is running4, Pid: 14376 is done1, Pid: 17420 is running1, Pid: 17420 is done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例二：添加互斥锁</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from multiprocessing import Process, Lockimport timeimport randomclass MyProcess(Process):    def __init__(self, index, mutex):        Process.__init__(self)        self.index = index        self.mutex = mutex    def run(self):        self.mutex.acquire()        print(f'{self.index}, Pid: {self.pid} is running')        time.sleep(random.random())        print(f'{self.index}, Pid: {self.pid} is done')        self.mutex.release()if __name__ == '__main__':    mutex = Lock()    for i in range(1, 5):        p = MyProcess(i, mutex)        p.start()# 输出1, Pid: 17852 is running1, Pid: 17852 is done2, Pid: 17044 is running2, Pid: 17044 is done3, Pid: 4844 is running3, Pid: 4844 is done4, Pid: 11176 is running4, Pid: 11176 is done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python">from multiprocessing import Process, Lockimport timeimport randomimport osdef task(index, mutex):    mutex.acquire()    print(f'{index}, Pid: {os.getpid()} is running')    time.sleep(random.random())    print(f'{index}, Pid: {os.getpid()} is done')    mutex.release()if __name__ == '__main__':    mutex = Lock()    for i in range(1, 5):        p = Process(target=task, args=(i, mutex))        p.start()# 输出1, Pid: 13196 is running1, Pid: 13196 is done2, Pid: 16272 is running2, Pid: 16272 is done3, Pid: 11708 is running3, Pid: 11708 is done4, Pid: 13432 is running4, Pid: 13432 is done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-7-信号量"><a href="#1-4-7-信号量" class="headerlink" title="1.4.7 信号量"></a>1.4.7 信号量</h4><p>进程互斥锁可以使同一时刻只有一个进程能访问共享资源，但有时候我们需要允许多个进程来访问共享资源，同时还需要限制能访问共享资源的进程的数量。信号量是进程同步过程中一个比较重要的角色。它可以控制临界资源的数量，实现多个进程同时访问共享资源，限制进程的并发量。</p><p>信号量：相当于一个计数器，可以指定同时访问资源的进程数。进程每消耗信号量时内置计数器<code>-1</code>，释放信号量时计数器<code>+1</code>。若计数器为0时，其他进程就停止访问信号量，一直阻塞直到其他进程释放信号量。</p><p>信号量Semaphore是一个计数器，常用的方法：</p><ul><li>acquire(blocking = True, timeout=None)：请求一个信号量，计数器<code>+1</code>。</li><li>release()：释放一个信号量，计数器<code>-1</code>。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">from multiprocessing import Process, Semaphoreimport time, randomdef have_meal(i, sem):    sem.acquire()    print(u'%s Enter the restaurant' %i)    time.sleep(random.randint(1, 5))    print(u'%s Leave the restaurant' %i)    sem.release()if __name__ == "__main__":    print('Main Process Start')    sem = Semaphore(3)    processes = []    for i in range(5):        p = Process(target=have_meal, args=(i, sem))        processes.append(p)        p.start()    for p in processes:        p.join()    print('Main Process End')# 输出Main Process Start0 Enter the restaurant1 Enter the restaurant2 Enter the restaurant1 Leave the restaurant3 Enter the restaurant3 Leave the restaurant4 Enter the restaurant2 Leave the restaurant0 Leave the restaurant4 Leave the restaurantMain Process End<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-8-队列"><a href="#1-4-8-队列" class="headerlink" title="1.4.8 队列"></a>1.4.8 队列</h4><p> multiprocessing模块中的队列（Queue）：可以作为进程通信的共享队列使用，在进程间共享数据。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from multiprocessing import Process, Queueimport os, timedef write(q):    print("Write subprocess start：%s" % os.getpid())    for i in [1, 2, 3, 4]:        q.put(i)   # put方法用以插入数据到队列中        time.sleep(1)    print("Write subprocess end：%s" % os.getpid())def read(q):    print("Read subprocess start：%s" % os.getpid())    while True:        value = q.get()  # 从队列读取数据        print(value)    print("Read subprocess end：%s" % os.getpid())if __name__ == "__main__":    print("Main Process Start")    q = Queue()    pw = Process(target=write, args=(q, ))    pr = Process(target=read, args=(q, ))    pw.start()    pr.start()    pw.join()    pr.terminate()   # pr进程是一个死循环，强行结束。    print("Main Process End")# 输出Main Process StartWrite subprocess start：16564Read subprocess start：109681234Write subprocess end：16564Main Process End<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-9-管道"><a href="#1-4-9-管道" class="headerlink" title="1.4.9 管道"></a>1.4.9 管道</h4><p>管道：可以把它理解为两个进程之间通信的通道。管道可以是单向的，即 half-duplex：一个进程负责发消息，另一个进程负责收消息；也可以是双向的 duplex，即互相收发消息。默认声明 Pipe 对象是双向管道，如果要创建单向管道，可以在初始化的时候传入 deplex 参数为 False。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from multiprocessing import Process, Pipeclass Consumer(Process):    def __init__(self, pipe):        Process.__init__(self)        self.pipe = pipe    def run(self):        self.pipe.send('Consumer Words')        print(f'Consumer Received: {self.pipe.recv()}')class Producer(Process):    def __init__(self, pipe):        Process.__init__(self)        self.pipe = pipe    def run(self):        print(f'Producer Received: {self.pipe.recv()}')        self.pipe.send('Producer Words')if __name__ == '__main__':    pipe = Pipe()    # 返回两个对象    p = Producer(pipe[0])    c = Consumer(pipe[1])    p.daemon = c.daemon = True    p.start()    c.start()    p.join()    c.join()    print('Main Process Ended')# 输出Producer Received: Consumer WordsConsumer Received: Producer WordsMain Process Ended<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4-10-进程池"><a href="#1-4-10-进程池" class="headerlink" title="1.4.10 进程池"></a>1.4.10 进程池</h4><p>multiprocessing 中的 <code>Pool</code>（进程池）：Pool 可以提供指定数量的进程，供用户调用，当有新的请求提交到 pool 中时，如果池还没有满，就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行它。</p><p>Pool(processes=None, initializer=None, initargs=(), maxtasksperchild=None)</p><ul><li>processes表示工作进程的个数，默认为None，会自动根据处理器内核来分配进程数。</li><li>initializer表示工作进程start时调用的初始化函数，initargs表示initializer函数的参数。如果initializer不为None，在每个工作进程start之前会调用initializer(*initargs)</li><li>maxtaskperchild表示每个工作进程在退出/被其他新的进程替代前，需要完成的工作任务数，默认为None，表示工作进程存活时间与pool相同，即不会自动退出/被替换。</li><li>返回一个进程池（Pool）对象。</li></ul><p>Pool支持的方法：</p><ul><li>apply_async()：单个任务异步执行。</li><li>map()：多个任务同步执行。</li><li>map_async()：多个任务异步。</li><li>close()：关闭进程池，使其不在接受新的任务。</li><li>terminal()：结束工作进程，不再处理未处理的任务。</li><li>join()：主进程阻塞等待子进程的退出， join方法要在close或terminate之后使用。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">from multiprocessing import Poolimport timedef task(index):    print(f'Start process: {index}')    time.sleep(3)    print(f'End process {index}', )if __name__ == '__main__':    print('Main Process started')    pool = Pool(processes=4)    for i in range(6):        pool.apply_async(task, args=(i,))    pool.close()    pool.join()    print('Main Process ended')# 输出Main Process startedStart process: 0Start process: 1Start process: 2Start process: 3End process 0Start process: 4End process 1End process 2End process 3Start process: 5End process 4End process 5Main Process ended<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面例子中，我们声明了一个大小为 4 的进程池，通过 processes 参数来指定。然后，使用 apply_async 方法将进程添加进去，args 可以用来传递参数。</p><p>进程池大小为 4，所以最初可以看到有 4 个进程同时执行，第5个进程在等待，在有进程运行完毕之后，第5个进程马上跟着运行。最后，我们<strong>要记得调用 close 方法来关闭进程池，使其不再接受新的任务，然后调用 join 方法让主进程等待子进程的退出，等子进程运行完毕之后，主进程接着运行并结束。</strong></p><p>接下来，我们学习进程池一个更好用的 map 方法，可以实现多个进程并行运行。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from multiprocessing import Poolimport timedef task(index):    print(f'Start process: {index}')    time.sleep(3)    print(f'End process {index}', )if __name__ == '__main__':    print('Main Process started')    pool = Pool(processes=3)    index_list = range(1,5)    pool.map(task, index_list)    pool.close()    pool.join()    print('Main Process ended')# 输出Main Process startedStart process: 1Start process: 2Start process: 3End process 1Start process: 4End process 2End process 3End process 4Main Process ended<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h2><h3 id="2-1-线程与多线程的含义"><a href="#2-1-线程与多线程的含义" class="headerlink" title="2.1 线程与多线程的含义"></a>2.1 线程与多线程的含义</h3><p><strong>线程：是操作系统进行运算调度的最小单位，是进程中的一个最小运行单元</strong>。进程是由一个或多个线程构成的。比如打开一个浏览器，这就开启了一个浏览器进程。在浏览器上播放音乐就是一个线程，播放视频也是一个线程。这些线程的并发或并行执行最后使得整个浏览器可以同时运行很多的任务。</p><p><strong>多线程：就是一个进程中同时执行多个线程，</strong>如前面所说的浏览器的情景就是典型的多线程执行。</p><h3 id="2-2-Python中多线程的实现"><a href="#2-2-Python中多线程的实现" class="headerlink" title="2.2 Python中多线程的实现"></a>2.2 Python中多线程的实现</h3><p>在 Python 中， Python 自带的实现多线程的模块叫作 <code>threading</code>。</p><h4 id="2-2-1-直接使用Thread类创建线程"><a href="#2-2-1-直接使用Thread类创建线程" class="headerlink" title="2.2.1 直接使用Thread类创建线程"></a>2.2.1 直接使用Thread类创建线程</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">import threadingimport timedef task():    print(f'Threading {threading.current_thread().name} is running')    time.sleep(1)    print(f'Threading {threading.current_thread().name} is ended')if __name__ == '__main__':    print(f'Threading {threading.current_thread().name} is running')    threads = []    for i in range(1, 3):        thread = threading.Thread(target=task, args=())        threads.append(thread)        thread.start()    for thread in threads:        thread.join()    print(f'Threading {threading.current_thread().name} is ended')# 输出Threading MainThread is runningThreading Thread-1 is runningThreading Thread-2 is runningThreading Thread-1 is endedThreading Thread-2 is endedThreading MainThread is ended<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-继承Thread类来创建线程"><a href="#2-2-2-继承Thread类来创建线程" class="headerlink" title="2.2.2 继承Thread类来创建线程"></a>2.2.2 继承Thread类来创建线程</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">import threadingimport timeclass MyThread(threading.Thread):    def __init__(self, second):        threading.Thread.__init__(self)        self.second = second    def run(self):        print(f'Threading {threading.current_thread().name} is running')        print(f'Threading {threading.current_thread().name} sleep {self.second}s')        time.sleep(self.second)        print(f'Threading {threading.current_thread().name} is ended')if __name__ == '__main__':    print(f'Threading {threading.current_thread().name} is running')    threads = []    for i in [1, 3, 5]:        thread = MyThread(i)        threads.append(thread)        thread.start()    for thread in threads:        thread.join()    print(f'Threading {threading.current_thread().name} is ended')# 输出Threading MainThread is runningThreading Thread-1 is runningThreading Thread-1 sleep 1sThreading Thread-2 is runningThreading Thread-2 sleep 3sThreading Thread-3 is runningThreading Thread-3 sleep 5sThreading Thread-1 is endedThreading Thread-2 is endedThreading Thread-3 is endedThreading MainThread is ended<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-守护线程"><a href="#2-2-3-守护线程" class="headerlink" title="2.2.3 守护线程"></a>2.2.3 守护线程</h4><p>如果一个线程被设置为守护线程，意味着，如果主线程结束了而该守护线程还没有运行完，那么它将会被强制结束。Python 中我们可以通过 <code>setDaemon</code> 方法来将某个线程设置为守护线程。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import threadingimport timedef task(second):    print(f'Threading {threading.current_thread().name} is running')    print(f'Threading {threading.current_thread().name} sleep {second}s')    time.sleep(1)    print(f'Threading {threading.current_thread().name} is ended')if __name__ == '__main__':    print(f'Threading {threading.current_thread().name} is running')    thread1 = threading.Thread(target=task, args=(1, ))    thread1.start()    thread2 = threading.Thread(target=task, args=(2, ))    thread2.setDaemon(True)    thread2.start()    print(f'Threading {threading.current_thread().name} is ended')# 输出Threading MainThread is runningThreading Thread-1 is runningThreading Thread-1 sleep 1sThreading Thread-2 is runningThreading Thread-2 sleep 2sThreading MainThread is endedThreading Thread-1 is ended<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例中线程thread2设置为了守护线程，这样主线程在运行完毕时，thread2 线程会随着线程的结束而结束。不过，如果我们都调用<code>join()</code>，则主线程就会等待各个子线程执行完毕再退出，不论其是否是守护线程。</p><h4 id="2-2-4-互斥锁"><a href="#2-2-4-互斥锁" class="headerlink" title="2.2.4 互斥锁"></a>2.2.4 互斥锁</h4><p>在一个进程中的多个线程是共享资源的，如果多个线程同时对某个数据进行读取或修改，就会出现不可预料的结果。为了避免这种情况，我们需要对多个线程进行同步，可以对需要操作的数据进行加锁保护，这里就需要用到 <code>threading.Lock</code> 。</p><p>加锁保护：某个线程在对数据进行操作前，需要先加锁，这样其他的线程发现被加锁了之后，就无法继续向下执行，会一直等待锁被释放，只有加锁的线程把锁释放了，其他的线程才能继续加锁并对数据做修改，修改完了再释放锁。这样可以确保同一时间只有一个线程操作数据，多个线程不会再同时读取和修改同一个数据。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import threadingimport timenum_sum = 0def task():    global num_sum    lock.acquire()    temp = num_sum + 1    time.sleep(0.001)    num_sum = temp    lock.release()if __name__ == '__main__':    lock = threading.Lock()    threads = []    for _ in range(100):        thread = threading.Thread(target=task, args=())        threads.append(thread)        thread.start()    for thread in threads:        thread.join()    print(f'Final num: {num_sum}')# 输出Final num: 100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>学习参考：<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=46#/detail/pc?id=1667" target="_blank" rel="noopener">52讲轻松搞定网络爬虫</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（十五）：日期与时间</title>
      <link href="/posts/76f5294c.html"/>
      <url>/posts/76f5294c.html</url>
      
        <content type="html"><![CDATA[<p>在Python中，与时间和日期处理相关模块有：<code>time</code> 模块、<code>datetime</code> 模块和 <code>calendar</code> 模块。</p><h2 id="1-time模块"><a href="#1-time模块" class="headerlink" title="1. time模块"></a>1. time模块</h2><p>time 模块提供时间相关的类和函数。</p><h3 id="1-1-获取当前时间"><a href="#1-1-获取当前时间" class="headerlink" title="1.1 获取当前时间"></a>1.1 获取当前时间</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">import timeseconds = time.time()local_time = time.localtime(seconds)   # 时间浮点数转换为时间元组print(seconds)print(local_time)# 输出1598181396.107466time.struct_time(tm_year=2020, tm_mon=8, tm_mday=23, tm_hour=19, tm_min=16, tm_sec=36, tm_wday=6, tm_yday=236, tm_isdst=0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-格式化时间字符串"><a href="#1-2-格式化时间字符串" class="headerlink" title="1.2 格式化时间字符串"></a>1.2 格式化时间字符串</h3><p><code>time</code> 类 <code>strftime</code> 方法，可以按照时间格式要求格式化 <code>struct_time</code> 为时间字符串。</p><p>常用的时间格式：</p><p><code>%Y</code>：四位数的年份表示（0000-9999）</p><p><code>%m</code>：月份（01-12）</p><p><code>%d</code>：月内中的一天（0-31）</p><p><code>%H</code>：24小时制小时数（0-23）</p><p><code>%M</code>：分钟数（00-59）</p><p><code>%S</code>：秒（00-59）</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import timelocal_time = time.localtime()format_time = time.strftime('%Y-%m-%d %H:%M:%S', local_time)print(format_time)# 输出2020-08-23 19:41:08<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-时间字符串转时间元组"><a href="#1-3-时间字符串转时间元组" class="headerlink" title="1.3 时间字符串转时间元组"></a>1.3 时间字符串转时间元组</h3><p><code>time</code> 类 <code>strptime</code> 方法，解析 (<code>parse</code>) 时间字符串为 <code>struct_time</code> 类型的时间。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import timeformat_time = '2020-08-23 19:41:08'str_to_struct = time.strptime(format_time, '%Y-%m-%d %H:%M:%S')print(str_to_struct)# 输出time.struct_time(tm_year=2020, tm_mon=8, tm_mday=23, tm_hour=19, tm_min=41, tm_sec=8, tm_wday=6, tm_yday=236, tm_isdst=-1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，使用<code>strptime</code>时，第二个参数的时间格式，要匹配上第一个参数的时间格式。</p><h2 id="2-datetime模块"><a href="#2-datetime模块" class="headerlink" title="2. datetime模块"></a>2. datetime模块</h2><p>datetime模块提供了 4 种对日期和时间进行处理的类：<strong>date</strong>、<strong>time</strong>、<strong>datetime</strong> 和 <strong>timedelta</strong>。</p><h3 id="2-1-date"><a href="#2-1-date" class="headerlink" title="2.1 date"></a>2.1 date</h3><p><code>date</code> 类可以表示包含年、月、日等信息的日期值。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from datetime import date## 当前日期now_date = date.today()  str_date = date.strftime(now_date,'%Y-%m-%d')print(type(now_date), now_date)print(type(str_date), str_date)print(f'year={now_date.year}, month={now_date.month}, day={now_date.day}')# 输出<class 'datetime.date'> 2020-08-23<class 'str'> 2020-08-23year=2020, month=8, day=23## 指定日期date1 = date(2020, 8 ,23)str_date = date.strftime(date1,'%Y-%m-%d')print(str_date)# 输出2020-08-23<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-time"><a href="#2-2-time" class="headerlink" title="2.2 time"></a>2.2 time</h3><p><code>time</code> 类可以表示包含时、分、秒、微秒、时区等信息的时间对象。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from datetime import timetm = time(12, 0, 0)print(type(tm), tm)# 输出<class 'datetime.time'> 12:00:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-datetime"><a href="#2-3-datetime" class="headerlink" title="2.3 datetime"></a>2.3 datetime</h3><p><code>datetime</code> 类可以表示完整的日期和时间，类似 <code>time</code> 类和 <code>date</code> 类的结合。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from datetime import datetimedt = datetime.now()  # 获取当前的日期时间str_dt = datetime.strftime(dt,'%Y-%m-%d %H:%M:%S')print(dt)print(str_dt)print(dt.date())  # 返回日期部分print(dt.time())  # 返回时间部分print(dt.year)    # 年print(dt.isoweekday())  # 星期几# 输出2020-08-23 20:48:59.8488762020-08-23 20:48:592020-08-2320:48:59.84887620207<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在处理含有字符串日期的数据集时，我们需要一种自动解析字符串的方法，无论它是什么格式的，都可以将其转化为 datetime 对象。 可以使用dateutil 中的 parser 模块来实现这个需求。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from dateutil import parserstr_date = '2020-06-25'dt = parser.parse(str_date)print(type(dt), dt)# 输出<class 'datetime.datetime'> 2020-06-25 00:00:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-timedelta"><a href="#2-4-timedelta" class="headerlink" title="2.4 timedelta"></a>2.4 timedelta</h3><p><code>timedelta</code> 类表示某个特定长度的时间段，即两个日期或时间之间的间隔。两个 <code>datetime</code> 相减会得到 <code>timedelta</code> 对象，也可以用 <code>datetime</code> 加上或者减去 <code>timedelta</code> 得到新的时间值。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from datetime import datetime, timedeltadt1 = datetime(2020, 8, 1)dt2 = dt1 + timedelta(hours=12, minutes=30)dt3 = dt1 + timedelta(days=10)dt4 = dt1 + timedelta(weeks=2)print(dt2)print(dt3)print(dt4)# 输出2020-08-01 12:30:002020-08-11 00:00:002020-08-15 00:00:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-calendar模块"><a href="#3-calendar模块" class="headerlink" title="3. calendar模块"></a>3. calendar模块</h2><h3 id="3-1-绘制年日历图"><a href="#3-1-绘制年日历图" class="headerlink" title="3.1 绘制年日历图"></a>3.1 绘制年日历图</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">import calendarfrom datetime import datenow_date = date.today()year_calendar_str = calendar.calendar(2020)print(f"{now_date.year}年的日历图：{year_calendar_str}\n")# 输出2020年的日历图：                                  2020      January                   February                   MarchMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su       1  2  3  4  5                      1  2                         1 6  7  8  9 10 11 12       3  4  5  6  7  8  9       2  3  4  5  6  7  813 14 15 16 17 18 19      10 11 12 13 14 15 16       9 10 11 12 13 14 1520 21 22 23 24 25 26      17 18 19 20 21 22 23      16 17 18 19 20 21 2227 28 29 30 31            24 25 26 27 28 29         23 24 25 26 27 28 29                                                    30 31       April                      May                       JuneMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su       1  2  3  4  5                   1  2  3       1  2  3  4  5  6  7 6  7  8  9 10 11 12       4  5  6  7  8  9 10       8  9 10 11 12 13 1413 14 15 16 17 18 19      11 12 13 14 15 16 17      15 16 17 18 19 20 2120 21 22 23 24 25 26      18 19 20 21 22 23 24      22 23 24 25 26 27 2827 28 29 30               25 26 27 28 29 30 31      29 30        July                     August                  SeptemberMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su       1  2  3  4  5                      1  2          1  2  3  4  5  6 6  7  8  9 10 11 12       3  4  5  6  7  8  9       7  8  9 10 11 12 1313 14 15 16 17 18 19      10 11 12 13 14 15 16      14 15 16 17 18 19 2020 21 22 23 24 25 26      17 18 19 20 21 22 23      21 22 23 24 25 26 2727 28 29 30 31            24 25 26 27 28 29 30      28 29 30                          31      October                   November                  DecemberMo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su          1  2  3  4                         1          1  2  3  4  5  6 5  6  7  8  9 10 11       2  3  4  5  6  7  8       7  8  9 10 11 12 1312 13 14 15 16 17 18       9 10 11 12 13 14 15      14 15 16 17 18 19 2019 20 21 22 23 24 25      16 17 18 19 20 21 22      21 22 23 24 25 26 2726 27 28 29 30 31         23 24 25 26 27 28 29      28 29 30 31                          30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-绘制月日历图"><a href="#3-2-绘制月日历图" class="headerlink" title="3.2 绘制月日历图"></a>3.2 绘制月日历图</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">import calendarfrom datetime import datenow_date = date.today()month_calendar_str = calendar.month(now_date.year, now_date.month)print(f"{month_calendar_str}")# 输出August 2020Mo Tu We Th Fr Sa Su                1  2 3  4  5  6  7  8  910 11 12 13 14 15 1617 18 19 20 21 22 2324 25 26 27 28 29 3031<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-判断是否为闰年"><a href="#3-3-判断是否为闰年" class="headerlink" title="3.3 判断是否为闰年"></a>3.3 判断是否为闰年</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">import calendarfrom datetime import datenow_date = date.today()is_leap = calendar.isleap(now_date.year)if is_leap:    print("%s年是闰年"%now_date.year)else:    print("%s年不是闰年"%now_date.year)# 输出2020年是闰年<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-判断月有几天"><a href="#3-4-判断月有几天" class="headerlink" title="3.4 判断月有几天"></a>3.4 判断月有几天</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">import calendarfrom datetime import datenow_date = date.today()weekday, days = calendar.monthrange(now_date.year, now_date.month)print(f'{now_date.year}年-{now_date.month}月的第一天是那一周的第{weekday}天')print(f'{now_date.year}年-{now_date.month}月共有{days}天')# 输出2020年-8月的第一天是那一周的第5天2020年-8月共有31天<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-月的第一天和最后一天"><a href="#3-5-月的第一天和最后一天" class="headerlink" title="3.5 月的第一天和最后一天"></a>3.5 月的第一天和最后一天</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">from datetime import dateimport calendar# 月的第一天now_date = date.today()month_first_day = date(now_date.year, now_date.month, 1)print(f"当月第一天:{month_first_day}")# 月的最后一天_, days = calendar.monthrange(now_date.year, now_date.month)month_last_day = date(now_date.year, now_date.month, days)print(f"当月最后一天:{month_last_day}")# 输出当月第一天:2020-08-01当月最后一天:2020-08-31<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（十四）：正则表达式与JSON</title>
      <link href="/posts/1331ceb4.html"/>
      <url>/posts/1331ceb4.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-正则表达式必知必会"><a href="#1-正则表达式必知必会" class="headerlink" title="1. 正则表达式必知必会"></a>1. 正则表达式必知必会</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>正则表达式：是一些用来匹配和处理文本的字符串。</p><p>正则表达式的使用场景主要以下两种情况：一是查找特定的信息（搜索），二是查找并编辑特定的信息（替换）。</p><p>用模式（pattern）表示实际的正则表达式。</p><h3 id="1-2-匹配单个字符"><a href="#1-2-匹配单个字符" class="headerlink" title="1.2 匹配单个字符"></a>1.2 匹配单个字符</h3><ul><li><p>匹配普通文本：正则表达式为待匹配的文本。</p></li><li><p>匹配任意字符：<code>.</code>字符（英文句号）可以匹配任意单个字符，如字符、字母、数字，甚至是<code>.</code>字符本身。</p></li><li><p>匹配特殊字符：使用<code>\</code>转义地字符，如<code>\.</code>。</p></li></ul><h3 id="1-3-匹配一组字符"><a href="#1-3-匹配一组字符" class="headerlink" title="1.3 匹配一组字符"></a>1.3 匹配一组字符</h3><ul><li>匹配多个字符中的某一个</li></ul><p>使用<code>[]</code>定义一个字符集合，对于连续字符使用<code>-</code>连字符来定义字符区间。集合内字符是<code>OR</code>关系，匹配其中之一。</p><p>[A-Z]：匹配从A到Z的所有大写字母。</p><p>[a-z]：匹配从a到z的所有小写字母。</p><p>[0-9]：匹配从0到9的所有数字。</p><ul><li>排除</li></ul><p>使用元字符<code>^</code>来排除字符集合里指定的那些字符，如<code>[^0-9]</code>。注意，^的效果将作用于给定字符集合里的所有字符或字符区间。</p><h3 id="1-4-使用元字符"><a href="#1-4-使用元字符" class="headerlink" title="1.4 使用元字符"></a>1.4 使用元字符</h3><h4 id="1-4-1-元字符转义"><a href="#1-4-1-元字符转义" class="headerlink" title="1.4.1 元字符转义"></a>1.4.1 元字符转义</h4><p>元字符：在正则表达式里有特殊含义的字符。</p><p>转义：元字符可以通过在前面加上一个反斜杠（<code>\</code>）进行转义，这样匹配的就是该字符本身而不是特殊的元字符含义。</p><h4 id="1-4-2-匹配空白字符"><a href="#1-4-2-匹配空白字符" class="headerlink" title="1.4.2 匹配空白字符"></a>1.4.2 匹配空白字符</h4><p>元字符大概可以分为两种：一种是用来匹配文本的（如<code>.</code>），另一种是正则表达式语法的组成部分（如<code>[]</code>）。</p><p>空白元字符：换页符（\f）、换行符（\n）、回车符（\r）、制表符（\t）。</p><p>一般来说，需要匹配\r、\n和\t等空白字符的情况比较多见。\r\n匹配一个回车+换行组合。</p><h4 id="1-4-3-匹配特定的字符类型"><a href="#1-4-3-匹配特定的字符类型" class="headerlink" title="1.4.3 匹配特定的字符类型"></a>1.4.3 匹配特定的字符类型</h4><ul><li><strong>匹配数字与非数字：</strong></li></ul><p>\d：任何一个数字字符（等价于[0-9]）</p><p>\D：任何一个非数字字符（等价于<code>[^0-9]</code>）</p><ul><li><strong>匹配字母数字或下划线：</strong></li></ul><p>\w：任何一个字母数字或下划线字符（等价于[a-zA-Z0-9_]）</p><p>\W：任何一个非字母数字或非下划线字符（等价于<code>[^a-zA-Z0-9_]</code>）</p><ul><li><strong>匹配空白字符与非空白字符：</strong></li></ul><p>\s：任何一个空白字符（等价于<code>[\f\n\r\t\v]</code>）</p><p>\S：任何一个非空白字符（等价于<code>[^\f\n\r\t\v]</code>）</p><h3 id="1-5-重复匹配"><a href="#1-5-重复匹配" class="headerlink" title="1.5 重复匹配"></a>1.5 重复匹配</h3><ul><li><strong>匹配一个或多个字符：</strong></li></ul><p><code>+</code>匹配一个或多个字符，在一个给定字符集合加上+后缀时，必须放在整个字符集合的外面，如<code>[0-9]+</code>。</p><p>一般来说，当在字符集合使用时，像.和+这样的元字符被解释为普通字符，不需要转义，但转义也不影响。</p><ul><li><strong>匹配零个或多个字符：</strong></li></ul><p><code>*</code>用来匹配字符或字符集合出现零次或多次的情况。</p><ul><li><strong>匹配零个或一个字符：</strong></li></ul><p><code>?</code>可以匹配某个字符或字符集合的零次或一次。</p><p><code>[]</code>的常规用法是把多个字符定义为一个集合，但不少程序员喜欢把一个字符也定义为一个集合，好处是可以增加可读性和避免产生误解。同时使用[]和?时，要把?放在字符集合的外面。</p><ul><li><strong>具体的匹配次数：</strong></li></ul><p>设置具体的匹配次数，把数字写在<code>{}</code>中，如<code>{3}</code>。</p><p>可以为重复匹配的次数设定一个区间范围，<strong>设置最小次数和最大次数</strong>，如<code>{3, 5}</code>。</p><p>也可以指定至少要匹配的次数，如<code>{3, }</code>。</p><ul><li><strong>防止过度匹配：</strong></li></ul><p>在使用重复匹配如果没有上限值，则有时会导致过度匹配的现象。</p><p>像<code>*</code>和<code>+</code>这些都是“贪婪型”元字符，其匹配行为是多多益善和不是适可而止，会尽可能从一段文本的开头一直匹配到末尾，而不会碰到第一个匹配时就停止。</p><p><code>+、*、?</code>这些叫做量词，量词是<strong>贪婪</strong>的。</p><p>为了防止过度匹配，我们可以使用量词的“懒惰型”版本（匹配尽可能少的字符，而非尽可能多地去匹配），<strong>懒惰型量词地写法是在贪婪型量词后加<code>?</code>。</strong></p><h3 id="1-6-位置匹配"><a href="#1-6-位置匹配" class="headerlink" title="1.6 位置匹配"></a>1.6 位置匹配</h3><p>位置匹配用于指定应该在文本什么地方进行匹配操作。位置匹配需要用到边界，即一些用于指定模式前后位置（或边界）的特殊元字符。</p><ul><li>单词边界</li></ul><p>由<code>\b</code>指定单词边界，用来匹配一个单词的开头或结尾。<code>\b</code>匹配的是字符之间的一个位置：一边是单词（能够被<code>\w</code>匹配的字母数字和下划线），另一边是其他内容（能够被<code>\W</code>匹配的字符）。注意：<code>\b</code>匹配的是一个位置，而不是任何实际的字符。</p><p>如果我们想匹配一个完整的单词，就必须在匹配的文本前后加上<code>\b</code>。如果不想匹配单词边界，可以使用<code>\B</code>。</p><ul><li>字符串边界</li></ul><p>字符串边界元字符有两个：<code>^</code>表示字符串开头，<code>$</code>表示字符串结尾。</p><p>注意：有些元字符有多种用途，如<code>^</code>。如果<code>^</code>出现在字符集合<code>[]</code>里且紧跟在左方括号<code>[</code>后面时，它才表示排除该字符集合。如果<code>^</code>出现在字符集合之外并且位于模式的开头，<code>^</code>将匹配字符串的起始位置。</p><ul><li>多行模式</li></ul><p>多行模式影响的是<code>^</code>和<script type="math/tex">`的匹配规则：在默认模式下，`^`和`</script>匹配的是整个字符串的起始位置和结束位置，但是在多行模式下，它们也<strong>能匹配字符串内部某一行文本的起始位置和结束位置</strong>。多行模式迫使正则表达式引擎<strong>将换行符视为字符串分隔符</strong>，这样一来，<code>^</code>既可以匹配字符串开头，也可匹配换行符之后的起始位置（新行）；<code>$</code>不仅能匹配字符串结尾，也能匹配换行符之后的结束位置。</p><p>启用多行模式，使用<code>(?m)</code>，并且其必须出现在整个模式最前面。</p><h3 id="1-7-子表达式"><a href="#1-7-子表达式" class="headerlink" title="1.7 子表达式"></a>1.7 子表达式</h3><p>子表达式是更长的表达式的一部分。划分子表达式的目的是为了将其视为单一的实体来使用。子表达式使用<code>()</code>进行定义，并用于对表达式进行分组。</p><ul><li>指定子表达式的重复次数</li></ul><p>匹配IP：<code>(\d{1, 3}\.){3}\d{1, 3}</code></p><ul><li>与模式里的<code>|</code>（或）连用</li></ul><p><code>(19|20)\d{2}</code>，匹配19或20开头的年份。</p><ul><li>子表达式的嵌套</li></ul><p>匹配一个有效的IP：</p><p><code>(((25[0-5])|(2[0-4]\d)|(1\d{2})|(\d{1, 2}))\.){3}(((25[0-5])|(2[0-4]\d)|(1\d{2})|(\d{1, 2})))</code></p><h3 id="1-8-反向引用"><a href="#1-8-反向引用" class="headerlink" title="1.8 反向引用"></a>1.8 反向引用</h3><p>反向引用：指的是这些实体引用的是先前的子表达式。</p><p>使用小括号<code>()</code>指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。</p><ul><li>默认组号</li></ul><p>默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。<code>\1</code>是引用匹配模式中使用的第一个子表达式，<code>\2</code>匹配模式中的第二个子表达式，以此类推。<code>\0</code>可以用来匹配整个表达式。</p><ul><li>自定义子表达式的组名</li></ul><p><code>(?&lt;name&gt;exp)</code>或<code>(?'name'exp)</code>：匹配exp,并捕获文本到名称为name的组里。</p><ul><li>匹配但不捕获，也不分配组号</li></ul><p><code>(?:exp)</code>：匹配exp,不捕获匹配的文本，也不给此分组分配组号。</p><h3 id="1-9-环视"><a href="#1-9-环视" class="headerlink" title="1.9 环视"></a>1.9 环视</h3><ul><li>向前查看</li></ul><p>向前查看指定了一个必须匹配但不用在结果中返回的模式。向前查看是查看以匹配文本之后的内容，但不消耗这些内容。向前查看是一个子表达式，以<code>?=</code>开头，需要匹配的文本跟在<code>=</code>的后面。例如：<code>.+(?=:)</code>可以匹配<code>http://www.baidu.com，https://www.baidu.com/</code>中的<code>http</code>和<code>https</code>。</p><ul><li>向后查看</li></ul><p>向后查看是查看以匹配文本之前的内容，操作符为<code>?&lt;=</code>。</p><p>以上两个都属于肯定式查看，与之相对应的是否定式查看，即否定式向前查看和否定式向后查看。</p><ul><li>否定式向前查看</li></ul><p>否定式向前查看会向前查看不匹配指定模式的文本，操作符为<code>?!</code>。</p><ul><li>否定式向后查看</li></ul><p>否定式向后查看是向后查看不匹配指定模式的文本，操作符为<code>?&lt;!</code>。</p><h3 id="1-10-嵌入式条件"><a href="#1-10-嵌入式条件" class="headerlink" title="1.10 嵌入式条件"></a>1.10 嵌入式条件</h3><p>正则表达式里的条件用<code>?</code>来定义。嵌入式条件主要以下两种情况：一是根据反向引用来进行条件处理，二是根据环视来进行条件处理。</p><ul><li>反向引用条件</li></ul><p>反向引用条件仅在一个前面的子表达式得以匹配的情况下才允许使用另一个表达式。定义这种条件的语法是<code>(?(backreference)true)</code>，其中?表明这是一个条件，括号里的backreference是一个反向引用。</p><p>条件还可以使用else表达式，定义这种条件的语法：<code>(?(backreference)true|false)</code>。</p><p>示例：<code>(\()?\d{3}(?(1)\)|-)\d{3}-\d{4}</code></p><ul><li>环视条件</li></ul><p>环视条件允许根据向前查看或向后查看操作是否成功来决定要不要执行表达式。</p><p>示例：<code>\d{5}(?(?=-))-\d{4}</code></p><h3 id="1-11-正则表达式测试网站"><a href="#1-11-正则表达式测试网站" class="headerlink" title="1.11 正则表达式测试网站"></a>1.11 正则表达式测试网站</h3><p><a href="http://www.pyregex.com/" target="_blank" rel="noopener">http://www.pyregex.com/</a></p><p><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a></p><p><a href="https://c.runoob.com/front-end/854" target="_blank" rel="noopener">https://c.runoob.com/front-end/854</a></p><h3 id="1-12-常见问题的正则表达式解决方案"><a href="#1-12-常见问题的正则表达式解决方案" class="headerlink" title="1.12 常见问题的正则表达式解决方案"></a>1.12 常见问题的正则表达式解决方案</h3><h2 id="2-Python中的正则表达式"><a href="#2-Python中的正则表达式" class="headerlink" title="2. Python中的正则表达式"></a>2. Python中的正则表达式</h2><p>在Python中，标准库中的模块<code>re</code>提供了正则表达式操作。</p><h3 id="2-1-re模块中的函数"><a href="#2-1-re模块中的函数" class="headerlink" title="2.1 re模块中的函数"></a>2.1 re模块中的函数</h3><h4 id="2-1-1-re-complie"><a href="#2-1-1-re-complie" class="headerlink" title="2.1.1 re.complie()"></a>2.1.1 re.complie()</h4><p>将正则表达式的样式编译为一个 <a href="https://docs.python.org/zh-cn/3/library/re.html#re-objects" target="_blank" rel="noopener">正则表达式对象</a> （正则对象），正则表达式对象支持match()、search() 等方法。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""语法：re.compile(pattern, flags)参数：pattern为一个字符串形式的正则表达式，flags为可选参数，表示匹配模式，具体参数为：re.I：忽略大小写re.M：多行模式re.S：让‘.’匹配任何字符，包括换行符re.X：为了增加可读性，忽略空格和#后面的注释"""import repattern = re.compile(r'\d+')res = pattern.search('abc123def456')  # search：扫描整个字符串并返回第一个成功的匹配结果print(res)print(res.group())  # 匹配整体结果# 输出<re.Match object; span=(3, 6), match='123'>123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在re模块中，也提供了一些和match()、search()这些方法功能一致的函数。</p><h4 id="2-1-2-re-match"><a href="#2-1-2-re-match" class="headerlink" title="2.1.2 re.match()"></a>2.1.2 re.match()</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">""" 尝试从字符串的起始位置匹配一个模式，如果起始位置匹配失败，则返回None。 语法：re.match(pattern, string, flags=0) 参数：pattern为正则表达式样式，string为待匹配的字符串，flags为匹配模式。 返回值：如果匹配成功则返回一个匹配对象，否则返回None。"""import reres1 = re.match(r'\d+', 'abc123def456')res2 = re.match(r'\d+', '123abc456def')print(res1)print(res2.group(0))print(res2.groups())# 输出None123()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>匹配对象有两个主要的方法：group() 和 groups() 。</p><ul><li>group(num=0)：group()和group(0)返回整个匹配对象，group(1)、group(2)，…，返回特定组的匹配结果。</li><li>groups()：返回所有匹配子组的元组，组号从1开始。</li></ul><p>除此之外，匹配对象还支持其他方法：</p><ul><li>start()：返回匹配的开始位置</li><li>end()：返回匹配的结束位置</li><li>span()：以元组形式返回匹配的范围</li></ul><h4 id="2-1-3-re-search"><a href="#2-1-3-re-search" class="headerlink" title="2.1.3 re.search()"></a>2.1.3 re.search()</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""扫描整个字符串并返回第一个成功的匹配。语法：re.search(pattern, string, flags=0)返回值：如果匹配成功则返回一个匹配对象，否则返回None。"""import reres = re.search(r'\d+', 'abc123def456')print(res.group())# 输出123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-4-re-findall"><a href="#2-1-4-re-findall" class="headerlink" title="2.1.4 re.findall()"></a>2.1.4 re.findall()</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。语法：findall(string, start_pos, end_pos)参数：string为待匹配的字符串，start_pos指定字符串的起始位置（可选），默认为0，end_pos指定字符串的结束位置（可选），默认为字符串的长度。返回值：以列表形式返回所有匹配结果"""import reres = re.findall(r'\d+', 'abc123def456')print(res)# 输出['123', '456']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：re.findall()返回的结果是一个匹配结果的列表，不支持group()和groups()这些方法。</p><h4 id="2-1-5-re-finditer"><a href="#2-1-5-re-finditer" class="headerlink" title="2.1.5 re.finditer()"></a>2.1.5 re.finditer()</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""和findall类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。语法：re.finditer(pattern, string, flags=0)返回值：返回所有匹配对象构成的迭代器。"""import reres = re.finditer(r"\d+","abc123def456") for match in res:     print(match)   # 迭代器中的每个元素都为匹配对象，支持group()    print(match.group())# 输出<re.Match object; span=(3, 6), match='123'>123<re.Match object; span=(9, 12), match='456'>456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-6-re-split"><a href="#2-1-6-re-split" class="headerlink" title="2.1.6 re.split()"></a>2.1.6 re.split()</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""按照能够匹配的子串将字符串分割后返回列表。语法：re.split(pattern, string[, maxsplit=0, flags=0])参数：maxsplit为最大分隔次数，默认为0，即不限次数，flags为匹配模式。返回值：返回以匹配子串分隔的字符串列表。"""import reres = re.split(r"\W+","abc,123,def,456") print(res)# 输出['abc', '123', 'def', '456']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-7-re-sub"><a href="#2-1-7-re-sub" class="headerlink" title="2.1.7 re.sub()"></a>2.1.7 re.sub()</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""替换字符串中的匹配项。语法：re.sub(pattern, repl, string, count=0, flags=0)参数：repl为替换的字符串或函数，string为待匹配的原始字符串，count为替换的最大次数，默认为0，表示替换所有的匹配。返回值：返回替换后的字符串。"""import reres = re.sub(r"\d", "*", "abc123def456") print(res)# 输出abc***def***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-8-re-subn"><a href="#2-1-8-re-subn" class="headerlink" title="2.1.8 re.subn()"></a>2.1.8 re.subn()</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""与sub()相同, 但返回一个元组, 其中包含新字符串和替换次数。"""import reres = re.subn(r"\d", "*", "abc123def456") print(res)# 输出('abc***def***', 6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-元字符"><a href="#2-2-元字符" class="headerlink" title="2.2 元字符"></a>2.2 元字符</h3><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//yuanzifu.png" alt="yuanzifu"></p><h2 id="3-JSON"><a href="#3-JSON" class="headerlink" title="3. JSON"></a>3. JSON</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>JSON是一种轻量级的数据交换格式。符合JSON格式的字符串称为JSON字符串。JSON优点：</p><ul><li><p>易于阅读</p></li><li><p>易于解析</p></li><li><p>网络传输效率高</p></li><li><p>跨语言交换数据</p></li></ul><p>JSON对象类似于Python中的字典，由键值对组成。键必须是字符串，值可以是字符串, 数字, 对象, 数组, 布尔值或 null。需注意，JSON对象中的字符串必须用<strong>双引号(“ “)</strong>。</p><pre class="line-numbers language-lang-json"><code class="language-lang-json">{"name": "Tom", "age": 28, "address": "Shanghai"}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-序列化"><a href="#3-2-序列化" class="headerlink" title="3.2 序列化"></a>3.2 序列化</h3><p>序列化：将python数据类型向json字符串转换的过程。</p><h4 id="3-2-1-json-dumps"><a href="#3-2-1-json-dumps" class="headerlink" title="3.2.1 json.dumps()"></a>3.2.1 json.dumps()</h4><p>dumps()函数中有一些参数需要了解：</p><ul><li>ensure_ascii：指定输出内容的编码，默认是ascii编码，如果需要输出中文，设置<code>ensure_ascii=False</code>。</li><li>skipkeys：如果要将字典转换为json字符串，则字典键只能是基本数据类型(<code>str</code>, <code>unicode</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>bool</code>, <code>None</code>)，否则会抛出异常。将skipkeys设置为True，则会跳过哪些类型不是基本类型的键。</li><li>indent：根据数据格式缩进显示。</li><li>sort_keys：sort_keys设置为True，输出内容按键进行排序。</li><li>separators：作用是去掉<code>','</code>和<code>':'</code>后面的空格。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">import jsonstu = {'name': 'Tom', 'age': 28, 'school': 'Harvard University'}stu_arr = [{'name': 'Tom', 'age': 28, 'school': 'Harvard University'},           {'name': 'Henry', 'age': 27, 'school': '清华大学'}]print(type(json.dumps(stu)))print(json.dumps(stu))print(json.dumps(stu_arr, ensure_ascii=False, indent=2))# 输出<class 'str'>{"name": "Tom", "age": 28, "school": "Harvard University"}[  {    "name": "Tom",    "age": 28,    "school": "Harvard University"  },  {    "name": "Henry",    "age": 27,    "school": "清华大学"  }]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-2-json-dump"><a href="#3-2-2-json-dump" class="headerlink" title="3.2.2 json.dump()"></a>3.2.2 json.dump()</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""将Python对象转换为json对象并保存到文件中"""import jsonstu = {'name': 'Tom', 'age': 28, 'school': 'Harvard University'}with open('student_info.json', 'w') as f:    json.dump(stu, f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-反序列化"><a href="#3-3-反序列化" class="headerlink" title="3.3 反序列化"></a>3.3 反序列化</h3><p>反序列化：将json字符串转换为python中的数据类型。</p><pre><code>json可以转换为python对应的类型json                      pythonobject                    dictarray                     liststring                    strnumber                    int/floattrue                      Truefalse                     Falsenull                      None</code></pre><h4 id="3-3-1-json-loads"><a href="#3-3-1-json-loads" class="headerlink" title="3.3.1 json.loads()"></a>3.3.1 json.loads()</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">import jsonstu = '{"name": "Tom", "age": 28, "school": "Harvard University"}'print(type(json.loads(stu)))print(json.loads(stu))# 输出<class 'dict'>{'name': 'Tom', 'age': 28, 'school': 'Harvard University'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-2-json-load"><a href="#3-3-2-json-load" class="headerlink" title="3.3.2 json.load()"></a>3.3.2 json.load()</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">import jsonwith open('student_info.json', 'r') as f:    data = json.load(f)    print(data)# 输出{'name': 'Tom', 'age': 28, 'school': 'Harvard University'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（十三）：文件操作与异常处理</title>
      <link href="/posts/142a13a2.html"/>
      <url>/posts/142a13a2.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-文件操作"><a href="#1-文件操作" class="headerlink" title="1. 文件操作"></a>1. 文件操作</h2><h3 id="1-1-文件读写操作"><a href="#1-1-文件读写操作" class="headerlink" title="1.1 文件读写操作"></a>1.1 文件读写操作</h3><p>文件读、写操作比较常见。这里，学习在python中如何进行文件读写。</p><h4 id="1-1-1文件读操作"><a href="#1-1-1文件读操作" class="headerlink" title="1.1.1文件读操作"></a>1.1.1文件读操作</h4><p>读取文件，要先判断文件是否存在。如果文件存在，则正常进行读取，否则抛出文件不存在的异常。</p><ul><li>打开文件</li></ul><pre><code>open(file, mode='r', encoding=None, ...)</code></pre><p>参数说明：</p><p><code>file</code>: 必需，文件路径（相对或者绝对路径）。</p><p><code>mode</code>: 可选，文件打开模式。</p><p><code>encoding</code>: 编码方式，一般使用utf8。</p><p>常用的mode参数：</p><p><strong>mode=’r’：</strong>以只读方式打开文件，文件的指针将会放在文件的开头。（默认模式）</p><p><strong>mode=’w’：</strong>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</p><p><strong>mode=’a’：</strong>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</p><p><strong>mode=’+’：</strong>可读写模式，可与其他模式等配合使用，如’r+’、’w+’、’a+’等。</p><ul><li>读取文件内容</li></ul><p>使用<code>open()</code>打开文件，返回一个<strong>文件对象</strong><code>fileObject</code>。</p><p><code>fileObject.readlines()</code>：一次性读取文件所有内容，并返回一个列表。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">f = open("E:/WorkSpace/test.txt", 'r')lines = f.readlines()print(lines)f.close()# 输出   由每行字符串构成列表['Beautiful is better than ugly.\n', 'Explicit is better than implicit.\n', 'Simple is better than complex.\n', 'Complex is better than complicated.\n', 'Flat is better than nested.\n', 'Sparse is better than dense.\n']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>fileObject.readline()</code>：一次读取文件一行，能解决大文件读取内存溢出问题。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">f = open("E:/WorkSpace/test.txt", 'r')while True:    line = f.readline()    if line:        print(type(line), line)    else:        breakf.close()# 输出<class 'str'> Beautiful is better than ugly.<class 'str'> Explicit is better than implicit.<class 'str'> Simple is better than complex.<class 'str'> Complex is better than complicated.<class 'str'> Flat is better than nested.<class 'str'> Sparse is better than dense.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>fileObject.read()</code>：读取整个文件，将文件内容放到一个字符串变量中。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">f = open("E:/WorkSpace/test.txt", 'r')text = f.read()print(type(text), text)f.close()# 输出<class 'str'> Beautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>fileObject.close()</code>：用于关闭一个已打开的文件，关闭后的文件不能再进行读写操作。</p><h4 id="1-1-2-文件写操作"><a href="#1-1-2-文件写操作" class="headerlink" title="1.1.2 文件写操作"></a>1.1.2 文件写操作</h4><p>如果想向文件中写入内容，打开文件<code>open()</code>的模式<code>mode</code>可以设置为<code>'w'</code>或<code>'w+'</code>。</p><ul><li>fileObject.write(str)：用于向文件中写入指定字符串，返回的是写入的字符长度。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">f = open("E:/WorkSpace/test.txt", 'w')content = "Simple is better than complex"print(f.write(content))f.close()# 输出29<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>fileObject.writelines()：向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符<code>\n</code>。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">f = open("E:/WorkSpace/test.txt", 'w')str_list = ['Simple is better than complex\n', 'Explicit is better than implicit']f.writelines(str_list)f.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-3-with语句读取文件"><a href="#1-1-3-with语句读取文件" class="headerlink" title="1.1.3 with语句读取文件"></a>1.1.3 with语句读取文件</h4><p>在读写文件时，我们经常使用with语句，可以保证在文件操作后会自动关闭打开的文件。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">with open("E:/WorkSpace/test.txt", 'r') as f:    for line in f.readlines():        print(line)# 输出Simple is better than complexExplicit is better than implicit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-os模块中文件-目录方法"><a href="#1-2-os模块中文件-目录方法" class="headerlink" title="1.2 os模块中文件/目录方法"></a>1.2 os模块中文件/目录方法</h3><h4 id="1-2-1-os-getcwd"><a href="#1-2-1-os-getcwd" class="headerlink" title="1.2.1 os.getcwd()"></a>1.2.1 os.getcwd()</h4><p>返回当前工作目录。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import osprint(os.getcwd())# 输出E:\WorkSpace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-os-chdir-path"><a href="#1-2-2-os-chdir-path" class="headerlink" title="1.2.2 os.chdir(path)"></a>1.2.2 os.chdir(path)</h4><p>用于改变当前工作目录到指定的路径。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import osprint(os.getcwd())  # 当前目录os.chdir('E:\WorkSpace\EffectivePython')  # 切换到新路径print(os.getcwd())  # 新路径# 输出E:\WorkSpaceE:\WorkSpace\EffectivePython<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-3-os-listdir-path"><a href="#1-2-3-os-listdir-path" class="headerlink" title="1.2.3 os.listdir(path)"></a>1.2.3 os.listdir(path)</h4><p>返回path路径下包含的文件或文件夹的名字的列表。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import ospath = "E:/WorkSpace/EffectivePython"dirs = os.listdir(path)for file in dirs:    print(file)# 输出.git.gitignore.vscodebuildmake.batMakefileREADME.mdsource<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-4-os-mkdir-path"><a href="#1-2-4-os-mkdir-path" class="headerlink" title="1.2.4 os.mkdir(path)"></a>1.2.4 os.mkdir(path)</h4><p>创建单层目录，如果该目录已存在抛出异常。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import osos.mkdir('E:/WorkSpace')# 输出FileExistsError: [WinError 183] 当文件已存在时，无法创建该文件。: 'E:/WorkSpace'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python">import osos.mkdir('E:/WorkSpace/subWorkSpace')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-2-5-os-makedirs-path"><a href="#1-2-5-os-makedirs-path" class="headerlink" title="1.2.5 os.makedirs(path)"></a>1.2.5 os.makedirs(path)</h4><p>用于递归创建多层目录，如果该目录已存在抛出异常。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import osos.makedirs('E:/WorkSpace/subWorkSpace1/subWorkSpace2')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-2-6-os-remove-path"><a href="#1-2-6-os-remove-path" class="headerlink" title="1.2.6 os.remove(path)"></a>1.2.6 os.remove(path)</h4><p>用于删除指定路径的文件。如果指定的路径是一个目录，将抛出 <code>OSError</code>。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import osos.remove('E:/WorkSpace/test.txt')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-2-7-os-rmdir-path"><a href="#1-2-7-os-rmdir-path" class="headerlink" title="1.2.7 os.rmdir(path)"></a>1.2.7 os.rmdir(path)</h4><p>用于删除单层目录，仅当这文件夹是空的才可以, 否则, 抛出OSError。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import osos.rmdir('E:/WorkSpace/subWorkSpace1/subWorkSpace2')  # 仅删除subWorkSpace2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-2-8-os-removedirs-path"><a href="#1-2-8-os-removedirs-path" class="headerlink" title="1.2.8 os.removedirs(path)"></a>1.2.8 os.removedirs(path)</h4><p>递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import osos.removedirs('E:/WorkSpace/subWorkSpace1/subWorkSpace2')   # 删除/subWorkSpace1/subWorkSpace2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-2-9-os-rename-src-dst"><a href="#1-2-9-os-rename-src-dst" class="headerlink" title="1.2.9 os.rename(src, dst)"></a>1.2.9 os.rename(src, dst)</h4><p>用于命名文件或目录，从 src 到 dst,如果dst是一个存在的目录, 将抛出OSError。<strong>src</strong> 为要修改的目录名，<strong>dst</strong>是修改后的目录名。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import osos.rename('./subWorkSpace1/subWorkSpace2', './subWorkSpace1/subWorkSpace3')  # subWorkSpace2重命名为subWorkSpace3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-2-10-os-path模块"><a href="#1-2-10-os-path模块" class="headerlink" title="1.2.10 os.path模块"></a>1.2.10 os.path模块</h4><p>该模块主要用于获取文件的属性。</p><ul><li>os.path.basename(path)：返回文件名</li><li>os.path.abspath(path)：返回绝对路径</li><li>os.path.dirname(path)：返回文件路径</li><li>os.path.exists(path)：判断指定路径（目录或文件）是否存在。</li><li>os.path.isabs(path)：判断是否为绝对路径</li><li>os.path.isfile(path)：判断路径是否为文件</li><li>os.path.isdir(path)：判断路径是否为目录</li><li>os.path.samefile(path1, path2)： 判断path1和path2是否相同</li><li>os.path.join(path1[, path2[, …]])：将 <code>path1</code>和<code>path2</code> 各部分组合成一个路径名</li><li>os.path.split(path)：把路径path分割成<u>文件路径</u>和<u>文件名</u>，并返回一个<code>(file_path, file_name)</code>元组。如果完全使用目录，它会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在。</li><li>os.path.splitext(path)：分离文件名与扩展名，返回路径名和文件扩展名的元组。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">import osprint(os.path.basename(r'E:\WorkSpace\subWorkSpace1\subWorkSpace2\test.txt'))print(os.path.abspath(r'E:\WorkSpace\subWorkSpace1\subWorkSpace2\test.txt'))print(os.path.dirname(r'E:\WorkSpace\subWorkSpace1\subWorkSpace2\test.txt'))print(os.path.exists(r'E:\WorkSpace\subWorkSpace1\subWorkSpace2\test1.txt'))print(os.path.isabs(r'E:\WorkSpace\subWorkSpace1\subWorkSpace2'))print(os.path.isfile(r'E:\WorkSpace\subWorkSpace1\subWorkSpace2\test.txt'))print(os.path.isdir(r'E:\WorkSpace\subWorkSpace1\subWorkSpace2'))print(os.path.samefile(r'E:\WorkSpace\subWorkSpace1\subWorkSpace2', r'E:\WorkSpace\subWorkSpace1\subWorkSpace3'))print(os.path.join(r'E:\WorkSpace\subWorkSpace1\subWorkSpace3', 'test.txt'))print(os.path.split(r'E:\WorkSpace\subWorkSpace1\subWorkSpace2\test.txt'))print(os.path.splitext(r'E:\WorkSpace\subWorkSpace1\subWorkSpace2\test.txt'))# 输出test.txtE:\WorkSpace\subWorkSpace1\subWorkSpace2\test.txtE:\WorkSpace\subWorkSpace1\subWorkSpace2FalseTrueTrueTrueFalseE:\WorkSpace\subWorkSpace1\subWorkSpace3\test.txt('E:\\WorkSpace\\subWorkSpace1\\subWorkSpace2', 'test.txt')('E:\\WorkSpace\\subWorkSpace1\\subWorkSpace2\\test', '.txt')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-异常处理"><a href="#2-异常处理" class="headerlink" title="2. 异常处理"></a>2. 异常处理</h2><p>异常就是运行期检测到的错误。</p><h3 id="2-1-Python-标准异常总结"><a href="#2-1-Python-标准异常总结" class="headerlink" title="2.1  Python 标准异常总结"></a>2.1  Python 标准异常总结</h3><ul><li>BaseException：所有异常的<strong>基类</strong></li><li>Exception：所有异常类的基类，但继承BaseException</li><li>AssertionError ：断言语句（assert）失败</li><li>AttributeError：尝试访问未知的对象属性</li><li>IOError：输入/输出操作失败</li><li>OSError：操作系统产生的异常</li><li>KeyboardInterrupt：用户中断执行</li><li>ImportError：导入模块失败的时候</li><li>IndexError：索引超出序列的范围</li><li>KeyError：字典中查找一个不存在的关键字</li><li>MemoryError：内存溢出（可通过删除对象释放内存）</li><li>NameError：尝试访问一个不存在的变量</li><li>SyntaxError：语法错误导致的异常</li><li>IndentationError：缩进错误导致的异常</li><li>TypeError：不同类型间的无效操作</li><li>ValueError：传入无效的参数</li><li>UnicodeError：Unicode相关的异常（ValueError的子类）</li><li>UnicodeEncodeError：Unicode编码错误导致的异常（UnicodeError的子类）</li><li>UnicodeDecodeError：Unicode解码时的异常（UnicodeError的子类）</li><li>ZeroDivisionError：除数为零</li></ul><h3 id="2-2-Python标准警告总结"><a href="#2-2-Python标准警告总结" class="headerlink" title="2.2 Python标准警告总结"></a>2.2 Python标准警告总结</h3><ul><li>Warning：警告的基类</li><li>DeprecationWarning：关于被弃用的特征的警告</li><li>PendingDeprecationWarning：关于特性将会被废弃的警告</li><li>RuntimeWarning：可疑的运行时行为(runtime behavior)的警告</li><li>SyntaxWarning：可疑语法的警告</li><li>ImportWarning：用于在导入模块过程中触发的警告</li><li>UnicodeWarning：与Unicode相关的警告</li><li>BytesWarning：与字节或字节码相关的警告</li><li>ResourceWarning：与资源使用相关的警告</li></ul><h3 id="2-3-异常处理"><a href="#2-3-异常处理" class="headerlink" title="2.3 异常处理"></a>2.3 异常处理</h3><h4 id="2-3-1-try-except"><a href="#2-3-1-try-except" class="headerlink" title="2.3.1 try - except"></a>2.3.1 try - except</h4><pre><code>try:    执行代码except Exception as error:    发生异常时执行的代码</code></pre><p>工作方式：</p><ul><li>首先，执行<code>try</code>子句。如果没有异常发生，忽略<code>except</code>子句，<code>try</code>子句执行后结束。</li><li>如果在执行<code>try</code>子句的过程中发生了异常，那么<code>try</code>子句余下的部分将被忽略。与异常类型对应的except子句将被执行。</li><li>如果一个异常没有与任何的<code>except</code>匹配，那么这个异常将会传递给上层的<code>try</code>中。</li></ul><h4 id="2-3-2-try-except-else"><a href="#2-3-2-try-except-else" class="headerlink" title="2.3.2 try-except-else"></a>2.3.2 try-except-else</h4><pre><code>try:    执行代码except Exception as error:    发生异常时执行的代码else:    没有异常时执行的代码</code></pre><p>比如，判断文件是否可以打开，如果打开文件时没有发生异常则执行 else 部分的语句，读取文件内容，并关闭打开的文件。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">try:    f = open('E:/WorkSpace/test.txt', 'r')except Exception as err:    print("err: %s"%err)else:    content = f.readlines()    print(content)    f.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-3-try-except-finally"><a href="#2-3-3-try-except-finally" class="headerlink" title="2.3.3 try - except - finally"></a>2.3.3 try - except - finally</h4><pre><code>try:    执行代码except Exception as error:    发生异常时执行的代码else:    没有异常时执行的代码finally:    不管有没有异常都会执行的代码</code></pre><p>如果一个异常在<code>try</code>子句里被抛出，而又没有任何的<code>except</code>把它截住，那么这个异常会在<code>finally</code>子句执行后被抛出。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def divide(x, y):    try:        result = x / y        print("result is", result)    except ZeroDivisionError:        print("division by zero!")    finally:        print("executing finally clause")divide(2, 4)# 输出result is 0.5executing finally clausedivide(2, 0)# 输出division by zero!executing finally clausedivide('2', '4')# 输出executing finally clauseTypeError: unsupported operand type(s) for /: 'str' and 'str'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-4-抛出异常"><a href="#2-3-4-抛出异常" class="headerlink" title="2.3.4 抛出异常"></a>2.3.4 抛出异常</h4><p>使用<code>raise</code>语句抛出一个指定的异常。</p><pre><code>raise [Exception [, args [, traceback]]]</code></pre><p>Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（十二）：Python工程组织结构</title>
      <link href="/posts/38a64c6a.html"/>
      <url>/posts/38a64c6a.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-组织结构"><a href="#1-组织结构" class="headerlink" title="1. 组织结构"></a>1. 组织结构</h2><ul><li>Python项目的组织结构主要由<strong>包—模块—类</strong>这些部分构成。</li><li><strong>包：</strong>可以看成文件夹，可以包含多个模块。如果让普通文件夹变成python的包，在该文件夹下必须包含<strong>init</strong>.py文件。<code>__init__.py</code>也是一个特殊的模块，模块名就是包名。</li><li><strong>模块：</strong>可以看成文件，对应python中的.py文件。一个模块下面也可以包含多个类。模块下面也可以直接写函数。</li><li><strong>类：</strong>类中定义了变量和函数。</li><li><strong>函数：</strong>用于实现特定功能，</li></ul><h2 id="2-模块导入"><a href="#2-模块导入" class="headerlink" title="2. 模块导入"></a>2. 模块导入</h2><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//demo1.png" alt></p><h3 id="2-1-import"><a href="#2-1-import" class="headerlink" title="2.1 import"></a>2.1 import</h3><p>import只能引入模块，不能直接引入变量或函数。</p><p>示例：在main.py文件中导入包package1中的模块module1.py和module2.py。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import package1.module1import package1.module2 as pm2   # 多层调用太长，可以重命名print(package1.module1.var1)print(pm2.num1)# 输出Python1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-from…import"><a href="#2-2-from…import" class="headerlink" title="2.2 from…import"></a>2.2 from…import</h3><p>可以导入模块、变量或函数。</p><ul><li>导入模块</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">from package1 import module1from package1 import module2print(module1.var2)print(module2.num2)# 输出Go2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>导入变量或函数</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">from package1.module1 import var3print(var3)# 输出Java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>导入模块下所有内容</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">from package1.module2 import *   # 一般不建议使用*print(num2)# 输出2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>控制模块中对外暴露的内容</li></ul><p>在<code>module2.py</code>模块中定义了<code>__all__=['num1', 'num2']</code>，则导入模块<code>module2.py</code>时只可导入<code>num1, num2</code>，其他内容不可见。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from package1.module2 import *print(num3)# 输出NameError: name 'num3' is not defined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，<code>__all__</code>属性仅在使用<code>import *</code>时才有效。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from package1.module2 import num3print(num3)# 输出3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>导入模块换行</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 使用 \from package1.module2 import num1, \    num2, num3# 使用()，推荐这种方式from package1.module2 import (num1,    num2, num3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-包和模块导入注意点"><a href="#2-3-包和模块导入注意点" class="headerlink" title="2.3 包和模块导入注意点"></a>2.3 包和模块导入注意点</h3><ul><li><p>包和模块不会重复导入：在导入一个模块的时候，就会执行这个模块里的所有内容，但是多次导入只执行一次。</p></li><li><p>不建议循环引入：多个模块文件间不建议相互调用，会导致报错。</p></li></ul><h3 id="2-4-相对导入和绝对导入"><a href="#2-4-相对导入和绝对导入" class="headerlink" title="2.4 相对导入和绝对导入"></a>2.4 相对导入和绝对导入</h3><ul><li>绝对导入：必须从顶级包开始。</li><li>相对导入：<code>.</code>表示当前目录，<code>..</code>上一级目录。</li><li>import不能使用相对导入，如import .package2.package4.m2。</li><li>入口文件不可以使用相对路径来导入模块，只能使用绝对路径。</li><li>python -m main.py 将入口文件当作一个模块执行，则可以使用相对路径导入模块。</li></ul><h3 id="2-5-模块搜索路径"><a href="#2-5-模块搜索路径" class="headerlink" title="2.5 模块搜索路径"></a>2.5 模块搜索路径</h3><p>当我们导入模块时，默认情况下python解析器会搜索当前目录、已安装的内置模块和第三方模块，搜索路径存放在<strong>sys模块的path</strong>中。sys.path返回一个列表</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import sysprint(sys.path)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>当我们需要添加自定义的搜索目录时，使用如下命令：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import syssys.path.append('自定义模块的路径')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-6-模块推荐导入顺序"><a href="#2-6-模块推荐导入顺序" class="headerlink" title="2.6 模块推荐导入顺序"></a>2.6 模块推荐导入顺序</h3><p>在文件中需要导入内置模块、第三方模块或自定义模块时，<strong>建议的导入顺序是：标准库模块—第三方模块—自定义模块</strong>。</p><h2 id="3-init-py的用法"><a href="#3-init-py的用法" class="headerlink" title="3. __init__.py的用法"></a>3. <code>__init__.py</code>的用法</h2><ul><li>用来标识该文件夹是一个包。</li><li>导入包或包下的模块时，<code>__init__.py</code>文件被自动执行。</li><li><code>__init__.py</code>文件中也可以利用<code>__all__</code>来限制导入的模块。</li></ul><p>例如，在<code>__init__.py</code>定义如下内容：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">__all__ = ['module1']<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在main.py中导入模块module2.py。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from package1 import *print(module2.num1)  # 输出NameError: name 'module2' is not defined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于在<code>__init__.py</code>文件中限制了导入的模块，<code>module2.py</code>不能被导入。</p><ul><li>批量导入模块</li></ul><p>如果在项目中有模块是多个文件共用的，可以把这些模块在<code>__init__.py</code>导入。</p><h2 id="4-入口文件"><a href="#4-入口文件" class="headerlink" title="4. 入口文件"></a>4. 入口文件</h2><p>Python 是脚本语言，和 C++、Java 最大的不同在于，不需要显式提供 main() 函数入口。在Python文件中，<code>__name__ == '__main__'</code>被用于定义入口文件。这些文件既可以作为模块被导入，也可以执行。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">if __name__ == '__main__':    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果文件作为模块被导入，<code>__name__</code>被赋值模块的名字。当文件执行被执行时，<code>__name__</code>为<code>__main__</code>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（十一）：面向对象</title>
      <link href="/posts/b9ae55.html"/>
      <url>/posts/b9ae55.html</url>
      
        <content type="html"><![CDATA[<p>面向对象中的两个基本概念就是类和对象。类用于定义抽象数据类型，而对象是类的一个实例。</p><h2 id="1-类与实例对象"><a href="#1-类与实例对象" class="headerlink" title="1. 类与实例对象"></a>1. 类与实例对象</h2><h3 id="1-1-类的定义与创建"><a href="#1-1-类的定义与创建" class="headerlink" title="1.1 类的定义与创建"></a>1.1 类的定义与创建</h3><p>类是现实世界或思维世界中的实体在计算机中的反映，它将数据以及这些数据上的操作封装在一起。简洁来说，类就是用来描述具有相同的属性和方法的对象的集合。属性就是定义在类中的变量，而方法就是定义在类中的函数。</p><p>类是对象的蓝图和模板，而对象是类的实例。类是抽象的概念，而对象是具体的东西。类有三个基本特性：封装、继承和多态：</p><ul><li>封装性：隐藏对象的属性和方法的实现细节，通过私有属性<strong>、</strong>私有方法的方式实现封装。</li><li>继承性：从已存在的类创建新类，复用父类里面的属性或者方法。</li><li>多态性：指同一个方法调用，由于对象不同可能会产生不同的行为。</li></ul><p>在Python中，使用关键字class定义一个类：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class ClassName:    <statement-1>    .    .    .    <statement-N><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在定义一个类时，需注意：</p><ul><li>类名首字母大写，当类名由多个单词构成时，采用“大驼峰式”命名法，即每个单词首字母大写。</li><li>类中定义的变量名小写，变量名由多个单词构成时，用下划线“_”连接。</li><li>类中定义的方法名小写，多个单词之间下划线“_”连接。</li></ul><p>定义一个简单的Student类：根据学生语数外三科考试分数，获取相应的等级。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Student():    stu_num = 0  # 类变量    def __init__(self, name, age, score):   # 构造函数        self.name = name   # 实例变量        self.age = age        self.score = score    def get_grade(self):  # 实例方法        temp = list(map(lambda x: x >= 90, self.score))        temp1 = list(map(lambda x: x >= 80, self.score))        if all(temp):             grade = 'A+'        elif temp.count(True) == 2 and all(temp1):            grade = 'A'        elif temp.count(True) == 1 and all(temp1):            grade = 'B'        elif temp.count(True) == 0 and all(temp1):            grade = 'C'        else:            grade = 'D'        print(f"{self.name}今年{self.age},期末考试等级为{grade}")stu1 = Student('张三', 14, score = [100, 90, 85])  # 实例化为对象stu2 = Student('李四', 13, score = [98, 95, 92]) stu1.get_grade()stu2.get_grade()# 输出张三今年14,期末考试等级为A李四今年13,期末考试等级为A+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面一个示例中，其实已经包含了类和对象的一些内容，如类变量、实例变量、实例方法、构造函数、类的实例化等。接下来，我们逐一学习这些内容。</p><h3 id="1-2-创建实例化对象"><a href="#1-2-创建实例化对象" class="headerlink" title="1.2 创建实例化对象"></a>1.2 创建实例化对象</h3><p>对象是类的实例。创建一个类的实例化对象：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">stu = Student('张三', 14, score = [100, 90, 85])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对象实例化过程：首先创建一个类的对象，然后再初始化对象。首先，看一个实例化示例：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Student(object):    def __new__(cls, name, age):        print('__new__ called.')        return super(Student, cls).__new__(cls)    def __init__(self, name, age):        print('__init__ called.')        self.name = name        self.age = age    def __str__(self):        return '<Student: %s(%s)>' % (self.name, self.age)stu = Student('王五', 15)print(stu)# 输出__new__ called.__init__ called.<Student: 王五(15)><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上述示例可以看到，实例化时先执行<code>__new__</code>方法，再执行<code>__init__</code>方法。具体执行过程：</p><ul><li>首先，执行<code>__new__</code>方法，创建并返回cls（cls指代当前类）的一个实例。</li><li>然后，调用<code>__init__</code>方法进行初始化，上一步创建的实例就是<code>__init__</code>方法中的self。</li></ul><p><strong><code>__new__</code>和<code>__init__</code>的一些说明：</strong></p><ul><li><code>__new__</code>方法是一个构造方法，用于创建实例，并返回cls实例，是一个静态方法。<code>__new__</code>方法是在继承自object的新式类中才有的（object为所有类的基类，从object继承得来的类称为新式类）。<code>__new__</code>方法是有返回值。<code>__new__</code>方法中的第一个参数cls代表当前要实例化的类。</li><li><code>__init__</code>方法是在<code>__new__</code>方法创建实例对象后调用的，self代表创建的这个实例对象。<code>__init__</code>实际是一个初始化方法，用于设置对象属性的初始值，没有返回值。</li><li>我们在定义类时如果没有重写<code>__new__</code>方法，Python默认是调用该类的直接父类的<code>__new__</code>方法来构造该类的实例，如果该类的父类也没有重写<code>__new__</code>方法，那么将一直按此追溯至基类object的<code>__new__</code>()方法。</li><li>我们经常会见到<code>__init__</code>方法，但是很少见到<code>__new__</code>方法，主要是因为<code>__new__</code>方法经常不被重写，Python中默认调用了父类的<code>__new__</code>方法，如果父类没有就继续上溯，直到object的<code>__new__</code>方法。</li><li>如果我们在类中重写了<code>__new__</code>方法，那么可以自由选择任意一个的其他的新式类的<code>__new__</code>方法来创建实例，但不能调用自身的<code>__new__</code>方法，因为这会造成死循环。</li></ul><h3 id="1-3-构造函数"><a href="#1-3-构造函数" class="headerlink" title="1.3 构造函数"></a>1.3 构造函数</h3><p>在我们定义类时，我们一般更习惯称<code>__init__()</code>为构造函数，用来初始化对象属性。实例化时自动调用构造函数，不需显式调用。构造函数返回None，不能返回字符串等其他内容。</p><p>在类中添加一个<code>__init__()</code>方法，当创建实例时，<code>__init__()</code>方法被自动调用，我们就能为每个实例都统一加上属性。下面看一个具体示例：定义一个Person类，拥有name, gender,和birth属性。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Person(object):   # python3中默认继承object，可不显式继承    def __init__(self, name, gender, birth):   # 构造函数        self.name = name        self.gender = gender        self.birth = birthperson1 = Person('Henry', 'Male', 18) # 实例化，传入参数person2 = Person('Tom', 'Male', 19)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>__init__()</code> 方法的第一个参数必须是 <code>self</code>，代表当前实例对象。后续的参数用于初始化对象属性。相应地，创建实例时，就必须要提供除 <strong>self</strong> 以外的参数。</p><h3 id="1-4-类变量与实例变量"><a href="#1-4-类变量与实例变量" class="headerlink" title="1.4 类变量与实例变量"></a>1.4 类变量与实例变量</h3><p>类变量与类关联在一起，实例变量与对象相关联。</p><ul><li>类变量（类属性）：定义在类中，方法（函数）外的变量。所有类的实例化对象都可以共享类变量，可以通过类名访问，也可以通过实例化对象访问（不推荐，类变量一般不于对象相关联在一起）。</li><li>实例变量（实例属性）：用self修饰的变量，在构造函数中定义的，一般用于类的实例方法中。实例变量只能通过对象名访问，无法通过类名访问。</li></ul><p>除了上面两类变量，我们也应了解全局变量和局部变量：</p><ul><li>全局变量：在模块内、在所有函数外面、在class外面定义。</li><li>局部变量：对于函数来说，在函数内定义的为局部变量。而对于类而言，在类的方法中定义的变量（无self修饰）为局部变量。在上面定义的Student类中，temp就是一个局部变量。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Student():    name = 'zhangsan'    # 类变量    age = 18    def __init__(self, name, age):     # 构造函数        self.name = name    # 实例变量        self.age = age    def do_homework(self):      # 行为        var = "This is a local variable"  # 局部变量        print(var)        print('do homework!')# 访问类变量print(Student.name)# 修改类变量Student.age = 20print(Student.age)# 实例化stu = Student('lisi', 19)print(stu.name)  # 访问实例变量print(stu.age)stu.do_homework() # 调用实例方法# 输出zhangsan20lisi19This is a local variabledo homework!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，应注意类与对象的变量查找顺序：先去查找实例变量，如果没有再去查找类变量。</p><h3 id="1-5-self与实例方法"><a href="#1-5-self与实例方法" class="headerlink" title="1.5 self与实例方法"></a>1.5 self与实例方法</h3><p>实例方法：在类中定义的函数，第一个参数是self，指向调用该方法的实例本身，其他参数和一个普通函数是完全一样。在实例方法内部，可以访问所有实例属性。注意，self参数的命名不是固定的，只是一般约定为self。</p><p>调用：调用实例方法时，不需加self，并且只能由实例对象调用。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Student():    def __init__(self, name, age):     # 构造函数        self.name = name            self.age = age    def do_homework(self):      # 实例方法，self就是指代Student类实例化后的对象。        print('do homework!')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-类方法"><a href="#1-6-类方法" class="headerlink" title="1.6 类方法"></a>1.6 类方法</h3><p>类方法：在类中定义，并且用@classmethod装饰的方法。类方法的第一个参数为 cls，指代类本身。</p><p>调用：在调用类方法时，无需显式为 cls 参数传参。可以通过类名和实例对象调用，不过<strong>一般推荐使用类名</strong>。</p><p>建议：类方法操作类变量，如果操作与对象无关的变量，最好还是使用类方法。</p><p>示例：定义一个Student类，每实例化一个对象，学生人数加一，获取学生人数。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Student():    total_num = 0    def __init__(self, name, age):             self.name = name        self.age = age        self.__class__.total_num += 1    def get_grade(self):               pass    @classmethod       def plus_sum(cls):  # 类方法        print('当前班级学生总数为: %s人' % str(cls.total_num))stu1 = Student('zhangsan', 18)stu2 = Student('lisi', 19)stu3 = Student('wangwu', 18)Student.plus_sum()# 输出当前班级学生总数为: 3人<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注： 在上面示例中 <code>self.__class__</code>是实例调用<code>__class__</code>属性，会指向该实例对应的类。 <code>self.__class__.total_num</code>表示访问类属性total_num。</p><h3 id="1-7-静态方法"><a href="#1-7-静态方法" class="headerlink" title="1.7 静态方法"></a>1.7 静态方法</h3><p>静态方法：用 @staticmethod 装饰的方法，不带 self 、cls这种特殊参数。类的静态方法和我们学过的函数很像，只是定义在类命名空间中。此外，类的静态方法体中不能使用类或实例的属性和方法。</p><p>调用：可以通过类名和实例对象调用。</p><p>建议：不要经常使用静态方法</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">@staticmethoddef add():    print("This is a static method!")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-8-特殊属性与特殊方法"><a href="#1-8-特殊属性与特殊方法" class="headerlink" title="1.8 特殊属性与特殊方法"></a>1.8 特殊属性与特殊方法</h3><h4 id="1-8-1-特殊属性"><a href="#1-8-1-特殊属性" class="headerlink" title="1.8.1 特殊属性"></a>1.8.1 特殊属性</h4><p>特殊属性：属性名以两个下划线开头，两个下划线结尾，如<code>__dict__</code>。</p><ul><li><code>__doc__</code>：获取类的文档字符串。</li><li><code>__module__</code>：类所在的模块，类和实例对象都可调用。</li><li><code>__class__</code>：实例对象所属的类，只有对象可以调用。</li><li><code>__dict__</code>：类和实例都可调用。类调用时返回这个类中已经定义了的属性和方法，包括特殊方法。实例调用时返回实例的属性字典。</li><li><code>__name__</code>：类名</li><li><code>__bases__</code>：类的所有父类构成元素</li></ul><p>示例：定义一个Programmer类。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Programmer():    "This is a Programmer Class"    num  = 0    hobby = 'Play computer games.'    def __init__(self, name, age):             self.name = name        self.age = age        self.__class__.num += 1    @classmethod   # 类方法    def plus_sum(cls):        print('当前班级学生总数为: %s人' % str(cls.num))    @classmethod    def get_hobby(cls):        return cls.hobby    def self_introduction(self):        print(f"My name is {self.name}, I'm {self.age} years old.")RD = Programmer('小王', 28)print(f'Programmer.__doc__: {Programmer.__doc__}')print(f'Programmer.__module__: {Programmer.__module__}')print(f'RD.__module__: {RD.__module__}')print(f'RD.__class__: {RD.__class__}')print(f'Programmer.__dict__: {Programmer.__dict__}')print(f'RD.__dict__: {RD.__dict__}')print(f'Programmer.__name__: {Programmer.__name__}')print(f'Programmer.__bases__: {Programmer.__bases__}')# 输出Programmer.__doc__: This is a Programmer ClassProgrammer.__module__: __main__RD.__module__: __main__RD.__class__: <class '__main__.Programmer'>Programmer.__dict__: {'__module__': '__main__', '__doc__': 'This is a Programmer Class', 'num': 1, 'hobby': 'Play computer games.', '__init__': <function Programmer.__init__ at 0x00000268CA4625E8>, 'plus_sum': <classmethod object at 0x00000268CA43C8C8>, 'get_hobby': <classmethod object at 0x00000268CA43CF48>, 'self_introduction': <function Programmer.self_introduction at 0x00000268CA462288>, '__dict__': <attribute '__dict__' of 'Programmer' objects>, '__weakref__': <attribute '__weakref__' of 'Programmer' objects>}RD.__dict__: {'name': '小王', 'age': 28}Programmer.__name__: ProgrammerProgrammer.__bases__: (<class 'object'>,)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-8-2-特殊方法"><a href="#1-8-2-特殊方法" class="headerlink" title="1.8.2 特殊方法"></a>1.8.2 特殊方法</h4><p>特殊方法（昵称魔术方法，又称双下方法）：方法名以两个下划线开头，以两个下划线结尾，如<code>__init__、__new__</code>。python的特殊方法定义在类中，不需要直接调用，Python的某些函数或操作符会调用对应的特殊方法。Python中有很多特殊方法，这里仅介绍部分。</p><ul><li><p><code>__new__、__init__、__call__、__del__</code></p><p><code>__new__、__init__</code>在1.2节已经介绍过，在实例化对象时会调用<code>__new__</code>和<code>__init__</code>。</p><p><code>__call__</code>：如果定义了这个方法，则类的实例对象可以像函数一样被调用。</p><p><code>__del__</code>：析构方法，当在对象被销毁的时候被调用。</p></li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Programmer():    '''描述类的信息'''    def __init__(self, name, age):           print('__init__ called.')        self.name = name        self.age = age    def __call__(self, content):        print('__call__ called.')        print(content)    def __del__(self):        print('__del__ called.')RD = Programmer('Tom', 28)del RD# 输出__init__ called.__del__ called.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>__str__、__repr__</code></p><p><code>__str__</code>：通过<code>str(obj)</code>以及内置函数<code>format()</code>和<code>print()</code>调用以生成一个对象的字符串表示，并且它返回的字符串对终端用户更友好。</p><p><code>__repr__</code>：是由<code>repr()</code>内置函数调用，把一个对象用字符串的形式表达出来。</p><p><code>__str__</code>和<code>__repr__</code>的区别：虽然都是把一个对象用字符串的形式表达出来，但是<code>__str__</code> 的目标可读性更好，是面向用户的。<code>__repr__</code> 的目标是明确的，所返回的字符串应该准确、无歧义，主要是面向开发者。</p></li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Programmer():    '''描述类的信息'''    def __init__(self, name, age):           print('__init__ called.')        self.name = name        self.age = age    def __str__(self):        print('__str__ called.')        return '(Programmer: %s, %s)' % (self.name, self.age)RD = Programmer('Tom', 28)print(RD)# 输出__init__ called.__str__ called.(Programmer: Tom, 28)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>__len__</code></p><p>定义 <code>len(obj)</code> 返回的内容。</p></li><li><p><code>__slots__</code></p><p>限制类的实例允许添加的属性,是一个元组。</p></li><li><p><code>__lt__、__eq__、__gt__</code></p><p>定义&gt;、==、&lt;等运算符的行为。</p></li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Programmer():    '''描述类的信息'''    __slots__ = ['name', 'age']    def __init__(self, name, age):           print('__init__ called.')        self.name = name        self.age = age    def __len__(self):        print('__len__ called.')        return len(self.name)    def __gt__(self, other):        print('__gt__ called.')        return len(self.name) >= len(other)RD = Programmer('Tom', 28)RD1 = Programmer('Henry', 26)print(len(RD))print(RD > RD1)# 输出__init__ called.__init__ called.__len__ called.3__gt__ called.__len__ called.False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>__getattr__、__getattribute__、__setattr__、__delattr__</code></p><p><code>__getattr__</code>：当访问不存在的属性时调用。</p><p><code>__getattribute__</code>：当访问某个实例属性时， <code>__getattribute__</code>会被调用。如果访问的属性不存在，调用<code>__getattribute__</code>方法并抛出 <code>AttributeError</code> 异常时,才会调用 <code>__getattr__</code> 方法。此外，为了防止无限递归调用，定义<code>__getattribute__</code>方法时从object继承<code>__getattribute__</code>方法。</p><p><code>__setattr__</code>：当访问属性并赋值是会调用。</p><p><code>__delattr__</code>：当删除属性时会被调用。</p></li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Programmer():    '''描述类的信息'''    def __init__(self, name, age):           print('__init__ called.')        self.name = name        self.age = age    def __getattr__(self, item):        print('__getattr__ called.')        raise AttributeError('{} object has no attribute {}'.format(type(self), item))    def __getattribute__(self, item):        print('__getattribute__ called.')        try:            return super(Programmer, self).__getattribute__(item)        except AttributeError:            raise AttributeError('{} object has no attribute {}'.format(type(self), item))    def __setattr__(self, key, value):        print('__setattr__ called.')        self.__dict__[key] = valueRD = Programmer('Tom', 28)---------------------------print(RD.name)---------------------------RD.hobby = 'Play computer games.'print(RD.hobby)---------------------------RD.weight# 输出__init__ called.__setattr__ called.__getattribute__ called.__setattr__ called.__getattribute__ called.----------------------------__getattribute__ called.Tom----------------------------__setattr__ called.__getattribute__ called.__getattribute__ called.Play computer games.----------------------------__getattribute__ called.__getattr__ called.AttributeError: <class '__main__.Programmer'> object has no attribute weight<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>__add__、__sub__、__mul__、__abs__</code>：定义+、-、*、abs等算术运算的行为。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">from math import hypotclass Vector:    def __init__(self, x=0, y=0):        self.x = x        self.y = y    def __repr__(self):        return 'Vector(%r, %r)' % (self.x, self.y)    def __abs__(self):        return hypot(self.x, self.y)    def __add__(self, other):        x = self.x + other.x        y = self.y + other.y        return Vector(x, y)    def __mul__(self, scalar):        return Vector(self.x * scalar, self.y * scalar)v1 = Vector(4, 3)v2 = Vector(1, 5)print(abs(v1))   # 使用abs()求模，解释器自动调用__abs__方法print(v1 + v2)   # 使用+求向量加法，解释器自动调用__add__方法print(v1 * 3)    # 使用*求向量与数的乘法，解释器自动调用__mul__方法# 输出5.0Vector(5, 8)Vector(12, 9)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>__enter__、__exit__</code></li></ul><p>实现上下文管理，即可以和with结合使用。为了让一个对象兼容with语句，必须在这个对象的类中定义<code>__enter__</code>和<code>__exit__</code>方法，具体可以参考<a href="https://www.linwang93.cn/posts/4068f7eb.html">【流程控制与关键字】</a>一文中的介绍。</p><ul><li><code>__getitem__、__setitem__、__delitem__</code></li></ul><p>如果自定义的类想像序列类型一样支持索引取值、索引赋值等操作，定义的类需要实现<code>__getitem__</code>、<code>__setitem__</code>和<code>__delitem__</code>。</p><p><code>__getitem__</code>：用于获取指定索引的值。</p><p><code>__setitem__</code>：定义设置给定键的值。</p><p><code>__delitem__</code>：删除给定键对应的元素。</p><ul><li><code>__contains__</code>：定义当使用成员运算符（in 或 not in）时的方法。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Programmer():    def __init__(self, name, age):           print('__init__ called.')        self.name = name        self.age = age    def __getitem__(self, item):        print('__getitem__ called.')        return self.__dict__[item]    def __setitem__(self, key, value):        print('__setitem__ called.')        self.__dict__[key] = value    def __delitem__(self, key):        print('__delitem__ called.')        del self.__dict__[key]    def __contains__(self, item):        print('__contains__ called.')        return item in self.__dict__RD = Programmer('Tom', 28)print(RD['name'])-------------------------------------RD['hobby'] = 'Play computer games.'print(RD['hobby'])-------------------------------------del RD['hobby']print('name' in RD)print('hobby' in RD)# 输出__init__ called.__getitem__ called.Tom-------------------------------------__setitem__ called.__getitem__ called.Play computer games.-------------------------------------__delitem__ called.__contains__ called.True__contains__ called.False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>__iter__、__next__</code></li></ul><p>任意对象，只要定义了<code>__iter__</code>和<code>__next__</code>方法，它就是一个迭代器。具体可参考<a href="https://www.linwang93.cn/posts/4360111c.html">【迭代器与生成器】</a>一文的介绍。</p><h3 id="1-9-访问限制：公有与私有"><a href="#1-9-访问限制：公有与私有" class="headerlink" title="1.9 访问限制：公有与私有"></a>1.9 访问限制：公有与私有</h3><p>Python并没有真正的私有化支持，但是, 可以使用下划线完成<strong>“伪私有”</strong>的效果。</p><ul><li>变量和方法前加单下划线<code>'_'</code>：表示受保护的变量或方法。这样的数据成员在外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的标识符时，意思就是，“虽然我可以被外部访问，但是，请把我视为私有成员，不要在外部访问我！”。</li><li>变量和方法前加双下划线<code>'__'</code>：表示私有成员，在类的内部可以访问，不可以从外部访问。必须说明的是，这种其实是“伪私有”，并没有从语法层面彻底限制对私有成员的访问。本质上，外部不能直接访问<code>"__"</code>定义的变量或方法是因为Python解释器对外把<code>__var</code>变量改成了<code>_class__var</code>，也就是<code>_类名__变量名</code>。因此，我们其实还是可以通过<code>_类名__变量名</code>对变量进行访问的，但一般不建议这样做。</li><li>变量或方法前后都加双下划线<code>"__"</code>：表示特殊属性和方法，如上面介绍的<code>__name__、__init__</code>等。</li></ul><p>如果外部相对私有成员进行，建议在类的内部创建外部可以访问的方法。下面通过一个具体示例来介绍：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Programmer():    "This is a Programmer Class"    def __init__(self, name, age, weight):             self.name = name        self.age = age        self.__weight = weight    def self_introduction(self):        print(f"My name is {self.name}, I'm {self.age} years old.")    def get_weight(self):        return self.__weight    def set_weight(self, weight):        self.__weight = weightRD = Programmer('Tom', 28, '78kg')RD.__weight  # 实例直接访问私有变量会报错------------------------------------print(RD._Programmer__weight)  # 不建议这样做------------------------------------print(RD.get_weight())   # 通过类中定义的方法获取私有变量------------------------------------RD.set_weight('80kg')print(RD.get_weight())# 输出AttributeError: 'Programmer' object has no attribute '__weight'  ------------------------------------78kg------------------------------------78kg------------------------------------80kg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-10-槽（slots）"><a href="#1-10-槽（slots）" class="headerlink" title="1.10 槽（slots）"></a>1.10 槽（slots）</h3><p>在定义类时，使用<code>__slots__</code>来限制类的属性。<code>__slots__</code>可以节省内存，并获取更快的访问速度。此外，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类不起作用。除非在子类中也定义<code>__slots__</code>，这样，子类允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Person(object):    __slots__ = ('name', 'gender', 'age')    def __init__(self, name, gender, age):        self.name = name        self.gender = gender        self.age = ageclass Student(Person):    __slots__ = ('score')    def __init__(self, name, gender, age, score):        self.score = score        super(Student, self).__init__(name, gender, age)s = Student('Tom', 'male', 19, 670)s.name = 'Henry'print(s.name)print(s.gender)print(s.score)s.hobby = 'Play computer games.'# 输出Henrymale670AttributeError: 'Student' object has no attribute 'hobby'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-11-property装饰器"><a href="#1-11-property装饰器" class="headerlink" title="1.11 @property装饰器"></a>1.11 @property装饰器</h3><h4 id="1-11-1-property"><a href="#1-11-1-property" class="headerlink" title="1.11.1 @property"></a>1.11.1 @property</h4><p>@property是Python中一个内置的装饰器，对类的方法进行装饰可以让方法<strong>以属性的形式进行访问和调用</strong>。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Student(object):    def __init__(self, name, score):        self.name = name        self.__score = score    @property    def get_score(self):        return self.__scorestu = Student('Tom', 18)print(stu.get_score) print(stu.get_score()) # @property装饰后方法再加()调用会报错。# 输出18TypeError: 'int' object is not callable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来，我们再看一个实例，看看@property的应用场合：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Student():    def __init__(self, name, score):        self.name = name        self.__score = score    @property    def score(self):        return self.__score    @score.setter    def score(self, score):        if score < 0 or score > 100:            raise ValueError('invalid score')        self.__score = score    @score.deleter    def score(self):        del self.__scorestu = Student('Tom', 18)print(stu.score)---------------------------------stu.score = 90print(stu.score)---------------------------------stu.score = -10---------------------------------del scoreprint(stu.score)# 输出18---------------------------------90---------------------------------ValueError: invalid score---------------------------------NameError: name 'score' is not defined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面示例我们可以看到，通过@property装饰器我们可以分别定义出对同一个属性的获取、修改和删除的操作。 @property装饰的score方法相当于一个get方法，用于获取属性值。@score.setter装饰的score方法相当于一个set方法，用于设置或修改属性值。@score.deleter修饰的方法相当于一个del方法，用于删除属性值。</p><h4 id="1-11-2-property-函数"><a href="#1-11-2-property-函数" class="headerlink" title="1.11.2 property()函数"></a>1.11.2 property()函数</h4><p>除了使用装饰器的方式将一个方法伪装成属性外，我们还可以使用内置的property()函数。property()函数的作用是在新式类中返回属性值。</p><p>python函数语法：<code>property(fget=None, fset=None, fdel=None, doc=None)</code></p><p>参数：fget是获取属性值的方法，fset是设置属性值的方法，fdel是删除属性值的方法，doc是属性描述信息。</p><p>返回值：返回新式类属性。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Student():    def __init__(self, name, score):        self.name = name        self.__score = score    def get_score(self):        return self.__score    def set_score(self, score):        if score < 0 or score > 100:            raise ValueError('invalid score')        self.__score = score    def del_score(self):        del self.__score    score = property(get_score, set_score, del_score, "This is a score property.")stu = Student('Tom', 18)print(stu.score)stu.score = 90print(stu.score)print(Student.score.__doc__)del scoreprint(stu.score)# 输出1890This is a score property.NameError: name 'score' is not defined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-多态与继承"><a href="#2-多态与继承" class="headerlink" title="2. 多态与继承"></a>2. 多态与继承</h2><h3 id="2-1-类的继承"><a href="#2-1-类的继承" class="headerlink" title="2.1 类的继承"></a>2.1 类的继承</h3><p>继承是新建类的一种方式，新建类称为<strong>子类</strong>或<strong>派生类</strong>，被继承的类称为<strong>基类</strong>、<strong>父类</strong>或<strong>超类</strong>。通过继承父类的属性和方法，对类的属性和方法重用，能够大大的减少代码量。</p><p>例如，已知我们已定义了一个Person类，拥有属性name, gender：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Person():    def __init__(self, name, gender):        self.name = name        self.gender = gender<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们想再定义Student类和Teacher类，其中Student类需要定义的属性有name, gender, school, score，Teacher类需要定义的属性有name, gender, school, course。那我们是不是需要分别从头编写定义这两个类的所有属性呢，当然可以这么做，但这里更好的一种操作是我们从已有的Person类中继承已有的属性。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Student(Person):    def __init__(self, name, gender, school, major):        # Python3中可以直接使用super().__init__(name, gender)        super(Student, self).__init__(name, gender)          self.school = school        self.major = majorclass Teacher(Person):    def __init__(self, name, gender, school, course):        super(Student, self).__init__(name, gender)        self.school = school        self.course = course<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面可以看出，定义的新类不必从头编写，可以从现有的类中继承，自动拥有现有类的所有功能，新类只需要编写现有类缺少的功能即可。</p><p><strong>继承的好处：</strong>复用已有的代码，自动拥有现有类的所有功能，只需要编写缺少的功能。</p><p><strong>继承的特点：</strong>子类和父类是is关系。如果类间关系是has关系，应该使用组合而非继承。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">p = Person('Tom', 'male')s = Student('Tom', 'male', 'Harvard University', 'computer engineering')print(isinstance(p, Person))  # isinstance()用于判断一个对象是否是一个已知的类型。print(isinstance(p, Student))print(isinstance(s, Person))print(isinstance(s, Student))print(issubclass(Student, Person))  # issubclass(sub, sup)用于判断一个类是否是另一个类的子类# 输出TrueFalseTrueTrueTrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们定义一个Book类，与Student类应该是has关系，使用继承就不合适了，应该作为Student的一个属性出现。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Student(Person):    def __init__(self, bookName):        self.bookName = Book(bookName)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>继承使用场合</strong>：假如要定义几个类，而类与类之间有一些公共的属性和方法，这时就可以把相同的属性和方法定义在基类中，而对于其他类独有的属性和方法在各自类中定义。这样子类只需要继承基类，子类就可以访问基类的属性和方法了。</p><p>除了继承父类的属性和方法，子类还可以自定义属性和方法，或者重写父类的方法。子类可以继承一个或多个父类，因此继承分为单继承和多继承。</p><h4 id="2-1-1-单继承"><a href="#2-1-1-单继承" class="headerlink" title="2.1.1 单继承"></a>2.1.1 单继承</h4><p>子类继承于一个父类。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Person():    def __init__(self, name, gender):        self.name = name        self.gender = gender    def get_gender(self):        return self.genderclass Student(Person):    def __init__(self, name, gender, school, major):        super().__init__(name, gender)        self.school = school        self.major = major    def get_info(self):        print(f"My name is {self.name}, I study in {self.school} and I major in {self.major}")p = Person('Tom', 'male')s = Student('Tom', 'male', 'Harvard University', 'computer engineering')s.get_info()print(s.get_gender())# 输出My name is Tom, I study in Harvard University and I major in computer engineeringmale<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面实例中，子类的构造函数调用了父类的构造函数，并重写了<code>__init__</code>函数，增加了自己的属性。同时，我们也可以用子类实例调用继承父类的方法<code>get_gender()</code>。</p><p>对于子类的构造函数主要有以下三种情形：</p><ul><li>子类不重写<code>__init__</code>方法，实例化子类后，自动调用父类的<code>__init__</code>方法。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Person():    def __init__(self, name, gender):        self.name = name        self.gender = gender    def get_info(self):        print(f'name: {self.name}, gender: {self.gender}')class Student(Person):    passs = Student('Tom', 'male')s.get_info()# 输出name: Tom, gender: male<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>子类重写<code>__init__</code>方法，没有显式调用父类的<code>__init__</code>方法，实例化子类后，不会自动调用父类的<code>__init__</code>方法。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Student(Person):    def __init__(self, name, gender, school, major):        self.name = name        self.gender = gender        self.school = school        self.major = major<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>子类子类重写<code>__init__</code>方法，同时显式调用父类的<code>__init__</code>方法（使用super关键字）。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Student(Person):    def __init__(self, name, gender, school, major):        super().__init__(name, gender)        self.school = school        self.major = major<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-多继承"><a href="#2-1-2-多继承" class="headerlink" title="2.1.2 多继承"></a>2.1.2 多继承</h4><p>子类继承于多个父类。注意，如果没有特殊的情况，应该尽量避免使用多重继承，因为多重继承会让我们的代码过于复杂。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class SubclassName(BaseClass1, BaseClass2, BaseClass3, ...):    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下面以一个示例介绍多重继承。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class A():    def __init__(self, item):        print('init A...')        self.item = itemclass B(A):    def __init__(self, item):        super(B, self).__init__(item)        print('init B...')class C(A):    def __init__(self, item):        super(C, self).__init__(item)        print('init C...')class D(B, C):    def __init__(self, item):        super(D, self).__init__(item)        print('init D...')d = D('test')# 输出init A...init C...init B...init D...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-方法重写"><a href="#2-2-方法重写" class="headerlink" title="2.2 方法重写"></a>2.2 方法重写</h3><p>如果继承的父类的方法不能满足需求，可以在新建的子类重写父类的方法，子类中的方法会覆盖掉父类中同名的方法。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Person():    def __init__(self, name, gender):        self.name = name        self.gender = gender    def get_basic_info(self):        print(f'name: {self.name}, gender: {self.gender}')class Student(Person):    def __init__(self, name, gender, school, major):        super().__init__(name, gender)        self.school = school        self.major = major    def get_education_info(self):        self.get_basic_info()        Person.get_basic_info(self)        print(f"I study in {self.school} and I major in {self.major}")stu = Student('Tom', 'male', 'Harvard University', 'computer engineering')stu.get_education_info()# 输出name: Tom, gender: malename: Tom, gender: maleI study in Harvard University and I major in computer engineering<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在子类中，如果定义的方法中需要调用父类的方法，可以采用以下两种方式：</p><ul><li>parentClass.parentMethod(self)</li></ul><p>直接用父类的类名.方法名去调用父类的方法，将self作为第一个参数，指向这个类的实例。</p><ul><li>self.parentMethod()</li></ul><p>用self去调用父类的方法，子类继承和父类的方法，可以直接调用。</p><h3 id="2-3-类的多态"><a href="#2-3-类的多态" class="headerlink" title="2.3 类的多态"></a>2.3 类的多态</h3><p>示例一：定义Programmer类和backendProgrammer类，其中backendProgrammer继承Programmer。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Programmer():    def __init__(self, name, age):             self.name = name        self.age = age    def self_introduction(self):        print(f"My name is {self.name}, I'm {self.age} years old.")class backendProgrammer(Programmer):    def __init__(self, name, age, language):        super().__init__(name, age)        self.language = language    def self_introduction(self):        print(f"My name is {self.name}, my favorite language is {self.language}.")def introduce(programmer):    if isinstance(programmer, Programmer):        programmer.self_introduction()programmer = Programmer('Tom', 28)backend_rogrammer = backendProgrammer('Henry', 27, 'Python')introduce(programmer)introduce(backend_rogrammer)# 输出My name is Tom, I'm 28 years old.My name is Henry, my favorite language is Python.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例二：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Person:    def __init__(self, name, age):        self.name = name        self.age = age    def print_age(self):        print("%s's age is %s" % (self.name, self.age))class Man(Person):    def print_age(self):        print("His name is %s' and his age is %s" %(self.name, self.age))class Woman(Person):    def print_age(self):        print("Her name is %s's and her age is %s" %(self.name, self.age))def person_age(person):    person.print_age()person = Person("Tom", 28)man = Man("Peter", 27)woman = Woman("Sunny", 25)person_age(person)person_age(man)person_age(woman)# 输出Tom's age is 28His name is Peter' and his age is 27Her name is Sunny's and her age is 25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从以上示例，我们可以看到对于不同类的实例对象，执行同名方法时，会呈现不同的结果。</p><p>多态的两大要素：继承和方法重写。多态首先是建立在继承的基础上的，子类对父类方法进行重写，在子类中呈现不同的结果。多态指的是一类事物有多种形态，如人分为男人和女人，会有不同的特征。多态性指的是对于继承自同一父类的不同子类对象，执行同名方法时会有不同的表现。比如，在Man和Woman类中都定义了print_age()方法，我们将实例化对象传入函数person_age()中，都会调用print_age()方法，结果呈现不同的输出结果。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（十）：迭代器与生成器</title>
      <link href="/posts/4360111c.html"/>
      <url>/posts/4360111c.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-可迭代对象"><a href="#1-可迭代对象" class="headerlink" title="1.可迭代对象"></a>1.可迭代对象</h2><p>对于Python中的任意对象，只要定义了可以返回⼀个迭代器的<code>__iter__</code>⽅法，或者定义了以⽀持下标索引的<code>__getitem__</code>⽅法，则该对象为可迭代对象。在Python中，所有的容器，比如列表、元组、字典、集合等，都是可迭代的（iterable）。</p><p>如何去判断一个对象是否是可迭代对象呢？可以通过以下几种方式进行判断：</p><ul><li>isinstance(obj, Iterable)</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">from collections.abc import Iterableprint(isinstance('hello world!', Iterable))   # 字符串是可迭代对象print(isinstance([1, 2, 3], Iterable))        # 列表是可迭代对象print(isinstance(123, Iterable))              # 数字不是可迭代对象# 输出TrueTrueFalse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用iter()函数判断，如不可迭代会报出TypeError。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">print(iter('hello world!'))print(iter([1, 2, 3]))print(iter(123))  # 数字不是可迭代对象，调用iter()会抛出异常TypeError# 输出<str_iterator object at 0x000001D2D2101848><list_iterator object at 0x000001D2D2101848>TypeError: 'int' object is not iterable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>for i in obj不报错的为可迭代对象。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">lst = [1, 2, 3]num = 123for item in lst:    passfor item in num:  # 报错    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际应用推荐使用isinstance()进行判断。</p><h2 id="2-迭代器"><a href="#2-迭代器" class="headerlink" title="2.迭代器"></a>2.迭代器</h2><p>任意对象，只要定义了<code>__iter__</code>和<code>__next__</code>方法，它就是一个迭代器。</p><p>迭代器的两个基本方法：</p><ul><li><code>__iter__</code>：返回迭代器本身self。</li><li><code>__next__</code>：返回迭代器下一个可用的元素，当最后没有元素时抛出StopIteration异常。</li></ul><p>迭代器的特点：</p><ul><li>迭代器一定是可迭代对象，因为实现了<code>__iter__</code>方法。</li><li>迭代器的<code>__iter__</code>方法返回的是自身，并不产生新的迭代器对象，只能遍历一次。若想再次迭代需要重建迭代器。</li><li>迭代器是惰性计算，只有在调用时才返回值，没有调用的时候就等待下一次调用。这样就节省了大量内存空间。</li></ul><p>创建一个迭代器：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 根据可迭代对象创建一个迭代器lst = [1, 2, 3]res = iter(lst)print(res)# 输出<list_iterator object at 0x000001D2D2166F88><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断对象是否是迭代器：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from collections.abc import Iteratorlst = [1, 2, 3, 4, 5]s = 'hello world!'d = {'a':1, 'b':2, 'c':3}# 判断可迭代对象是否为迭代器print(isinstance(lst, Iterator))print(isinstance(s, Iterator))print(isinstance(d, Iterator))# 根据可迭代对象创建迭代器print(isinstance(iter(lst), Iterator))print(isinstance(iter(s), Iterator))print(isinstance(iter(d), Iterator))# 输出FalseFalseFalseTrueTrueTrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>迭代器元素访问：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">d = {'a':1, 'b':2, 'c':3}d_iter = iter(d)print(next(d_iter))print(next(d_iter))print(d_iter.__next__())print(d_iter.__next__())  # 直到没有数据时抛出异常# 输出abcStopIteration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-for循环工作机制"><a href="#3-for循环工作机制" class="headerlink" title="3.for循环工作机制"></a>3.for循环工作机制</h2><p>在介绍了可迭代对象和迭代器，我们进一步总结一下可迭代对象和迭代器中的for循环工作机制。</p><h3 id="3-1-可迭代对象中for循环工作机制"><a href="#3-1-可迭代对象中for循环工作机制" class="headerlink" title="3.1 可迭代对象中for循环工作机制"></a>3.1 可迭代对象中for循环工作机制</h3><ul><li>先判断对象是否为可迭代对象(等价于判断有没有<strong>iter</strong>或<strong>getitem</strong>方法)，如果不可迭代则抛出TypeError异常。如果为可迭代对象则调用 <code>__iter__</code>方法，返回一个迭代器。</li><li>不断调用迭代器的<code>__next__</code>方法，每次按序返回迭代器中的一个值。</li><li>迭代到最后没有元素时，就抛出异常 StopIteration。这个异常Python自己会处理，不会暴露给开发者。</li></ul><h3 id="3-2-迭代器中for循环工作机制"><a href="#3-2-迭代器中for循环工作机制" class="headerlink" title="3.2 迭代器中for循环工作机制"></a>3.2 迭代器中for循环工作机制</h3><ul><li>调用 <code>__iter__</code>方法，返回自身self，也就是返回迭代器。</li><li>不断调用迭代器的next()方法，每次按序返回迭代器中的一个值。</li><li>迭代到最后没有元素时，就抛出异常 StopIteration。</li></ul><p>在Python中，for循环兼容两种机制：</p><ul><li>如果对象定义了<code>__iter__</code>，则会返回一个迭代器。</li><li>如果对象没有定义<code>__iter__</code>，但是实现了<code>__getitem__</code>，会改用下标迭代的方式。</li></ul><p>当for循环发现没有<code>__iter__</code>但是有<code>__getitem__</code>的时候，会从0开始依次读取相应的下标，直到发生IndexError为止。iter()方法也会处理这种情况，在不存在<code>__iter__</code>的时候，返回一个下标的迭代器对象来代替。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from collections.abc import Iterable, Iteratorclass Student(object):    def __init__(self,score):        self.score=score    def __getitem__(self,n):        return self.score[n]score= Student([90,95,98])print(isinstance(score, Iterable))print(isinstance(score, Iterator))print(isinstance(iter(score), Iterable))print(isinstance(iter(score), Iterator))# 输出FalseFalseTrueTrue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-生成器"><a href="#4-生成器" class="headerlink" title="4.生成器"></a>4.生成器</h2><p>生成器是一种特殊的迭代器。</p><h3 id="4-1-生成器创建"><a href="#4-1-生成器创建" class="headerlink" title="4.1 生成器创建"></a>4.1 生成器创建</h3><ul><li>生成器表达式</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""g = (expr for iter_var in iterable)与列表解析式结构很像，只是将[]换成了()。"""g = ( i**2 for i in range(5) )print(g)# 输出<generator object <genexpr> at 0x000001D2D217E048># 迭代for item in g:    print(item)# 输出014916<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成器表达式是按需求计算（或称惰性计算），需要的时候才计算值，返回一个迭代器，而列表解析式是立即返回值，返回可迭代对象列表。在内存占用上，生成器表达式要更省内存。</p><ul><li>生成器函数</li></ul><p>如果一个函数定义中包含<code>yield</code>关键字，则整个函数为生成器函数。在执行生成器函数过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 用生成器实现一个斐波那契数列。def fibonacci(n):    a, b, counter = 1, 1, 0    while counter < n:        yield a        a, b = b, a + b        counter += 1f = fibonacci(10)print(next(f))print(next(f))print('----')for item in f:    print(item)# 输出11----235813213455<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可迭代对象、迭代器、生成器之间的关系：</p><p><img src="https://gitee.com//linwang0714/ImgHosting/raw/master/article_img//iterator and generator.png" style="width:600px;"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（九）：函数进阶-匿名函数|高阶函数|闭包|装饰器</title>
      <link href="/posts/d7a6b6fc.html"/>
      <url>/posts/d7a6b6fc.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-匿名函数"><a href="#1-匿名函数" class="headerlink" title="1.匿名函数"></a>1.匿名函数</h2><p>Python中的函数，除了我们常见的def定义的函数，还有一种特殊的函数—匿名函数。def定义的函数是有具体函数名的，可以便于我们多次调用，而匿名函数是没有具体的函数名的，往往用于一次性实现某种功能的场合。在我们编码时，合理使用匿名函数，可以帮助我们大大简化代码的复杂度，提高代码的可读性。</p><p>匿名函数的关键字是<code>lambda</code>，之后是一系列的参数，然后用冒号隔开，最后则是由这些参数组成的表达式。lambda函数格式如下：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">lambda arg1, arg2,... argN : expression<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># lambdaf = lambda x, y: x + y   # 匿名函数赋值给一个变量# defdef add(x, y):    return x + y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>匿名函数 lambda 和常规函数def一样，返回的都是一个函数对象，很多时候用法是相似的，但也有一些区别。</p><ul><li>匿名函数是一个表达式，而不是一个语句。</li></ul><p>表达式是用一系列”公式”去表达某种内容，如 x + y，x ** 2等。而语句更强调的是完成了某种功能，如赋值语句、条件判断语句、循环语句等。由于匿名函数lambda是一个表达式，可以用于列表中、也可以作为某些函数的参数等，而常规的有名函一般不适用。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 用于列表推导lst = [(lambda x: x**2)(x) for x in range(10)]print(lst)# 输出[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]# 作为函数的参数d = {'b': 2, 'a': 1, 'c': 3}d_new = dict(sorted(d.items(), key=lambda x: x[1]))print(d_new)# 输出{'a': 1, 'b': 2, 'c': 3}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>lambda专注于一些简单的任务，def定义的常规函数则负责更复杂的多行逻辑。</li></ul><h2 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2.高阶函数"></a>2.高阶函数</h2><p>在介绍高阶函数前，需要了解一下函数式编程。Python提供了一些函数式编程的特性。函数式编程是指代码中每一块都是不可变的，都由纯函数的形式组成。纯函数是指返回结果只依赖于输入参数（外部的变化不会影响返回结果），而且执行过程没有副作用（不会改变外部环境的变量）。</p><p>在Python中，提供了几个遵循函数式编程思想的高阶函数：map()、reduce()、filter()，通常结合匿名函数 lambda 一起使用。</p><h3 id="2-1-map"><a href="#2-1-map" class="headerlink" title="2.1 map()"></a>2.1 map()</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""将function映射于可迭代对象iterable中的每一项，并返回一个新的列表或迭代器。语法：map(function, *iterable)参数：function为作用于可迭代对象元素的函数，iterable为可迭代对象，支持传入多个可迭代对象。返回值：Python2中返回列表，Python3返回迭代器。"""# 传入单个可迭代对象lst = [1,2,3,4,5,6,7,8]res = map(lambda x: x * x, lst)print(res)print(list(res))# 输出<map object at 0x0000020421827B48>  # Python3中返回一个map对象[1, 4, 9, 16, 25, 36, 49, 64]  # 将map对象转换为列表# 传入多个可迭代对象lst1 = [1,2,3,4,5,6,7,8]lst2 = [2,3,4,5]res = map(lambda x, y: x + y, lst1, lst2)print(res)# 输出[3, 5, 7, 9]  # 当传入多个可迭代对象时，输出元素个数等于较短序列长度。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-reduce"><a href="#2-2-reduce" class="headerlink" title="2.2 reduce()"></a>2.2 reduce()</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""连续计算。语法：reduce(function, iterable, initializer)参数：function是一个有两个参数的函数，对iterable中的每个元素以及上一次调用后的结果进行计算。iterable为可迭代对象。initializer为初始值，如果提供了初始值，会首先以初始值和iterable的第一个元素进行计算，否则以iterable的前两个元素开始计算。返回值：经过连续计算后返回一个单一值。"""from functools import reduce  # Python3中reduce()需要从functools中导入lst = list(range(10))res = reduce(lambda x, y: x + y, lst)print(res)    # (((1+2)+3)+4)+...# 输出45<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-filter"><a href="#2-3-filter" class="headerlink" title="2.3 filter()"></a>2.3 filter()</h3><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""对可迭代对象中元素进行过滤操作，过滤掉不符合条件的元素。对iterable中的每个元素，都使用function判断，并返回True 或者False，最后将返回True对应的元素组成一个可遍历的对象。语法：filter(function, iterable)参数：function为一个函数对象，iterable为一个可迭代对象。返回值：返回一个迭代器对象。"""lst = list(range(10))res = filter(lambda x: x % 2 == 0, lst)print(list(res))# 输出[0, 2, 4, 6, 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h2><p>闭包的形成首先需要是一个嵌套函数，由内嵌函数和外部函数定义时的环境变量（自由变量）构成。一个嵌套函数形成一个闭包需要满足以下三个条件：</p><ul><li>必须有一个内嵌函数。</li><li>内嵌函数必须要引用外部函数中定义的变量（自由变量）。</li><li>外部函数返回内嵌函数。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">def curve_pre():    a = 25    def curve(x):        return a * x * x    return curve# 调用f = curve_pre()print(f(2))# __code__属性中保存局部变量和自由变量的名称，__closure__属性中保存自由变量的值。print(f.__code__.co_varnames) # 局部变量print(f.__code__.co_freevars) # 自由变量print(f.__closure__) # 闭包函数有一个__closure__属性，定义了所有自由变量cell对象构成的元组。print(f.__closure__[0].cell_contents)# 输出100('x',)('a',)(<cell at 0x000002041D3D04C8: int object at 0x00007FFE986AA490>,)25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面示例可以看到内嵌函数curve()中引用了外部函数curve_pre()中定义的变量a，并且外部函数curve_pre将内嵌函数curve()作为返回值，满足闭包的条件。</p><h2 id="4-装饰器"><a href="#4-装饰器" class="headerlink" title="4.装饰器"></a>4.装饰器</h2><p>在Python中，装饰器应用广泛，是一个非常有用的功能。有时候，我们会遇到这样一个需求：在不改变原函数代码的基础上，想去扩展函数的功能。这时装饰器就派上用场了。所谓的装饰器，其实就是通过装饰器函数，在不改变原函数代码基础上，来增强原函数的功能。装饰器的这种特性可以总结为：对修改是封闭的，对扩展是开放的。在实际工程应用中，合理的使用装饰器会使得代码更加简洁，同时也会大大提升代码的复用性。</p><h3 id="4-1-装饰器结构"><a href="#4-1-装饰器结构" class="headerlink" title="4.1 装饰器结构"></a>4.1 装饰器结构</h3><p>装饰器本质上是一个闭包，它接受一个函数作为参数并返回一个新的函数。</p><h4 id="4-1-1-基本结构"><a href="#4-1-1-基本结构" class="headerlink" title="4.1.1 基本结构"></a>4.1.1 基本结构</h4><p>首先，我们以一个简单示例来介绍装饰器的基本结构。下面这个示例是通过装饰器实现对被装饰函数的执行计时。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import timedef decorator(func):    '''    Decorator that reports the execution time of a function.    '''    def wrapper():        start_time = time.time()        result = func()        end_time = time.time()        print(func.__name__, end_time-start_time)        return result    return wrapperdef sum_list():  # 对列表元素进行求和    num_sum = 0    lst = list(range(100000))    for i in lst:        num_sum += i    return num_sum# 装饰器decorator装饰函数sum_listsum_list = decorator(sum_list)result = sum_list()print(result)# 输出sum_list 0.0057930946350097664999950000# 一种更简洁的装饰：使用@语法糖@decorator  # @装饰器，相当于sum_list = decorator(sum_list)def sum_list():    num_sum = 0    lst = list(range(100000))    for i in lst:        num_sum += i    return num_sumresult = sum_list()print(result)print(sum_list.__name__)  # 装饰后的sum_list函数元信息改变# 输出sum_list 0.0057842731475830084999950000wrapper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从示例中我们可以看到函数被装饰器装饰后，原函数的<strong>元信息改变</strong>了，不再是定义的sum_list()函数，而是被wrapper()替代。为了保留原函数的元信息（如名字、文档字符串、注解和参数签名等），我们通过在构建装饰器时使用内置的装饰器@wrap，将原函数的元信息，拷贝到对应的装饰器函数里。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import timefrom functools import wrapsdef decorator(func):    '''    Decorator that reports the execution time of a function.    '''    @wraps(func)   # 保留原函数元信息    def wrapper():        start_time = time.time()        result = func()        end_time = time.time()        print(func.__name__, end_time-start_time)        return result    return wrapper@decoratordef sum_list():    num_sum = 0    lst = list(range(100000))    for i in lst:        num_sum += i    return num_sumresult = sum_list()print(result)print(sum_list.__name__)# 输出sum_list 0.0069987773895263674999950000sum_list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-2-被装饰函数带参数的装饰器"><a href="#4-1-2-被装饰函数带参数的装饰器" class="headerlink" title="4.1.2 被装饰函数带参数的装饰器"></a>4.1.2 被装饰函数带参数的装饰器</h4><p>上一个示例中，原函数没有传入参数，但在更多时候，函数会传入参数。我们应该也明白，装饰器可能会去装饰多个函数，而每个函数传入的参数个数也可能不同，这就要求我们构建的装饰器要有足够的灵活性，可以接受任意个任意类型的参数。通常情况下，我们会把<code>*args</code>和<code>**kwargs</code>，作为装饰器内部函数 wrapper() 的参数。<code>*args</code>和<code>**kwargs</code>，表示接受任意数量和类型的参数。</p><p>这里，我们对前面示例中的装饰器进行修改：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import timefrom functools import wrapsdef decorator(func):    '''    Decorator that reports the execution time of a function.    '''    @wraps(func)   # 保留原函数元信息    def wrapper(*args, **kwargs):         start_time = time.time()        result = func(*args, **kwargs)        end_time = time.time()        print(func.__name__, end_time-start_time)    return wrapper@decoratordef f1(func_name):    print('This is a function named ' + func_name)@decoratordef f2(func_name1, func_name2):    print('This is a function named ' + func_name1)    print('This is a function named ' + func_name2)@decoratordef f3(func_name1, func_name2, **kw):    print('This is a function named ' + func_name1)    print('This is a function named ' + func_name2)    print(kw)f1('test func')f2('test func1', 'test func2')f3('test func1', 'test func2', a = 1, b =2, c = '123')# 输出This is a function named test funcf1 0.0This is a function named test func1This is a function named test func2f2 0.0011019706726074219This is a function named test func1This is a function named test func2{'a': 1, 'b': 2, 'c': '123'}f3 0.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-3-带参数的装饰器"><a href="#4-1-3-带参数的装饰器" class="headerlink" title="4.1.3 带参数的装饰器"></a>4.1.3 带参数的装饰器</h4><p>装饰器除了上面介绍的原函数可以接受任意类型和数量的参数，装饰器还可以接受参数，一般这种类型的装饰器至少有3层的函数嵌套。内部装饰器可以使用最外层函数传入的参数。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from functools import wrapsdef repeat(num):  # 最外层函数传入参数控制装饰器的行为    def decorator(func):        @wraps(func)        def wrapper(*args, **kwargs):            for i in range(num):                print("This is the %dth greet"%(i+1))                func(*args, **kwargs)        return wrapper    return decorator@repeat(4)def greet(message):    print(message)greet('hello world')# 输出This is the 1th greethello worldThis is the 2th greethello worldThis is the 3th greethello worldThis is the 4th greethello world# 上述装饰器操作等价于如下函数调用操作decorator = repeat(4)wrapper = decorator(greet)wrapper("hello world")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-4-类装饰器"><a href="#4-1-4-类装饰器" class="headerlink" title="4.1.4 类装饰器"></a>4.1.4 类装饰器</h4><p>除了函数可以构造装饰器，类也可以作为装饰器，主要依赖于类中的<code>__call__()</code>方法。</p><ul><li>不带参数的类装饰器</li></ul><p>通过构造函数传入函数，然后通过<code>__call__()</code>方法重载，返回一个函数。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Count:    def __init__(self, func):        self.func = func        self.num_calls = 0    def __call__(self, *args, **kwargs):        self.num_calls += 1        print('num of calls is: {}'.format(self.num_calls))        return self.func(*args, **kwargs)@Countdef greet(message):    print(message)for i in range(3):    greet("hello world!")# 输出num of calls is: 1hello world!num of calls is: 2hello world!num of calls is: 3hello world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>带参数的类装饰器</li></ul><p>在构造函数中传入的是参数，而不是一个函数。<code>__call__()</code>方法中传入被装饰函数，并返回一个函数。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class Greet:    def __init__(self, num):        self.num = num    def __call__(self, func):        def wrapper(*args, **kwargs):            for i in range(self.num):                print("This is the %dth greet"%(i+1))                func(*args, **kwargs)        return wrapper@Greet(3)def greet(message):    print(message)greet("hello world!")# 输出This is the 1th greethello world!This is the 2th greethello world!This is the 3th greethello world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-5-装饰器的嵌套"><a href="#4-1-5-装饰器的嵌套" class="headerlink" title="4.1.5 装饰器的嵌套"></a>4.1.5 装饰器的嵌套</h4><p>上面介绍的都是一个装饰器，实际应用中，可能会出现需要使用多个装饰器的情况，比如：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">@decorator1@decorator2@decorator3def func():    ...# 执行顺序从内到外，等价于decorator1(decorator2(decorator3(func)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面，以一个示例来分析嵌套装饰器的执行过程。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from functools import wrapsdef decorator1(func):    print('execute decorator1_1')    @wraps(func)    def wrapper(*args, **kwargs):        print('execute decorator1_2')        func(*args, **kwargs)        print('execute decorator1_3')    return wrapperdef decorator2(func):    print('execute decorator2_1')    @wraps(func)    def wrapper(*args, **kwargs):        print('execute decorator2_2')        func(*args, **kwargs)        print('execute decorator2_3')    return wrapper@decorator1@decorator2def greet(message):    # 等价于 decorator1(decorator2(greet))    print(message)greet('hello world')# 输出execute decorator2_1execute decorator1_1execute decorator1_2execute decorator2_2hello worldexecute decorator2_3execute decorator1_3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，以下过程是等价的：</p><pre><code>@decorator1@decorator2def greet(message):       print(message)greet('hello world')等价于result = decorator1(decorator2(greet))result('hello world')</code></pre><ul><li>首先执行<code>wrapper2 = decorator2(greet)</code>：执行外层<code>print('execute decorator2_1')</code>，并<code>return wrapper</code>，即wrapper2。</li><li>接着执行<code>wrapper1=decorator1(wrapper2 )</code>：执行外层<code>print('execute decorator1_1')</code>，并return wrapper，即wrapper1。</li><li>调用wrapper1(‘hello world’)时：会先跳转到decorator1中wrapper内执行print(‘execute decorator1_2’)，执行func(<em>args, *</em>kwargs)时会跳转到decorator2中调用wrapper，然后依次执行print(‘execute decorator2_2’)，greet(‘hello world’)和print(‘execute decorator2_3’)，执行结束后再跳转到decorator1中wrapper内执行print(‘execute decorator1_3’)。</li><li>至此，整个执行过程结束。</li></ul><h3 id="4-2-装饰器应用"><a href="#4-2-装饰器应用" class="headerlink" title="4.2 装饰器应用"></a>4.2 装饰器应用</h3><ul><li>身份认证</li></ul><p>装饰器可以用于检查是否被授权执行某种操作。比如访问一些博客时，在未登录博客网站的情况下也可以浏览文档，但是对于评论等进一步操作可能只有登录后才能有权限。这种情况就可以通过装饰器来实现身份认证的功能。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from functools import wrapsdef authenticate(func):    @wraps(func)    def wrapper(*args, **kwargs):        request = args[0]        if check_user_logged_in(request): # 如果用户处于登录状态            return func(*args, **kwargs) # 执行函数post_comment()         else:            raise Exception('Authentication failed')    return wrapper@authenticatedef post_comment(request, ...)    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>日志记录</li></ul><p>日志记录是装饰器应用的另一个亮点。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from functools import wrapsdef logit(logfile='out.log'):    def logging_decorator(func):        @wraps(func)        def wrapper(*args, **kwargs):            log_string = func.__name__ + " was called."            print(log_string)            # 打开logfile，并将日志写入到文件            with open(logfile, 'w') as opened_file:                opened_file.write(log_string + '\n')            return func(*args, **kwargs)        return wrapper    return logging_decorator@logit(logfile="greet.log")def greet(message):    print(message)greet("hello world!") # 输出greet was called.    # 生成了一个名为greet.log的文件，内容为greet was called.hello world!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输入合理性检查</li></ul><p>在工作中，很多情况下都会出现输入不合理的现象，往往会用装饰器对其输入进行合理性检查。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from functools import wrapsdef validation_check(func):    @wraps(func)    def wrapper(*args, **kwargs):         ... # 检查输入是否合法@validation_checkdef func(param1, param2, ...):<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>缓存</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（八）：函数</title>
      <link href="/posts/7be03e0a.html"/>
      <url>/posts/7be03e0a.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>函数是实现某一功能的代码段，一般具有<strong>功能性、隐藏细节、避免编写重复性代码</strong>等特点。在Python中，函数是一等对象，满足下述条件：</p><ul><li>在运行时创建 </li><li>能赋值给变量或数据结构中的元素 </li><li>能作为参数传给函数 </li><li>能作为函数的返回结果</li></ul><p>在Python中，整数、字符串和字典都是一等对象。把函数视作一等对象简称为“一等函数”。</p><p>定义一个函数：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def func_name(param_list):    """    函数说明    """    func_body    return value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li>函数用关键字def定义。</li><li>func_name为函数名。</li><li>param_list为参数列表，可以省略。</li><li>文档字符串<code>""" """</code>中为函数说明，可选。</li><li>func_body为函数主体部分，执行相应的语句。</li><li>return返回函数值，如不指定则返回None。函数可以返回多个结果的元组，调用函数后尽量用有意义的名称来接收函数的返回结果，避免直接元组索引来接收元组解包结果。</li></ul><p>def 是可执行语句，这意味着函数在被调用前，都是不存在的。当程序调用函数时，def 语句才会创建一个新的函数对象，并赋予其名字。需要注意，主程序调用函数时，必须保证这个函数此前已经定义过，不然就会报错。但是，如果我们在函数内部调用其他函数，函数间哪个声明在前、哪个在后就无所谓，因为 def 是可执行语句，函数在调用之前都不存在，我们只需保证调用时，所需的函数都已经声明定义。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">demo()  # 在定义前调用报错：NameError: name 'demo' is not defineddef demo():     print("This is a demo")  # 函数内部调用其他函数def my_func(message):    my_sub_func(message) # 调用my_sub_func()在其声明之前不影响程序执行def my_sub_func(message):    print(message)my_func('hello world')# 输出hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-参数"><a href="#1-2-参数" class="headerlink" title="1.2 参数"></a>1.2 参数</h2><p>函数的参数可以接受任何数据类型（数字、字符串、列表、字典等）。在Python中，不用考虑输入的参数数据类型，而是将其交给具体的代码去判断。在实际使用中，我们可以在开头加上数据的类型检查。</p><h3 id="1-2-1-参数传递"><a href="#1-2-1-参数传递" class="headerlink" title="1.2.1 参数传递"></a>1.2.1 参数传递</h3><p>在 python 中，类型属于对象，变量是没有类型的：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">lst = [1, 2, 3, 4, 5] # [1, 2, 3, 4, 5]是列表类型，而变量lst是没有类型的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数的参数主要有两类：不可变类型（如数字、字符串、元组等），可变类型（列表、字典等）。</p><ul><li><p>不可变类型变量作为参数传入函数：类似于C++中的值传递，在函数内部修改这些参数值，不影响外部的变量值。</p></li><li><p>可变类型变量作为参数传入函数：类似于C++中的引用传递，在函数内部修改参数值，也会影响外部的变量值。</p></li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 传入不可变类型def print_message(message):     message = 'hello world.' # 不可变类型不可修改，相当于重新创建了字符串    print(message)message = 'I love Python.'print_message(message)print(message)# 输出hello world.I love Python.  # 传入可变类型def print_message(message):     message.append(4)    print(message)message = [1, 2, 3]print_message(message)print(message)# 输出[1, 2, 3, 4][1, 2, 3, 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-2-参数类型详解"><a href="#1-2-2-参数类型详解" class="headerlink" title="1.2.2 参数类型详解"></a>1.2.2 参数类型详解</h3><p>在函数中，需要先了解下什么是形参和实参。形参是<strong>函数定义</strong>时传入的参数。而实参是<strong>函数调用</strong>时传入的参数值。在Python中，函数的参数形式主要可分为以下几类：位置参数、关键字参数、默认参数、可变参数、可变关键字参数。我们可以借助Python中的<code>inspect</code>模块来查看函数中参数的类型。</p><h4 id="1-2-2-1-位置参数（必须参数）"><a href="#1-2-2-1-位置参数（必须参数）" class="headerlink" title="1.2.2.1 位置参数（必须参数）"></a>1.2.2.1 位置参数（必须参数）</h4><p>调用函数时，根据函数定义时的形参位置顺序传入参数，且实参与形参的个数相等。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def func(x, y):    result = x + y    return result# 查看参数的类型from inspect import signaturefor name, val in signature(func).parameters.items():    print(name, val.kind)# 输出x POSITIONAL_OR_KEYWORD   # x, y 为位置或关键字参数   y POSITIONAL_OR_KEYWORD# 调用函数# 传入整数，x= 1, y =2func(1, 2)  # 输出：3# 传入2个列表func([1, 2, 3], [4, 5, 6]) # 输出：[1, 2, 3, 4, 5, 6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-2-关键字参数"><a href="#1-2-2-2-关键字参数" class="headerlink" title="1.2.2.2 关键字参数"></a>1.2.2.2 关键字参数</h4><p>函数调用时，不需考虑参数的顺序，直接指定参数值。有时，在函数中不能直接看出是位置参数还是关键字参数，主要取决于调用函数时的传参形式。如果在调用函数传入的参数是键值对（键=值），则为关键字参数。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def func(x, y):    result = x + y    return resultres = func(y=2, x=1)   # 传入参数的顺序可以和定义时不一致print(res) # 输出 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-3-默认参数"><a href="#1-2-2-3-默认参数" class="headerlink" title="1.2.2.3 默认参数"></a>1.2.2.3 默认参数</h4><p>定义函数时，如果形参直接赋值，则为默认参数。对于有默认值的形参，调用函数时，如果为该参数传值，则使用传入的值，否则使用默认值。设置默认参数时，非默认参数要放在前面，将其他默认参数放在后面。此外，默认参数通常应该定义成不可变类型。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 只有一个默认参数def func(num=0):    print(f'num:{num}')# 有两种调用方式func()  # 按照默认值调用，可省略参数。func(1) # 修改默认值# 参数列表有多个参数def student(name, age, school='苏州大学'):    print(f"{name}今年{age}岁了，在{school}读书。")# 调用stu1 = student('小王', 20)student('小李', 21, '南京大学')print(stu1)   # 输出小王今年20岁了，在苏州大学读书。  小李今年21岁了，在南京大学读书。None  # 函数如果不指定返回值，默认返回None。stu1和stu2接收返回值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-4-可变参数"><a href="#1-2-2-4-可变参数" class="headerlink" title="1.2.2.4 可变参数"></a>1.2.2.4 可变参数</h4><p>可变参数是数量不定的参数，允许你传入0个或任意个参数，用<code>*args</code>来表示。函数调用时，<code>*args</code>会以元组的形式传入。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def add(*nums):    num_sum = 0    for i in nums:        num_sum += 1    return num_sum # 调用lst = [1, 2, 3, 4, 5]seq = range(10)res1 = add(*lst)   # 15res2 = add(*seq)  # 45<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-5-可变关键字参数"><a href="#1-2-2-5-可变关键字参数" class="headerlink" title="1.2.2.5 可变关键字参数"></a>1.2.2.5 可变关键字参数</h4><p>可变关键字参数是由一组键值对组成的参数集合，用<code>**kwargs</code>来表示。函数调用时，<code>**kwargs</code>会以字典的形式传入。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def func(**params):    for key, value in params.items():        print(f'{key}:{value}')# 调用data = {'A':1, 'B':2, 'C':3}  func(**data) # 或者func(A=1,B=2,C=3)# 输出A:1B:2C:3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-3-参数使用规则"><a href="#1-2-3-参数使用规则" class="headerlink" title="1.2.3 参数使用规则"></a>1.2.3 参数使用规则</h3><p>Python中函数有多种参数形式可供灵活选择，但在使用时也应遵守一定的规则约束，否则函数调用时可能会出现各种各样的调用异常。</p><ul><li>不带默认值的位置参数都需要传入参数值</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">def func(param1, param2):    result = param1 * param2    return result# 调用func(1)  # TypeError: func() missing 1 required positional argument: 'param2'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>关键字参数必须在位置参数的右边</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">def func(param1, param2):    result = param1 * param2    return result# 调用func(param1=1,2)  #SyntaxError: positional argument follows keyword argument<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>同一个形参不能重复传值</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">def func(a,*b):    pass# 调用func(a=1,a=2,3,4)  # SyntaxError: keyword argument repeated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>默认参数放在其他参数后面</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">def func(a,*b,c=1):    print(f'a:{a},b:{b},c:{c}')# 调用func(1,*[2,3]) # a:1,b:(2, 3),c:1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可变位置参数不能传入关键字参数</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">def func(*args):    print(args)# 调用func(a=1) # TypeError: func() got an unexpected keyword argument 'a'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可变关键字参数不能传入位置参数</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">def func(**kwargs):    print(kwargs)# 调用func(1,2)  # TypeError: func() takes 0 positional arguments but 2 were given<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-作用域"><a href="#1-3-作用域" class="headerlink" title="1.3 作用域"></a>1.3 作用域</h2><p>在Python中，函数的变量与其他语言类似，是有作用域的。在函数外部定义的变量为全局变量，在函数内部定义的变量为局部变量。</p><h3 id="1-3-1-局部变量"><a href="#1-3-1-局部变量" class="headerlink" title="1.3.1 局部变量"></a>1.3.1 局部变量</h3><p>在函数内部定义的变量默认为局部变量，除非有特殊的声明，如global声明的为全局变量。函数内的局部变量，外部不可以访问。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def testlocal():    x = 10print(x)  # NameError: name 'x' is not defined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-3-2-全局变量"><a href="#1-3-2-全局变量" class="headerlink" title="1.3.2 全局变量"></a>1.3.2 全局变量</h3><p>全局变量则是定义在整个文件层次上的，可以在文件内的任何地方被访问。当然对于全局变量，在函数内部也是可以的，但是如果要在函数内部修改全局变量，需要借助关键字global来声明。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">a = 2  # 全局变量def demo():    a = 4demo()print(a)  # 2# 修改函数内变量为全局变量a = 2def demo():    global a    a = 4demo()print(a)  # 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-3-非局部变量"><a href="#1-3-3-非局部变量" class="headerlink" title="1.3.3 非局部变量"></a>1.3.3 非局部变量</h3><p>对于嵌套函数来说，内部函数可以访问外部函数定义的变量，但是无法修改，若要修改，必须借助nonlocal关键字来声明。nonlocal是Python3引入的，nonlocal声明的变量必须是外层定义过的局部变量，否则会报错。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">a = 1  # 全局变量def outer():    a = 2    def inner():        nonlocal a         print(a)        a = 3    inner()    print(a)# 调用outer()# 输出    2    3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（七）：流程控制与关键字</title>
      <link href="/posts/4068f7eb.html"/>
      <url>/posts/4068f7eb.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-流程控制"><a href="#1-流程控制" class="headerlink" title="1.流程控制"></a>1.流程控制</h2><h3 id="1-1-条件语句"><a href="#1-1-条件语句" class="headerlink" title="1.1 条件语句"></a>1.1 条件语句</h3><ul><li>if单独使用</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""if condition:    statement"""lst = []if not lst:    print("列表为空列表！")Out:    列表为空列表！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>if-else结构</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""if condition:    statement_1else:    statement_2"""num = int(input("输入一个整数: "))if num % 2 == 0:    print("{}是偶数.".format(num))else:    print("{}是奇数.".format(num))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>if-elif-else结构</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""if condition_1:    statement_1elif condition_2:    statement_2...elif condition_i    statement_ielse:    statement_n"""height = float(input("请输入你的身高："))  # 单位/ mweight = float(input("请输入你的体重："))  # 单位/ kgBMI = weight / height**2if BMI < 18.5:    print("过轻")elif BMI >= 18.5 and BMI < 25:    print("正常")elif BMI >= 25 and BMI < 28:    print("过重")elif BMI >= 28 and BMI < 32:    print("肥胖")else:    print("严重肥胖")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>三元操作符</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""expression1 if condition else expression2"""# y = |x|x = -1y = x if x > 0 else -x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在进行条件判断时，我们可以省略判断条件来简化代码，省略判断条件的常见用法：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>结果</th></tr></thead><tbody><tr><td>String</td><td>空字符串解析为False，其余为True</td></tr><tr><td>Int</td><td>0解析为False，其余为True</td></tr><tr><td>Bool</td><td>True为True，False为False</td></tr><tr><td>list、tuple、dict、set</td><td>Iterable为空解析为False，其余为True</td></tr><tr><td>Object</td><td>None为False，其余为True</td></tr></tbody></table></div><pre class="line-numbers language-lang-python"><code class="language-lang-python">lst = [1, 2, 3, 4, 5]lst_new = []if lst:    lst_new = [item**2 for item in lst]print(lst_new)  # [1, 4, 9, 16, 25]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-循环语句"><a href="#1-2-循环语句" class="headerlink" title="1.2 循环语句"></a>1.2 循环语句</h3><p>Python中循环语句有for循环和while循环两种，各有侧重与其适用场景。for循环主要用于遍历可迭代对象，并进行相应的操作，而while循环需要在满足某个条件前，不停地重复某些操作。</p><h4 id="1-2-1-for循环"><a href="#1-2-1-for循环" class="headerlink" title="1.2.1 for循环"></a>1.2.1 for循环</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""for item in iterable:    statement"""# 取出所有偶数lst = list(range(10))lst_even = []for item in lst:    if item % 2 == 0:        lst_even.append(item)print(lst_even)  # [0, 2, 4, 6, 8]# 遍历字典的项d = {'name':'Tom', 'age':'18', 'gender':'male'}for k, v in d.items():    print('key: {}, value: {}'.format(k, v))Out:    key: name, value: Tom    key: age, value: 18    key: gender, value: male<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-while循环"><a href="#1-2-2-while循环" class="headerlink" title="1.2.2 while循环"></a>1.2.2 while循环</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""while condition:    statement"""sum_total = 0num = 1 while num <= 100:    sum_total += num    num += 1print("1~100的和为{}".format(sum_total))  # 1~100的和为5050<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-3-for与if配合用于解析式"><a href="#1-2-3-for与if配合用于解析式" class="headerlink" title="1.2.3 for与if配合用于解析式"></a>1.2.3 for与if配合用于解析式</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""结构一：[expression_1 if condition else expression_2 for item in iterable]结构二：[expression for item in iterable if condition]"""lst = list(range(10))res = [item**2 if item % 2 == 0 else item*2 for item in lst]print(res)  # [0, 2, 4, 6, 16, 10, 36, 14, 64, 18]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-4-for循环和range-结合使用"><a href="#1-2-4-for循环和range-结合使用" class="headerlink" title="1.2.4 for循环和range()结合使用"></a>1.2.4 for循环和range()结合使用</h4><p>在实际工作中，我们可能需要根据序列的索引做一些条件判断。我们通常利用<code>range()</code> 这个函数获取索引，再去遍历访问序列中的元素。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">l = list(range(20))l_new = []for index in range(len(l)):    if index % 5 == 0:        l_new.append(l[index])print(l_new) # [0, 5, 10, 15]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-5-for循环和enumerate-结合使用"><a href="#1-2-5-for循环和enumerate-结合使用" class="headerlink" title="1.2.5 for循环和enumerate()结合使用"></a>1.2.5 for循环和enumerate()结合使用</h4><p>当我们在for循环遍历同时需要索引和元素时，Python内置函数enumerate()是一种很简洁的方式。结合该函数来遍历序列，不仅返回每个元素，并且还返回其对应的索引。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">l = list(range(20))l_new = []for index, value in enumerate(l):    if index % 5 == 0:        l_new.append(value)print(l_new)  # [0, 5, 10, 15]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-控制语句"><a href="#1-3-控制语句" class="headerlink" title="1.3 控制语句"></a>1.3 控制语句</h3><p>在循环语句中，我们还常常搭配 <code>continue</code> 和 <code>break</code> 一起使用，使程序更加简洁、易读。</p><ul><li>continue语句：让程序跳过当前循环剩下的语句，继续执行下一轮的循环。</li><li>break语句：停止执行，退出循环。对于嵌套循环，只会中止本层循环。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># continue，取出列表中的奇数lst = [1, 2, 3, 4, 5]lst_odd = []for item in lst:    if item % 2 == 0:        continue    lst_odd.append(item)print(lst_odd)  # [1, 3, 5]# break，遇到空格退出循环s = 'hello world!'s_new = ''for letter in s:    if letter == ' ':        break    s_new += letterprint(s_new)  # hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/article_img/流程控制.png" alt></p><h2 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2.关键字"></a>2.关键字</h2><h3 id="2-1-关键字概览"><a href="#2-1-关键字概览" class="headerlink" title="2.1 关键字概览"></a>2.1 关键字概览</h3><p>在Python3.7中，共有35个关键字。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import keywordprint(keyword.kwlist)  # 输出关键字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/article_img/关键字.png"></p><p>这里先重点介绍几个关键字的具体用法，后面也会陆续补充其他内容。</p><h3 id="2-2-global与nonlocal"><a href="#2-2-global与nonlocal" class="headerlink" title="2.2 global与nonlocal"></a>2.2 global与nonlocal</h3><p>在Python中，只有变量在模块（module）、类（class）、函数（def, lambda）中定义时，才会产生作用域。其它的代码块（如 if-elif-else、try-except、for/while等）是不会引入新的作用域的，即这些语句内定义的变量，外部也可以访问。Python 的作用域一共有4种，分别是：</p><ul><li>内部作用域（Local, L）</li><li>嵌套作用域（Enclosing, E）</li><li>全局作用域（Global, G）</li><li>内置作用域（Built-in）</li></ul><p><strong>python引用变量的顺序：</strong> 当前作用域局部变量-&gt;外层作用域变量-&gt;当前模块中的全局变量-&gt;python内置变量。</p><ul><li>局部变量(local)</li></ul><p>在函数内部定义的变量默认为局部变量，除非有特殊的声明，如global声明的为全局变量。函数内的局部变量，外部不可以访问。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">def testlocal():    x = 10print(x)  # NameError: name 'x' is not defined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>全局变量（global）</li></ul><p>global关键字修饰的变量为全局变量，可以用于任何地方。在函数内部，如果想对全局变量做改变，需要使用global进行变量声明。如果不修改全局变量，可不使用global关键字。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">a = 2  # 全局变量def demo():    a = 4demo()print(a)  # 2# 修改函数内变量为全局变量a = 2def demo():    global a    a = 4demo()print(a)  # 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>非局部变量（nonlocal）</li></ul><p>nonlocal是python3引入的，只能用于嵌套函数中，nonlocal声明的变量必须是外层定义过的局部变量，否则会报错。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">a = 1  # 全局变量def outer():    a = 2    def inner():        nonlocal a  # 不声明会报错：UnboundLocalError: local variable 'a' referenced before assignment        print(a)        a = 3    inner()    print(a)# 调用outer()Out:    2    3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-with…as"><a href="#2-3-with…as" class="headerlink" title="2.3 with…as"></a>2.3 with…as</h3><p>with…as是try…finally的一种简化操作，是<strong>上下文管理器</strong>的一种典型应用。上下文管理器，能够帮助你在执行操作完成后自动释放资源。上下文管理器，通常应用在文件的打开关闭和数据库的连接关闭等场景中，可以确保用过的资源得到迅速释放，有效提高了程序的安全性。一个很好的例子就是是文件处理，首先需要获取一个文件句柄，从文件中读取数据，然后关闭文件句柄。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""打开test.txt文件，写入内容（I love Python.），然后这个文件就会自动关闭，相应的资源也可以得到释放，防止资源泄露。"""with open('E:/test/test.txt', 'w') as f:    f.write('I love Python.')# 上述操作也可以用try-finally来实现f = open('E:/test/test.txt', 'w')try:    f.write('I love Python.')finally:    f.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比较with-as和try-finally可以看到with-as更简洁，也避免了资源泄露，一般也推荐使用这种方式。</p><p>接下来，具体看看上下文管理器的内部原理。这里，定义一个上下文管理类 FileManager，模拟 Python 的打开、关闭文件操作，并模拟出现异常抛出。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">class FileManager:    def __init__(self, name, mode):        print('calling __init__ method')        self.name = name        self.mode = mode         self.file = None    def __enter__(self):        print('calling __enter__ method')        self.file = open(self.name, self.mode)        return self.file    def __exit__(self, exc_type, exc_val, exc_tb):        print('calling __exit__ method')        if self.file:            if exc_type:                print(f'exc_type: {exc_type}')                            print(f'exc_value: {exc_val}')                            print(f'exc_traceback: {exc_tb}')            self.file.close()with FileManager('test.txt', 'w') as f:    print('ready to write to file')    f.wrote('hello world')  # write错写为wrote来验证异常处理## 输出calling __init__ methodcalling __enter__ methodready to write to filecalling __exit__ methodexc_type: <class 'AttributeError'>exc_value: '_io.TextIOWrapper' object has no attribute 'wrote'exc_traceback: <traceback object at 0x000002A088A6AC08><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述脚本用类来创建了上下文管理器，并用 with 语句执行这个上下文管理器。从输出结果可以看到，首先初始化方法<code>__init__</code>被调用，初始化对象FileManager，然后调用<code>__enter__</code>方法，返回一个文件句柄赋值给f，接着执行<code>print('ready to write to file')</code>，并向文件中写入内容。由于f.wrote方法写错产生异常，<code>__exit__</code>方法被调用。</p><p><strong>with-as使用的基本思想是：with后的对象必须包含<code>__enter__()</code>和<code>__exit__()</code>方法，紧跟with后面的对象被执行，对象的<code>__enter__()</code>方法被调用，并将返回值将被赋值给as后面的变量。如果执行过程中有异常抛出或执行结束，会调用对象的<code>__exit__()</code>方法。</strong>with真正强大之处是它可以处理异常，</p><p>方法<code>__exit__()</code>中有3个参数：exc_type, exc_val, exc_tb，分别表示 exception_type、exception_value 和 traceback。当执行含有上下文管理器的 with 语句时，如果有异常抛出，异常的信息就会包含在这三个变量中，传给<code>__exit__()</code>方法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（六）：变量与运算符</title>
      <link href="/posts/ff967792.html"/>
      <url>/posts/ff967792.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><h3 id="1-1-变量的命名规则"><a href="#1-1-变量的命名规则" class="headerlink" title="1.1 变量的命名规则"></a>1.1 变量的命名规则</h3><ul><li>可以由字母、数字、下划线组成</li><li>首字母不能为数字</li><li>系统保留关键字不能作为变量名</li><li>区分大小写</li><li>变量没类型限制</li><li>变量名要见名知义</li></ul><h3 id="1-2-变量赋值"><a href="#1-2-变量赋值" class="headerlink" title="1.2 变量赋值"></a>1.2 变量赋值</h3><ul><li>序列解包赋值给多个变量</li></ul><p>任意序列（如字符串、元组、列表等）或可迭代对象（迭代器、生成器等）支持通过解包方式赋值给一组变量，前提是左侧变量数量与右侧序列元素个数一致，否则会产生异常。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 元组解包x, y, z = (1, 2, 3)  # x = 1, y =2, z =3# 只关注部分变量赋值，其他用'_'占位x, _, z = (1, 2, 3)  # x = 1, z = 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>星号<code>（*）</code>表达式处理变量与元素个数不一致</li></ul><p>星号（*）表达式用来接收不确定个数或任意个数元素的可迭代对象。星号表达式创建的变量是列表类型。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># *出现在结尾lst = [1, 2, 3, 4, 5]x, *other = lst   # x = 1, other = [2, 3, 4, 5]# *出现在中间x, *other, z = ('a', [1, 2, 3], 'b', 'c')   # x = 'a', other = [[1, 2, 3], 'b'], z = 'c'# *出现在开头*other, y, z = 'hello' # other = ['h', 'e', 'l'], y = 'l', z = 'o'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h2><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/article_img/运算符.png" alt></p><p>运算符优先级（从高到低）：</p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">**</td><td style="text-align:left">幂运算</td></tr><tr><td style="text-align:left">~</td><td style="text-align:left">按位取反</td></tr><tr><td style="text-align:left">+ 、-</td><td style="text-align:left">正、负</td></tr><tr><td style="text-align:left">*、/、%、//</td><td style="text-align:left">乘、除、取模、取整</td></tr><tr><td style="text-align:left">+、-</td><td style="text-align:left">加、减</td></tr><tr><td style="text-align:left">&lt;&lt;、&gt;&gt;</td><td style="text-align:left">左移、右移</td></tr><tr><td style="text-align:left">&amp;</td><td style="text-align:left">按位与</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">按位异或</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left"></td><td>按位或</td></tr><tr><td style="text-align:left">&gt;=、&gt;、&lt;=、&lt;、==、!=</td><td style="text-align:left">比较运算符</td></tr><tr><td style="text-align:left">=、+=、-=、*=、/=、//=、%=</td><td style="text-align:left">赋值运算符</td></tr><tr><td style="text-align:left">is、is not</td><td style="text-align:left">身份运算符</td></tr><tr><td style="text-align:left">in、not in</td><td style="text-align:left">成员运算符</td></tr><tr><td style="text-align:left">not、and、or</td><td style="text-align:left">逻辑运算（从左到右，优先级减小）</td></tr></tbody></table></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（五）：数据类型-字典与集合</title>
      <link href="/posts/72801a55.html"/>
      <url>/posts/72801a55.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-字典"><a href="#1-字典" class="headerlink" title="1. 字典"></a>1. 字典</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>字典是一种<strong>映射对象类型</strong>，由<strong>键值对</strong>构成的一个可变容器。字典中的每个键值对内用冒号 ( : ) 分隔，键值对间用逗号 ( , ) 分隔，所有键值对包括在<code>{}</code>中。字典的键必须是唯一的，只有<strong>可散列的数据类型</strong>才能用作这些映射里的键，而值则不必是唯一的。</p><blockquote><p>可散列数据类型：一个对象是可散列的，那么在它的生命周期中它的hash值是不变的。Python所有内置的不可变的对象都是可散列的（hashable），如数字、字符串等；可变的容器（比如list或dict）不是hashable；对于元组，只有它包含的所有元素都是可散列类型的情况下，它才是可散列的。</p></blockquote><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 判断对象是不是可散列数据类型t = (1, 2, 3)hash(t)   # 有hash值t = (1, 2, [1, 2])hash(t)   # TypeError: unhashable type: 'list'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建字典的方法：</p><ul><li>根据定义创建：使用一对中括号 <code>{}</code>，键值对中间用冒号，每项间使用逗号分隔。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">d = {}  # 空字典d = {'a':1, 'b':2, 'c':3}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>使用dict()构造函数</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 键值对d1 = dict({'name':'Tom', 'age':'18', 'gender':'male'})# 关键字参数d2 = dict('name'='Tom', 'age'='18', 'gender'='male')# 元素为元组或列表的元组、元素为元组或列表的列表d3 = dict([(name', 'Tom'), ('age', '18'), ('gender', 'male')])# zip(seq1, seq2)seq1 = ['name', 'age', 'gender']seq2 = ['Tom', '18', 'male']d4 = dict(zip(seq1, seq2))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>fromkeys() 方法</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""用于创建一个新字典，以序列seq中元素做字典的键，value为字典所有键对应的初始值。语法：dict.fromkeys(seq, value)参数：seq为字典键值列表，value为键序列对应的值，默认为None。返回值：返回一个新的字典。"""seq = ['a', 'b', 'c']value = [1, 2]d1 = dict.fromkeys(seq, value)d2 = {}.fromkeys(seq, value)d3 = {'A':1, 'B':2}.fromkeys(seq, value)print(d1)  # {'a': [1, 2], 'b': [1, 2], 'c': [1, 2]}print(d2)  # {'a': [1, 2], 'b': [1, 2], 'c': [1, 2]}print(d3)  # {'a': [1, 2], 'b': [1, 2], 'c': [1, 2]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>字典推导构建新字典</li></ul><p>字典推导可以从任何以键值对作为元素的可迭代对象中构建出字典。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 利用元组列表生成字典lt = [('a', 1), ('b', 2), ('c', 3)]d = {key: value for key, value in lt}  # {'a': 1, 'b': 2, 'c': 3}# 利用一个字典生成另一个字典d1 = {key.upper(): value for key, value in d.items()}  # {'A': 1, 'B': 2, 'C': 3}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-基本操作"><a href="#1-2-基本操作" class="headerlink" title="1.2 基本操作"></a>1.2 基本操作</h3><h4 id="1-2-1-访问字典"><a href="#1-2-1-访问字典" class="headerlink" title="1.2.1 访问字典"></a>1.2.1 访问字典</h4><ul><li>根据字典的键来访问字典，如果不存在，则会抛出异常。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">d = {'name':'Tom', 'age':'18', 'gender':'male'}d['name']  # Tomd['nationality']  # 报异常  KeyError: 'nationality'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>使用get()函数访问字典，如果键不存在，返回默认值，而不会报错。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""语法：dict.get(key, default=None)参数：key为要查找的键，default为键不存在时返回的默认值。返回：返回指定键的值，若不存在，则返回默认值default，default默认为None。"""d = {'name':'Tom', 'age':'18', 'gender':'male'}d.get('nationality', 'Chinese')  # Chinese<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-修改字典"><a href="#1-2-2-修改字典" class="headerlink" title="1.2.2 修改字典"></a>1.2.2 修改字典</h4><h5 id="1-2-2-1-更新字典元素"><a href="#1-2-2-1-更新字典元素" class="headerlink" title="1.2.2.1 更新字典元素"></a>1.2.2.1 更新字典元素</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 更新指定键对应的值d = {'name':'Tom', 'age':'18', 'gender':'male'}d['name'] = 'Henry'print(d)Out:    {'name': 'Henry', 'age': '18', 'gender': 'male'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-2-2-添加字典元素"><a href="#1-2-2-2-添加字典元素" class="headerlink" title="1.2.2.2 添加字典元素"></a>1.2.2.2 添加字典元素</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">d = {'name':'Tom', 'age':'18', 'gender':'male'}d['nationality'] = 'Chinese'  # 添加元素print(d)Out:    {'name': 'Tom', 'age': '18', 'gender': 'male', 'nationality': 'Chinese'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-2-3-setdefault-添加元素"><a href="#1-2-2-3-setdefault-添加元素" class="headerlink" title="1.2.2.3 setdefault()添加元素"></a>1.2.2.3 setdefault()添加元素</h5><p>与get()方法类似，如果key在字典中，返回对应的值，不修改已存在的键对应值。如果key不在字典中，则插入key及设置的默认值default，并返回 default，default默认值为None。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""语法：dict.setdefault(key, default=None)参数：key为要添加的键，default为key在字典dict中不存在时插入的值，默认为None。返回值：如果key在字典中，则返回对应的值，若不存在则插入键值对，并返回插入的值。"""d = {'name':'Tom', 'age':'18', 'gender':'male'}r = d.setdefault('name', 'Henry')   # r = Tom，字典不变r = d.setdefault('nationality', 'Chinese')  print(r)print(d)Out:    Chinese    {'name': 'Tom', 'age': '18', 'gender': 'male', 'nationality': 'Chinese'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-2-4-update-添加或更新元素"><a href="#1-2-2-4-update-添加或更新元素" class="headerlink" title="1.2.2.4 update()添加或更新元素"></a>1.2.2.4 update()添加或更新元素</h5><p>update()用于更新字典中的键值对，可以修改存在的键对应的值，也可以添加新的键值对到字典中。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""语法：dict.update(data)参数：data为要更新或添加的键值对数据，可以是字典、关键字参数、元组列表等。返回值：无"""# 更新存在键对应的值，传入字典d = {'name': 'Tom', 'age': '18', 'sex': 'Male'}d.update({'name': 'Henry'})print(d)Out: # 打印d的结果    {'name': 'Henry', 'age': '18', 'sex': 'Male'}# 添加键值对，传入关键字参数 d = {'name': 'Tom', 'age': '18', 'sex': 'Male'}d.update(stature='188', nationality='Chinese')print(d)Out:    {'name': 'Tom', 'age': '18', 'sex': 'Male', 'stature': '188', 'nationality': 'Chinese'}# 传入元组列表d = {'name': 'Tom', 'age': '18', 'sex': 'Male'}d.update([('stature', '188'), ('nationality', 'Chinese')])print(d)Out:    {'name': 'Tom', 'age': '18', 'sex': 'Male', 'stature': '188', 'nationality': 'Chinese'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-3-删除字典"><a href="#1-2-3-删除字典" class="headerlink" title="1.2.3 删除字典"></a>1.2.3 删除字典</h4><ul><li>删除单个字典元素</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># del 删除指定键的元素d = {'name': 'Tom', 'age': '18', 'sex': 'Male'}del d['sex']print(d)Out:    {'name': 'Tom', 'age': '18'}# dict.pop(key, default) 删除啊指定键key对应的值，并返回被删除的值。若key不存在，default要给出，否则报错。d = {'name': 'Tom', 'age': '18', 'sex': 'Male'}d.pop('sex')print(d)Out:    {'name': 'Tom', 'age': '18'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>清空字典所有元素</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">d = {'name': 'Tom', 'age': '18', 'sex': 'Male'}d.clear()print(d)Out:    {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除整个字典</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">d = {'name': 'Tom', 'age': '18', 'sex': 'Male'}del d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-2-4-字典视图"><a href="#1-2-4-字典视图" class="headerlink" title="1.2.4 字典视图"></a>1.2.4 字典视图</h4><p>字典自带的三个方法 dict.items()、dict.keys()、dict.values()，它们返回的对象都是原字典的视图，修改原字典对象，视图对象的值也会发生改变。</p><h5 id="1-2-4-1-dict-items"><a href="#1-2-4-1-dict-items" class="headerlink" title="1.2.4.1 dict.items()"></a>1.2.4.1 dict.items()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""语法：dict.items()参数：无返回值：返回可遍历的元组数组，元组由键值对构成。"""d = {'a': 1, 'b': 2, 'c': 3}r = d.items()print(r)print(list(r))Out:    dict_items([('a', 1), ('b', 2), ('c', 3)])    [('a', 1), ('b', 2), ('c', 3)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-4-2-dict-keys"><a href="#1-2-4-2-dict-keys" class="headerlink" title="1.2.4.2 dict.keys()"></a>1.2.4.2 dict.keys()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""语法： dict.keys()参数：无返回值：返回一个由字典键构成的迭代器，使用list()可转换为列表。"""d = {'a': 1, 'b': 2, 'c': 3}print(d.keys())Out:    dict_keys(['a', 'b', 'c'])# 获取所有键集合set(d)set(d.keys())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-4-3-dict-values"><a href="#1-2-4-3-dict-values" class="headerlink" title="1.2.4.3 dict.values()"></a>1.2.4.3 dict.values()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""语法： dict.values()参数：无返回值：返回一个由字典值构成的迭代器，使用list()可转换为列表。"""d = {'a': 1, 'b': 2, 'c': 3}print(d.values())Out:    dict_values([1, 2, 3])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-5-字典遍历"><a href="#1-2-5-字典遍历" class="headerlink" title="1.2.5 字典遍历"></a>1.2.5 字典遍历</h4><p>字典遍历常与 dict.items()、dict.keys()、dict.values()等三个方法配合使用。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># items()d = {'a': 1, 'b': 2, 'c': 3}for key, value in d.items():    print(f'key = {key}, value = {value}')Out:    key = a, value = 1    key = b, value = 2    key = c, value = 3# 字典推导d = {'a': 1, 'b': 2, 'c': 3, 'd': 4}d_new = {k: v for k, v in d.items() if v%2 == 0}print(d_new)Out:    {'b': 2, 'd': 4}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-6-字典排序"><a href="#1-2-6-字典排序" class="headerlink" title="1.2.6 字典排序"></a>1.2.6 字典排序</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 根据字典键排序d = {'b': 2, 'a': 1, 'c': 3}d_new = dict(sorted(d.items(), key=lambda x: x[0], reverse=True))print(d_new)Out:    {'c': 3, 'b': 2, 'a': 1}# 根据字典值排序d = {'b': 2, 'a': 1, 'c': 3}d_new = dict(sorted(d.items(), key=lambda x: x[1]))print(d_new)Out:    {'a': 1, 'b': 2, 'c': 3}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-7-统计元素个数"><a href="#1-2-7-统计元素个数" class="headerlink" title="1.2.7 统计元素个数"></a>1.2.7 统计元素个数</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">d = {'b': 2, 'a': 1, 'c': 3}print(len(d))Out:    3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-进阶知识"><a href="#1-3-进阶知识" class="headerlink" title="1.3 进阶知识"></a>1.3 进阶知识</h3><h4 id="1-3-1-collections模块中字典类型"><a href="#1-3-1-collections模块中字典类型" class="headerlink" title="1.3.1 collections模块中字典类型"></a>1.3.1 collections模块中字典类型</h4><h5 id="1-3-1-1-collections-defaultdict"><a href="#1-3-1-1-collections-defaultdict" class="headerlink" title="1.3.1.1 collections.defaultdict"></a>1.3.1.1 collections.defaultdict</h5><p>通过字典key访问字典元素时，如果key不存在，则会引发‘KeyError‘异常。为了避免这种情况，前面介绍的get()和setdefault()方法是通过指定默认值。除此之外，我们也可以使用 collections模块中的defaultdict类（dict的子类）来处理找不到的键的情况。使用defaultdict()可以用于以下两种场合：</p><ol><li><p>在key不存在时，不报异常，而是返回一个默认值。</p></li><li><p>在key不存在时，也可以赋值，而不报异常。</p></li></ol><p>collections.defaultdict(default_factory,…):  defaultdict是内置的dict类的一个子类，返回一个新的类字典的对象，第一个参数提供了default_factory属性的初始值，默认为None。default_factory可以设置为：</p><ol><li>使用类型名称来作为初始化函数的参数，当所访问的键不存在的时候，根据传入类型实例化一个初始值作为默认值。</li><li>使用不带参数的可调用函数作为初始化函数参数，以该函数返回值作为默认值。</li></ol><p>下面，通过一个统计列表中单词次数的示例来看如何处理键不存在的情况。</p><ul><li>KeyError异常</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""在Python中如果访问字典里不存在的键，会出现KeyError异常。"""# 统计列表中单词出现次数，并记录在字典count中fruits = ['apple', 'orange', 'cherry', 'apple', 'apple', 'cherry', 'blueberry']fruit_count = {}for fruit in fruits:    fruit_count[fruit] += 1  # KeyError: 'apple'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用判断语句检查</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">fruits = ['apple', 'orange', 'cherry', 'apple', 'apple', 'cherry', 'blueberry']fruit_count = {}for fruit in fruits:    if fruit not in fruit_count:        fruit_count[fruit] = 1    else:        fruit_count[fruit] += 1print(fruit_count)Out:    {'apple': 3, 'orange': 1, 'cherry': 2, 'blueberry': 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用dict.setdefault()方法</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">fruits = ['apple', 'orange', 'cherry', 'apple', 'apple', 'cherry', 'blueberry']fruit_count = {}for fruit in fruits:    fruit_count.setdefault(fruit, 0)    fruit_count[fruit] += 1print(fruit_count)Out:    {'apple': 3, 'orange': 1, 'cherry': 2, 'blueberry': 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用collections.defaultdict类</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 指定字典的值类型为int，用于计数from collections import defaultdictfruits = ['apple', 'orange', 'cherry', 'apple', 'apple', 'cherry', 'blueberry']fruit_count = defaultdict(int)for fruit in fruits:    fruit_count[fruit] += 1print(fruit_count)Out:    defaultdict(<class 'int'>, {'apple': 3, 'orange': 1, 'cherry': 2, 'blueberry': 1})# 指定字典的值类型为listseq = [('A', 1), ('B', 2), ('A', 3), ('B', 4), ('C', 1)]d = defaultdict(list)print(d['D'])  Out:    []for k, v in seq:    d[k].append(v)print(d)Out:    defaultdict(<class 'list'>, {'A': [1, 3], 'B': [2, 4], 'C': [1]})# 使用不带参数的可调用函数from collections import defaultdictdef zero():    return 0d = defaultdict(zero)print(d['A'])print(d)Out:    0    defaultdict(<function zero at 0x00000188F6163DC8>, {'A': 0})# 计数from collections import defaultdictfruits = ['apple', 'orange', 'cherry', 'apple', 'apple', 'cherry', 'blueberry']fruit_count = defaultdict(lambda: 0)   # 使用lambda来定义简单的函数for fruit in fruits:    fruit_count[fruit] += 1print(dict(fruit_count))Out:    {'apple': 3, 'orange': 1, 'cherry': 2, 'blueberry': 1}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-1-2-collections-OrderedDict"><a href="#1-3-1-2-collections-OrderedDict" class="headerlink" title="1.3.1.2 collections.OrderedDict"></a>1.3.1.2 collections.OrderedDict</h5><p>使用dict时，key是无序的。在对dict做迭代时，我们无法确定key的顺序。如果要保持Key的顺序，可以用OrderedDict。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from collections import OrderedDictod = OrderedDict([('A', 1), ('B', 2), ('C', 3)])od['D'] = 4od['E'] = 5od['F'] = 6print(od)Out:   OrderedDict([('A', 1), ('B', 2), ('C', 3), ('D', 4), ('E', 5), ('F', 6)])# 按键排序，创建排序字典d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}od = OrderedDict(sorted(d.items(), key=lambda t: t[0])) print(od)Out:    OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)])# 按值排序，创建排序字典d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}od = OrderedDict(sorted(d.items(), key=lambda t: t[1])) print(od)Out:    OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)])# 按键的字符长度排序，创建排序字典d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}od = OrderedDict(sorted(d.items(), key=lambda t: len(t[0]))) print(od)Out:    OrderedDict([('pear', 1), ('apple', 4), ('banana', 3), ('orange', 2)])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-1-3-collections-ChainMap"><a href="#1-3-1-3-collections-ChainMap" class="headerlink" title="1.3.1.3 collections.ChainMap"></a>1.3.1.3 collections.ChainMap</h5><p>ChainMap 用来成合并多个字典，但和 update 不同，它不会改变原对象，而且效率更高。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from collections import ChainMapa = {'a': 1, 'b': 2}b = {'b': 3, 'c': 4}c = ChainMap(a, b)print(c)Out:    ChainMap({'a': 1, 'b': 2}, {'b': 3, 'c': 4})# ChainMap读取和更新：ChainMap内部存储了一个名为maps的list用以维护mapping关系, 这个list可以直接查看和修改，修改之后相应ChainMap值也就修改了。print(c.maps)Out:    [{'a': 1, 'b': 2}, {'b': 3, 'c': 4}]c.maps[0]['b'] = 5c.maps[1]['b'] = 6print(c)Out:    ChainMap({'a': 1, 'b': 5}, {'b': 6, 'c': 4})# 如果不是修改maps这个list，对ChainMap的修改只会影响第一个map，读取的时候会从第一个map开始读，直到遇到指定的key。print(c['b'])Out:    5# new_child(m=None): 生成一个新的ChainMap, m指定mappings作为第一个mapping，后面跟着原先的mappings。print(c.new_child())print(c.new_child({'d': 10}))Out:    ChainMap({}, {'a': 1, 'b': 5}, {'b': 6, 'c': 4})    ChainMap({'d': 10}, {'a': 1, 'b': 5}, {'b': 6, 'c': 4})# 返回父ChainMap，由除了第一个map之后的其它mappings组成d = c.new_child({'d': 10})print(d.parents)Out:    ChainMap({'a': 1, 'b': 5}, {'b': 6, 'c': 4})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1.3.14 </p><p>Counter是dict的一个子类，用于可哈希对象的计数。它是一个无序键值对的集合，其中以元素为键，值为元素的计数值。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 创建Counter对象c = Counter()  # 创建一个空counter对象c = Counter(['apple', 'orange', 'apple', 'pear', 'orange'])  # 从一个可迭代对象（list、tuple、dict、字符串等）创建c = Counter({'A': 1, 'B': 2}) # 从一个映射对象（字典对象）创建c = Counter(cats=4, dogs=8)   # 根据关键字参数创建# Counter对象有字典接口，当不存在指定键时，返回的计数为0c = Counter({'A': 1, 'B': 2})c['C']Out:    0# 统计列表中单词出现次数cnt = Counter()seq = ['red', 'blue', 'red', 'green', 'blue', 'blue']for color in seq:    cnt[color] += 1print(cnt)Out:    Counter({'blue': 3, 'red': 2, 'green': 1})# 将counter中元素置0或删除元素seq = ['red', 'blue', 'red', 'green', 'blue', 'blue']cnt = Counter(seq)cnt['green'] = 0print(cnt)del cnt['green']print(cnt)Out:    Counter({'blue': 3, 'red': 2, 'green': 0})    Counter({'blue': 3, 'red': 2})# 按照元素出现次数返回一个迭代器，如果元素计数小于1，则忽略。c = Counter(a=4, b=2, c=0, d=-2)print(c.elements())print(sorted(c.elements()))Out:    <itertools.chain object at 0x00000188F677D1C8>    ['a', 'a', 'a', 'a', 'b', 'b']# 使用most_common(n)返回一个list, list中包含Counter对象中出现最多前n个元素。c = Counter('abracadabra')print(c.most_common(3))Out:    [('a', 5), ('b', 2), ('r', 2)]# subtractc1 = Counter(a=2, b=3)c2 = Counter(a=1, b=4)c1.subtract(c2)print(c1)Out:    Counter({'a': 1, 'b': -1})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-2-字典并集"><a href="#1-3-2-字典并集" class="headerlink" title="1.3.2 字典并集"></a>1.3.2 字典并集</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">def merge(d1, d2):    return {**d1, **d2}d1 = {'a':1, 'b':2}d2 = {'c':3, 'd':4}r = merge(d1, d2)print(r)Out:    {'a': 1, 'b': 2, 'c': 3, 'd': 4}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-3-字典差集"><a href="#1-3-3-字典差集" class="headerlink" title="1.3.3 字典差集"></a>1.3.3 字典差集</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">def diff(d1, d2):    return dict([(k, v) for k, v in d1.items() if k not in d2])d1 = {'a':1, 'b':2, 'c':3}d2 = {'c':3, 'd':4}r = diff(d1, d2) # r = {'a': 1, 'b': 2}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-4-获取字典前n个最大值对应的键"><a href="#1-3-4-获取字典前n个最大值对应的键" class="headerlink" title="1.3.4 获取字典前n个最大值对应的键"></a>1.3.4 获取字典前n个最大值对应的键</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">from heapq import nlargestdef topn_dict(d, n):    return nlargest(n, d, key=lambda k: d[k])# 调用函数d = {'a':5, 'b':6, 'c':8, 'd':4}r =  topn_dict(d, 2) # r = ['c', 'b']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-5-一键对多值字典"><a href="#1-3-5-一键对多值字典" class="headerlink" title="1.3.5 一键对多值字典"></a>1.3.5 一键对多值字典</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">lst = [('a', 1), ('b', 2), ('a', 3), ('b', 4), ('c', 5)]d = {}for k, v in lst:    if k not in d:        d[k] = []    d[k].append(v)print(d)Out:    {'a': [1, 3], 'b': [2, 4], 'c': [5]}# 使用 collections模块中的defaultdictfrom collections import defaultdictd = defaultdict(list)for k, v in lst:    d[k].append(v)print(d)Out:    defaultdict(<class 'list'>, {'a': [1, 3], 'b': [2, 4], 'c': [5]})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-6-在字典中根据条件筛选数据"><a href="#1-3-6-在字典中根据条件筛选数据" class="headerlink" title="1.3.6 在字典中根据条件筛选数据"></a>1.3.6 在字典中根据条件筛选数据</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 生成数据from random import randintd = {"student%d" % i : randint(70, 100) for i in range(1,6)}print(d)# 使用字典解析res= {k:v for k, v in d.items() if v >= 90}print(res)# 使用filter()函数res = dict(filter(lambda item: item[1] >= 90, d.items()))print(res)Out:    {'student1': 75, 'student2': 85, 'student3': 91, 'student4': 84, 'student5': 98}    {'student3': 91, 'student5': 98}    {'student3': 91, 'student5': 98}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>集合是一个无序的且不存在重复元素的容器，不支持索引操作。集合内元素必须是可哈希类型（hashable），意味着 list、dict 等不可哈希的对象不能作为集合的元素。集合的创建主要有以下两种方式：</p><ul><li>使用花括号<code>{}</code>创建。</li></ul><pre><code>s = {1, 'a', (1, 2, 3)}</code></pre><ul><li>使用set()函数创建。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""set(iterable): 参数为可迭代对象。"""l = [1, 2, 3, 4]s = set(l)# 结合可以去重l = [1, 2, 1, 3, 2]s = set(l) # {1, 2, 3}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>对于空集合，只能使用<code>set()</code>创建，<code>{}</code>是用来创建空字典。</p></blockquote><ul><li>frozenset()创建不可变集合</li></ul><p>不同于set()创建的可变集合，frozenset()创建的不可变集合元素是不可变的，不可以动态的对集合进行增加或删除操作。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># frozenset创建不可变集合fs = frozenset(range(10)) Out:    frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-基本操作"><a href="#2-2-基本操作" class="headerlink" title="2.2 基本操作"></a>2.2 基本操作</h3><h4 id="2-2-1-添加元素"><a href="#2-2-1-添加元素" class="headerlink" title="2.2.1 添加元素"></a>2.2.1 添加元素</h4><ul><li>add()</li></ul><p>add() 方法用于给集合添加元素，如果添加的元素在集合中已存在，则不执行任何操作。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = {1, 2, 3}s.add(4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>update()</li></ul><p>update() 方法用于修改当前集合，可以添加新的可迭代对象添加到当前集合中。如果添加的元素在集合中已存在，则会忽略。可迭代对象可以是列表、元组、字典、集合等。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = {1, 2, 3}s.update({1, 4, 5})print(s) Out:    {1, 2, 3, 4, 5}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-删除元素或清空集合"><a href="#2-2-2-删除元素或清空集合" class="headerlink" title="2.2.2 删除元素或清空集合"></a>2.2.2 删除元素或清空集合</h4><ul><li>remove()</li></ul><p>移除指定元素，如果移除的元素不存在，则会报错。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = {'a', 'b', 'c'}s.remove('a')  # s = {'b', 'c'}s.remove('d')  # 报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>discard()</li></ul><p>移除指定的集合元素，不同于remove()，当元素不存在时，不会报错。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = {'a', 'b', 'c'}s.discard('d') # s = {'b', 'a', 'c'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>pop()</li></ul><p>随机移除一个元素。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = {'a', 'b', 'c'}s.pop()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2-3-集合运算"><a href="#2-2-3-集合运算" class="headerlink" title="2.2.3 集合运算"></a>2.2.3 集合运算</h4><p>Python中集合自带了一些与数学集合运算类似的操作，如查找集合间的并、交、差集、子集判断。</p><h5 id="2-2-3-1-并集"><a href="#2-2-3-1-并集" class="headerlink" title="2.2.3.1 并集"></a>2.2.3.1 并集</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 使用“|”运算符s1 = {1, 3, 5, 7}s2 = {2, 3, 4, 5}s3 = {5, 6, 7, 8}s = s1 | s2 | s3   # s = {1, 2, 3, 4, 5, 6, 7, 8}# 使用union()方法s = s1.union(s2, s3) # s = {1, 2, 3, 4, 5, 6, 7, 8}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-3-2-交集"><a href="#2-2-3-2-交集" class="headerlink" title="2.2.3.2 交集"></a>2.2.3.2 交集</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 使用"&"运算符s1 = {1, 3, 5, 7}s2 = {2, 3, 4, 5}s3 = {5, 6, 7, 8}s = s1 & s2 & s3  # s = {5}# intersection()，返回交集操作后新的集合s = s1.intersection(s2, s3) # s = {5}# intersection_update() ，在原集合上移除不重叠的元素s1.intersection_update(s2, s3) # s1 = {5}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-3-3-差集"><a href="#2-2-3-3-差集" class="headerlink" title="2.2.3.3 差集"></a>2.2.3.3 差集</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 使用"-"运算符s1 = {1, 2, 3, 4, 5}s2 = {2, 3, 6, 7, 8}s = s1 - s2  # s = {1, 4, 5}# difference()，返回两个集合的差集，即返回的集合元素包含在第一个集合中，但不包含在第二个集合中。s1 = {1, 2, 3, 4, 5}s2 = {2, 3, 6, 7, 8}s = s1.difference(s2) #  s = {1, 4, 5}# difference_update() s1 = {1, 2, 3, 4, 5}s2 = {2, 3, 6, 7, 8}s1.difference_update(s2) #  s1 = {1, 4, 5}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-3-4-子集"><a href="#2-2-3-4-子集" class="headerlink" title="2.2.3.4 子集"></a>2.2.3.4 子集</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python"># issubset(): 判断一个集合是否是另一个的子集s1 = {1, 2, 3}s2 = {1, 2, 3, 4, 5}result = s1.issubset(s2) # result = True# issuperset(): 判断一个集合是否是另一个集合的父集s1 = {1, 2, 3}s2 = {1, 2, 3, 4, 5}result = s2.issuperset(s1) # result = True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-4-判断元素是否属于集合"><a href="#2-2-4-判断元素是否属于集合" class="headerlink" title="2.2.4 判断元素是否属于集合"></a>2.2.4 判断元素是否属于集合</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = {1, 2, 3, 4}1 in s # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2-5-集合推导"><a href="#2-2-5-集合推导" class="headerlink" title="2.2.5 集合推导"></a>2.2.5 集合推导</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = {1, 2, -2, 3, -4}s_new = {abs(x) for x in s}  # s_new = {1, 2, 3, 4}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（四）：数据类型-列表与元组</title>
      <link href="/posts/92f2c1f8.html"/>
      <url>/posts/92f2c1f8.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-列表"><a href="#1-列表" class="headerlink" title="1. 列表"></a>1. 列表</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>列表是一个<strong>容器序列类型</strong>，列表中的元素可以是字符串、数字、布尔等各种类型，同时列表中元素有序的，都有各自的位置索引，默认是从0开始，可以进行切片等操作。列表中的元素以逗号<code>","</code>分隔，用<code>[]</code>将元素括起来。列表是一个<strong>可变序列</strong>，可以对列表中的元素进行增删改查。</p><p>创建列表或生成列表有多种方法：</p><ul><li><p>根据列表定义创建：元素以逗号分隔，并用[]括起来，如<code>[1, 'a',  True]</code>，是最简单的一种方法。</p><p>创建空列表：<code>[]</code>。</p></li><li><p>list()创建：根据其他类型数据创建列表，如list(‘hello’)，list(range(10))。</p><p>创建一个空列表：list()。</p></li><li><p>列表生成式：如，[x**2 for x in range(10)]。</p></li></ul><h3 id="1-2-基本操作"><a href="#1-2-基本操作" class="headerlink" title="1.2 基本操作"></a>1.2 基本操作</h3><h4 id="1-2-1-索引与切片操作"><a href="#1-2-1-索引与切片操作" class="headerlink" title="1.2.1 索引与切片操作"></a>1.2.1 索引与切片操作</h4><h5 id="1-2-1-1-根据索引访问列表中的值"><a href="#1-2-1-1-根据索引访问列表中的值" class="headerlink" title="1.2.1.1 根据索引访问列表中的值"></a>1.2.1.1 根据索引访问列表中的值</h5><p>列表的索引从<code>0</code>开始，索引取值的范围为<code>-len(list)</code> 到<code>len(list)-1</code>（list表示列表），超过这个范围访问列表则抛出<u>IndexError</u>。索引<code>-1</code>表示列表的最后一个元素位置，<code>-2</code>为倒数第二个元素位置，以此类推。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">l = [1, 2, 3, 'a', 'b', 'c']r1 = l[2]r2 = l[-1]print(r1, r2)Out:    3 c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-1-2-列表切片取值"><a href="#1-2-1-2-列表切片取值" class="headerlink" title="1.2.1.2 列表切片取值"></a>1.2.1.2 列表切片取值</h5><p>列表seq切片格式为：<code>seq[start:end:step]</code>，左闭右开，<code>start</code>：起始索引，从0开始；<code>end</code>：结束索引，step：步长，默认为1，步长为正值从左往右取值，为负值从右往左取值。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 同时有起止索引l = [1, 2, 3, 4, 5]r1 = l[1:3]r2 = l[1:4:3]  #修改步长为3print("r1={}, r2={}".format(r1,r2))Out:    r1=[2, 3], r2=[2]# 仅有开始索引r1 = l[1:]r2 = l[-2:] # 开始索引为负值print("r1={}, r2={}".format(r1,r2))Out:    r1=[2, 3, 4, 5], r2=[4, 5] # 仅有结束索引r1 = l[:3]r2 = l[:-1] # -1表示最后索引print("r1={}, r2={}".format(r1,r2))Out:    r1=[1, 2, 3], r2=[1, 2, 3, 4]# 无开始结束索引r1 = l[::]  # 全选 l[:]r2 = l[::2] print("r1={}, r2={}".format(r1,r2))Out:    r1=[1, 2, 3, 4, 5], r2=[1, 3, 5]# 逆向索引r1 = l[-1:-4:-1]r2 = l[-4:-1:-1]r3 = l[::-1] # 列表反转print("r1={}, r2={}, r3={}".format(r1,r2,r3))Out:    r1=[5, 4, 3], r2=[], r3=[5, 4, 3, 2, 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-1-3-列表切片赋值"><a href="#1-2-1-3-列表切片赋值" class="headerlink" title="1.2.1.3 列表切片赋值"></a>1.2.1.3 列表切片赋值</h5><p>由于列表是可变序列，可以对列表的元素进行修改或删除操作。对于切片赋值，右侧必须是一个可迭代对象。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 对单个元素进行修改，赋值运算符右侧可以是数字，也可以是可迭代对象l = ['a', 'b', 'c', 'd', 'e']l[0] = 1l[1] = [1, 2]print(l)  Out:    [1, [1, 2], 'c', 'd', 'e']# 切片赋值，在步长为1时，右侧可迭代对象元素个数不必与左侧切片长度相同l = list("abcde")l[1:2] = ['A', 'B', 'C']  print(l)Out:    ['a', 'A', 'B', 'C', 'c', 'd', 'e']# 在步长不为1时，右侧可迭代对象元素个数必须与左侧切片长度相同，否则报错l = list("abcde")l[1:2:2] = ['A', 'B', 'C'] # 报错# 不替换元素，直接在相应位置插入l = list("abcde")l[0:0] = [1, 2]   # 在最开始位置插入l[3:3] = [3, 4]   # 在中间位置插入l[10:10] = [5, 6] # 在最后位置插入，索引要大于最后一个索引print(l)Out:    [1, 2, 'a', 3, 4, 'b', 'c', 'd', 'e', 5, 6]# 删除元素l = list("abcde")l[2:] = []print(l)Out:    ['a', 'b']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-添加元素"><a href="#1-2-2-添加元素" class="headerlink" title="1.2.2 添加元素"></a>1.2.2 添加元素</h4><h5 id="1-2-2-1-append"><a href="#1-2-2-1-append" class="headerlink" title="1.2.2.1 append()"></a>1.2.2.1 append()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""用于在列表末尾添加新的对象。语法：list.append(obj)参数：obj为添加到列表末尾的对象。返回值：无返回值，直接在原列表上添加，不会创建新的列表。"""l = [1, 2, 3]l.append(['a', 'b', 'c'])print(l)Out:    [1, 2, 3, ['a', 'b', 'c']]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-2-2-insert"><a href="#1-2-2-2-insert" class="headerlink" title="1.2.2.2 insert()"></a>1.2.2.2 insert()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""用于将指定对象插入列表的指定位置。语法：list.insert(index, obj)参数：obj为要插入列表中的对象，index为对象obj需要插入的索引位置。返回值：无返回值，直接在列表指定位置插入对象。"""l = [1, 2, 3, 4, 5]l.insert(3, ['a', 'b'])print(l)Out:    [1, 2, 3, ['a', 'b'], 4, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-3-合并列表"><a href="#1-2-3-合并列表" class="headerlink" title="1.2.3 合并列表"></a>1.2.3 合并列表</h4><h5 id="1-2-3-1-extend"><a href="#1-2-3-1-extend" class="headerlink" title="1.2.3.1 extend()"></a>1.2.3.1 extend()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""向列表中追加另一个可迭代对象的元素。语法：list.extend(seq)参数：seq可以为列表、元组、集合、字典等，若为字典,则仅会将键(key)作为元素依次添加至原列表的末尾。"""l = [1, 2, 3]s = ['a', 'b']l.extend(s)print(l)Out:    [1, 2, 3, 'a', 'b']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-3-2-用“-”连接列表"><a href="#1-2-3-2-用“-”连接列表" class="headerlink" title="1.2.3.2 用“+”连接列表"></a>1.2.3.2 用“+”连接列表</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""+运算符可以对两个列表进行连接，不改变原列表，返回一个新的列表。+=运算符，会在原列表上进行添加另一个列表的元素。"""# +l = [1, 2, 3]s = ['a', 'b', 'c']r = l + sprint("l={}, r={}".format(l,r))Out:    l=[1, 2, 3], r=[1, 2, 3, 'a', 'b', 'c']# +=l = [1, 2, 3]print(id(l))   # 获取对象的内存地址s = ['a', 'b', 'c']l += s    # 合并后对象的内存地址print(id(l))print(l)Out:    2355940909512   # 添加列表元素后内存地址不变    2355940909512    [1, 2, 3, 'a', 'b', 'c']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-4-删除元素"><a href="#1-2-4-删除元素" class="headerlink" title="1.2.4 删除元素"></a>1.2.4 删除元素</h4><h5 id="1-2-4-1-remove"><a href="#1-2-4-1-remove" class="headerlink" title="1.2.4.1 remove()"></a>1.2.4.1 remove()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""移除列表中指定对象的第一个匹配项。语法：list.remove(obj)参数：obj为列表要移除的对象返回值：无返回值，直接对原列表进行修改。"""l = [1, 'a', 2, 'a', 3, 'b']r = l.remove('a')print("r={}, l={}".format(r,l))Out:    r=None, l=[1, 2, 'a', 3, 'b']    # r=None表示remove方法无返回值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-4-2-pop"><a href="#1-2-4-2-pop" class="headerlink" title="1.2.4.2 pop()"></a>1.2.4.2 pop()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""用于移除指定位置的元素。语法：list.pop(index=-1)参数：index为可选参数，要移除元素的索引值，默认为-1。返回值：返回从列表中移除的元素对象。"""l = [1, 2, ['a', 'b'], 3]r1 = l.pop(2)r2 = l.pop()print("r1={}, r2={}, l={}".format(r1, r2, l))Out:    r1=['a', 'b'], r2=3, l=[1, 2]# pop与append是python中数据结构的出栈与入栈。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-4-3-del"><a href="#1-2-4-3-del" class="headerlink" title="1.2.4.3 del"></a>1.2.4.3 del</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""根据索引来删除单个元素或指定范围内的元素。"""# 删除单个元素l = [1, 2, 3, 4, 5]del l[-1]print(l)Out:    [1, 2, 3, 4]# 删除指定范围内的元素l = [1, 2, 3, 4, 5]del l[2:]print(l)Out:    [1, 2]# 删除整个对象l = [1, 2, 3, 4, 5]del lprint(l)Out:    NameError: name 'l' is not defined# del删除引用（变量），而不是删除对象(数据)，对象由自动垃圾回收机制（GC）删除。l = [1, 2, 3, 4, 5]s = ldel lprint(s)Out:    [1, 2, 3, 4, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-4-4-clear"><a href="#1-2-4-4-clear" class="headerlink" title="1.2.4.4 clear()"></a>1.2.4.4 clear()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""用于清空列表中所有元素，类似于del list[:]。语法：list.clear()"""l = [1, 2, 3, 4, 5]l.clear()print(l)Out:    []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-5-列表排序"><a href="#1-2-5-列表排序" class="headerlink" title="1.2.5 列表排序"></a>1.2.5 列表排序</h4><h5 id="1-2-5-1-sort"><a href="#1-2-5-1-sort" class="headerlink" title="1.2.5.1 sort()"></a>1.2.5.1 sort()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""对原列表进行排序。语法：list.sort(key=None, reverse=False)参数：key为用来进行比较的元素，可以用内置函数或自定义函数的返回值来进行比较，函数参数只有一个。key默认为None。reverse为排序规则，reverse=True降序，reverse=False升序，默认为升序。返回值：没有返回值，会直接对原列表进行排序。"""# 最简单的排序，不设置key参数l1 = [1, 5, 4, 2, 3]l2 = ['Google', 'Baidu', 'Taobao', 'Tencent', 'Douyin']l1.sort()  # 默认升序排序l2.sort(reverse=True) # 首先比较首字符，首字符相同，比较第二个字符，以此类推。print("l1={}, l2={}".format(l1, l2))Out:    l1=[1, 2, 3, 4, 5], l2=['Tencent', 'Taobao', 'Google', 'Douyin', 'Baidu']# 设置参数key，按字符串长度排序l = ['Google', 'Baidu', 'Taobao', 'Tencent', 'Douyin']l.sort(key=len) # 先按字符串长度排序，再按字母排序print(l)Out:    ['Baidu', 'Google', 'Taobao', 'Douyin', 'Tencent']# 列表元素为元组，按元组中的部分元素进行排序l = [(1, 'b', 'A'), (3, 'b', 'D'), (2, 'c', 'B'), (4, 'd', 'C')]l.sort(key=lambda x: (x[1], x[2]))print(l)Out:    [(1, 'b', 'A'), (3, 'b', 'D'), (2, 'c', 'B'), (4, 'd', 'C')]# 列表元素为字典，按字典键或值排序l1 = [{'A': 1}, {'C':3}, {'B':2}]l2 = [{'name': 'Tom', 'age': 19}, {"name": 'Jhon', 'age': 18}]l1.sort(key=lambda x: list(x.keys()))l2.sort(key=lambda x: x['age'])print("l1={}, l2={}".format(l1, l2))Out:    l1=[{'A': 1}, {'B': 2}, {'C': 3}], l2=[{'name': 'Jhon', 'age': 18}, {'name': 'Tom', 'age': 19}]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-5-2-sorted"><a href="#1-2-5-2-sorted" class="headerlink" title="1.2.5.2 sorted()"></a>1.2.5.2 sorted()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""对所有可迭代对象进行排序，返回排序后的新对象，原对象保持不变。语法：sorted(iterable, key=None, reverse=False)  参数：key为设置的排序方法，或指定迭代对象中用于排序的元素，reverse为排序规则。返回值：返回排序后的新对象。"""# 一维列表、元组、字典的排序l = [3, 1, 2, 5, 4]t = ('c', 'a', 'e', 'b', 'd')d = {'huawei': 1, 'vivo': 3, 'meizu': 4, 'oppo': 2}rl = sorted(l, reverse=True)rt = sorted(t)rd1 = sorted(d)  # 按键排序rd2 = sorted(d.items(), key=lambda x: x[1])  # 按值排序print("rl={}, rt={}".format(rl, rt))print("rd1={}, rd2={}".format(rd1, rd2))Out:    rl=[5, 4, 3, 2, 1], rt=['a', 'b', 'c', 'd', 'e']    rd1=['huawei', 'meizu', 'oppo', 'vivo'], rd2=[('huawei', 1), ('oppo', 2), ('vivo', 3), ('meizu', 4)]# 由列表作为元素组成的列表或元组l = [[1, 4, 6], [3, 2, 5], [2, 3, 6], [4, 1, 3]]r = sorted(l, key=lambda x: x[1], reverse=True)print(r)Out:    [[1, 4, 6], [2, 3, 6], [3, 2, 5], [4, 1, 3]]# 字典组成的列表l = [{'A': 1}, {'C':3}, {'B':2}]r = sorted(l, key=lambda x: list(x.values()))print(r)Out:    [{'A': 1}, {'B': 2}, {'C': 3}]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：1. sort()是列表的方法，仅可用于列表的排序，而sorted()可对所有可迭代对象进行排序。2. sort()无返回值，是直接对原列表进行排序，sorted()会返回一个排序后的新对象，原对象不变。</p></blockquote><h4 id="1-2-6-反转列表"><a href="#1-2-6-反转列表" class="headerlink" title="1.2.6 反转列表"></a>1.2.6 反转列表</h4><h5 id="1-2-6-1-reverse"><a href="#1-2-6-1-reverse" class="headerlink" title="1.2.6.1 reverse()"></a>1.2.6.1 reverse()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""用于反向列表中的元素。语法：list.reverse()参数：无参数返回值：没有返回值，直接对原列表进行反向操作。"""l = [1, 2, 3, 4, 5]l.reverse()print(l)Out:    [5, 4, 3, 2, 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-6-2-reversed"><a href="#1-2-6-2-reversed" class="headerlink" title="1.2.6.2 reversed()"></a>1.2.6.2 reversed()</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""实现序列的反转语法：reversed(seq)参数：seq为要转换的序列，如列表、元组、字符串等。返回值：返回一个迭代器，需要通过遍历或list等类型转换获取反转后的序列。"""s = 'AABBCC't = ('a', 'b', 'c')r1 = reversed(s)r2 = reversed(t)print("r1={}, r2={}".format(''.join(r1), tuple(r2)))Out:    r1=CCBBAA, r2=('c', 'b', 'a')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-6-3-使用列表切片"><a href="#1-2-6-3-使用列表切片" class="headerlink" title="1.2.6.3  使用列表切片"></a>1.2.6.3  使用列表切片</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">l = [1, 2, 3, 4, 5]r = l[::-1]print(r)Out:    [5, 4, 3, 2, 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-7-列表统计"><a href="#1-2-7-列表统计" class="headerlink" title="1.2.7 列表统计"></a>1.2.7 列表统计</h4><h5 id="1-2-7-1-计算最大值与最小值"><a href="#1-2-7-1-计算最大值与最小值" class="headerlink" title="1.2.7.1 计算最大值与最小值"></a>1.2.7.1 计算最大值与最小值</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""返回列表元素中的最大值/最小值。语法：max(list) / min(list)返回值：列表元素中的最大值/最小值。"""l = [1, 2, 3, 4, 5]r_min = min(l)r_max = max(l)print("最大值：{}, 最小值：{}".format(r_max, r_min))Out:    最大值：5, 最小值：1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-7-2-计算列表元素个数"><a href="#1-2-7-2-计算列表元素个数" class="headerlink" title="1.2.7.2 计算列表元素个数"></a>1.2.7.2 计算列表元素个数</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""计算列表元素个数。语法：len(list)返回值：列表元素个数。"""l = [1, 2, 3, 4, 5]r = len(l)print(r)Out:    5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-7-3-统计元素出现次数"><a href="#1-2-7-3-统计元素出现次数" class="headerlink" title="1.2.7.3 统计元素出现次数"></a>1.2.7.3 统计元素出现次数</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""用于统计某个元素在列表中出现的次数。语法：list.count(obj)参数：obj为要统计的元素返回值：返回元素在列表中出现的次数。"""l = ['a', 'b', 'a', 'c', 'd']r = l.count('a')print(r)Out:    2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-8-成员关系（in-not-in）"><a href="#1-2-8-成员关系（in-not-in）" class="headerlink" title="1.2.8 成员关系（in/not in）"></a>1.2.8 成员关系（in/not in）</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""判断子对象在列表中是否存在。"""# 存在 in 不存在 not ins = 'huawei'l = ['huawei', 'meizu', 'vivo', 'iphone']print(s in l)print(s not in l)Out:    True    False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-9-列表转换"><a href="#1-2-9-列表转换" class="headerlink" title="1.2.9 列表转换"></a>1.2.9 列表转换</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 将其他类型的数据转换为列表s = "Hello World."l = list(s)print(l)Out:    ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '.']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-进阶知识"><a href="#1-3-进阶知识" class="headerlink" title="1.3 进阶知识"></a>1.3 进阶知识</h3><h4 id="1-3-1-深浅拷贝与赋值"><a href="#1-3-1-深浅拷贝与赋值" class="headerlink" title="1.3.1 深浅拷贝与赋值"></a>1.3.1 深浅拷贝与赋值</h4><ul><li>赋值</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""1. 赋值操作其实就是对象的引用，相当于起了别名。2. 原对象发生变化，引用的对象也随之变化。3. A = B, A、B的值相等，内存地址相等，修改原对象B后，A、B的值和地址依然相等。"""# 对象进行增删改操作，不改变对象的地址l = [1, 2, 3, 4, 5]l1 = ll[2] = 'a'print("l={}, l1={}".format(l, l1))print("id_l:{}, id_l1:{}".fromat(id(l), id(l1)))Out:    l=[1, 2, 'a', 4, 5], l1=[1, 2, 'a', 4, 5]    id_l:2355940798152, id_l1:2355940798152   # 地址相同# 重新初始化后，会开辟新的空间l = [1, 2, 3, 4, 5]l1 = ll = ['a', 'b', 'c', 'd', 'e']print("l={}, l1={}".format(l, l1))print("id_l:{}, id_l1:{}".fromat(id(l), id(l1)))Out:    l=['a', 'b', 'c', 'd', 'e'], l1=[1, 2, 3, 4, 5]    id_l:2355940855560, id_l1:2355940694280  # 地址不同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>浅拷贝</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""1. 拷贝父对象，不会拷贝对象的内部的子对象，子对象仍然指向原来的内存地址。2. 值相等，内存地址不相等 ，修改原对象后，值和地址不相等。3. 切片[:]、list的copy()方法和copy模块的copy()方法都为浅拷贝"""# 浅拷贝后地址不同l = [1, 2, 3, ['a', 'b', 'c']]l1 = l.copy()print("id_l={}, id_l1={}".format(id(l), id(l1)))Out:    id_l=2355940803720, id_l1=2355940806600  # 地址变化# 原对象父对象改变，拷贝父对象不变l = [1, 2, 3, ['a', 'b', 'c']]l1 = l.copy()l.append(4)print("l={}, l1={}".format(l, l1))Out:    l=[1, 2, 3, ['a', 'b', 'c'], 4], l1=[1, 2, 3, ['a', 'b', 'c']]# 原对象子对象改变，拷贝对象的子对象随之改变l = [1, 2, 3, ['a', 'b', 'c']]l1 = l.copy()l[3].append('d')print("l={}, l1={}".format(l, l1))Out:    l=[1, 2, 3, ['a', 'b', 'c', 'd']], l1=[1, 2, 3, ['a', 'b', 'c', 'd']]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>深拷贝</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""1. 拷贝父对象及其子对象。2. 值相等，内存地址不相等，修改原对象后，值和地址不相等。3. copy模块的deepcopy()方法为深拷贝。"""# 修改原对象的父对象，拷贝的对象不变from copy import deepcopyl = [1, 2, 3, ['a', 'b', 'c']]l1 = deepcopy(l)l.append(4)print("l={}, l1={}".format(l, l1))Out:    l=[1, 2, 3, ['a', 'b', 'c'], 4], l1=[1, 2, 3, ['a', 'b', 'c']]# 修改原对象的子对象，拷贝的对象也不变from copy import deepcopyl = [1, 2, 3, ['a', 'b', 'c']]l1 = deepcopy(l)l[3].append('d')print("l={}, l1={}".format(l, l1))Out:    l=[1, 2, 3, ['a', 'b', 'c', 'd']], l1=[1, 2, 3, ['a', 'b', 'c']]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-2-比较（is与-）"><a href="#1-3-2-比较（is与-）" class="headerlink" title="1.3.2 比较（is与==）"></a>1.3.2 比较（is与==）</h4><p>Python对象包含三个基本要素：id（身份标识）、type（数据类型）、value（值）。is和==都是对对象进行比较判断，但比较判断的内容不同。</p><ul><li>is是用来检查对象的标识是否一致，也就是比较两个对象在内存中的地址是否一样，即id是否相同。</li><li>==是比较两个对象的内容是否相等，即值value是否相等。比较时会调用对象的<code>__eq__()</code>。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">l1 = [1, 2, 3, 4, 5]l2 = l1.copy()print(l1 == l2)print(l1 is l2)Out:    True    # 值相同    False   # id不同# 判断是否为Nonevar = Noneprint(var is None)Out:    True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-3-列表解析"><a href="#1-3-3-列表解析" class="headerlink" title="1.3.3 列表解析"></a>1.3.3 列表解析</h4><p>列表解析又叫列表推导式，可以根据一个列表生成新的列表。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""语法：[表达式 for 变量 in 列表] 或者 [表达式 for 变量 in 列表 if 条件]"""# 不加判断条件l = list(range(10))l_new = [item**2 for item in l]print(l_new)Out:    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]# 有判断条件l = list(range(10))l_new = [item for item in l if item % 2 == 0]l_new1 = [item*2 if item%2==0 else item**2 for item in l]print(l_new)print(l_new1)Out:    [0, 2, 4, 6, 8]    [0, 1, 4, 9, 8, 25, 12, 49, 16, 81]# 多个循环l1 = [1, 2, 3]l2 = ['a', 'b']l_new = [(item1,item2) for item1 in l1 for item2 in l2]print(l_new)Out:    [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b'), (3, 'a'), (3, 'b')]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-4-enumerate-与zip"><a href="#1-3-4-enumerate-与zip" class="headerlink" title="1.3.4 enumerate()与zip()"></a>1.3.4 enumerate()与zip()</h4><ul><li>enumerate()</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""将一个可迭代的数据对象(如列表、元组或字符串)组合为带有索引的枚举对象。语法：enumerate(seq, start=0])参数：seq为可迭代的数据对象，start为起始索引，默认为0。返回值：返回一个enumerate(枚举)对象。"""l = ['A', 'B', 'C', 'D']r1 = enumerate(l, 1)r2 = list(enumerate(l, 1))  # enumerate对象转换为列表print(r1)print(r2)Out:    <enumerate object at 0x000001E214A34638>      [(1, 'A'), (2, 'B'), (3, 'C'), (4, 'D')]# 用于for循环遍历l = ['A', 'B', 'C', 'D']for index, value in enumerate(l, 1):    print(index, value)Out:    1 A    2 B    3 C    4 D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>zip()</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""将可迭代对象对应元素打包成一个个元组，返回由这些元组组成的zip对象。当多个迭代对象长度不同时，返回对象的长度与最小长度相同。语法：zip(iter,...)参数：iter为可迭代对象，如列表、元组、字符串、字典等返回：返回一个zip对象。"""# 单个对象l = [1, 2, 3, 4, 5]print(zip(l))print(list(zip(l)))Out:    <zip object at 0x000001E214A39848>    [(1,), (2,), (3,), (4,), (5,)]# 多个对象打包l1 = [1, 2, 3, 4, 5]l2 = ['A', 'B', 'C', 'D', 'E']s = ('a', 'b', 'c', 'd', 'e')print(list(zip(l1,l2,s)))Out:    [(1, 'A', 'a'), (2, 'B', 'b'), (3, 'C', 'c'), (4, 'D', 'd'), (5, 'E', 'e')]# zip(*zipped)  *list/tuple，在列表/元组前面加星号作用是将列表/元组解开成两个独立的元素，可作为参数传入函数。l1 = [1, 2, 3]l2 = [4, 5, 6]l3 = [7, 8 ,9]r1 = zip(l1, l2, l3)r2 = zip(*zip(l1, l2, l3))  # 一般认为这是一个unzip的过程print(list(r1))print(list(r2))Out:    [(1, 4, 7), (2, 5, 8), (3, 6, 9)]    [(1, 2, 3), (4, 5, 6), (7, 8, 9)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-5-all-与any"><a href="#1-3-5-all-与any" class="headerlink" title="1.3.5 all()与any()"></a>1.3.5 all()与any()</h4><ul><li>all()</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""用于判断可迭代对象iterable中元素是否都为True。元素除了0、空（''、[]、()等）、None、False都为True。语法：all(iterable)参数：iterable为可迭代对象，参数不可为空，但iterable可为空值。返回值：如果所有的元素都为True，则返回True，否则返回False。"""# 可迭代对象不为空值l1 = ['a', 1, [], 'A']l2 = ['b', 2, ['a', 'b'], 'B']r1 = all(l1)r2 = all(l2)print(f"r1={r1}, r2={r2}")Out:    r1=False, r2=True# 可迭代对象为空l = []r = all(l)print(r)Out:    True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python"># all()等价于如下代码def all(iterable):    for element in iterable:        if not element:            return False    return True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>any()</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""用于判断可迭代对象iterable中元素是否全为False，如果是则返回False，否则返回True。语法：any(iterable)参数：iterable为可迭代对象，参数不可为空，但iterable可为空值。返回值：如果所有的元素全为False，则返回False，否则返回True。"""# 可迭代对象不为空t = ('a', '', [], 'A')r = any(t)print(r)Out:    True# 可迭代对象为空l = []r = any(t)print(r)Out:    False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python"># any()等价于如下代码def any(iterable):    for element in iterable:        if element:            return True    return False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-5-创建空列表的效率"><a href="#1-3-5-创建空列表的效率" class="headerlink" title="1.3.5 创建空列表的效率"></a>1.3.5 创建空列表的效率</h4><p>创建空列表主要有两种方式：<code>list()</code>或<code>[]</code>。对于这两种方式，<strong>使用<code>[]</code>创建空列表效率更高</strong>。主要是因为list()是一个函数调用，Python的函数调用会创建stack，并且进行一系列参数检查的操作，而[]是一个内置的C函数，可以直接被调用，因此效率高。</p><h4 id="1-3-6-判断列表有无重复元素"><a href="#1-3-6-判断列表有无重复元素" class="headerlink" title="1.3.6 判断列表有无重复元素"></a>1.3.6 判断列表有无重复元素</h4><ul><li>使用 list自带的count方法，依次判断每个元素在 list 内的出现次数，如果大于 1，则返回 True，表示有重复。遍历完成后，如果返回True，则表名有重复元素，否则无重复元素。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">def is_duplicated(lst):    for ele in lst:        if lst.count(ele) > 1:            return True    return False# 调用函数lst = [1, 2, 1, 3, 4, 5]result = is_duplicated(lst)print(result)Out:    True# 找出重复元素def find_duplicate(lst):    dup = []    for item in lst:        if lst.count(item) > 1 and item not in dup:            dup.append(item)    return duplst = [1, 2, 3, 2, 4, 3]r = find_duplicate(lst)print(r)Out:    [2, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用set()判断更方便。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">def is_duplicated(lst):    return len(lst) != len(set(lst))lst = [1, 2, 1, 3, 4, 5]result = is_duplicated(lst)  # result = True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-7-在列表中根据条件筛选数据"><a href="#1-3-7-在列表中根据条件筛选数据" class="headerlink" title="1.3.7 在列表中根据条件筛选数据"></a>1.3.7 在列表中根据条件筛选数据</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">from random import randintimport randomrandom.seed(10)# 生成一个列表l = [randint(-20, 20) for _ in range(10)]print(l)# 使用列表解析筛选数据res = [item for item in l if item > 0]print(res)# 使用内置函数filter(func, iterable)，返回一个迭代器对象。res = list(filter(lambda x: x >= 0, l))print(res)Out:    [16, -18, 7, 10, 16, -20, -7, 9, 11, -3]    [16, 7, 10, 16, 9, 11]    [16, 7, 10, 16, 9, 11]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：推荐使用列表解析。</p></blockquote><h4 id="1-3-8-统计序列中元素的频度"><a href="#1-3-8-统计序列中元素的频度" class="headerlink" title="1.3.8 统计序列中元素的频度"></a>1.3.8 统计序列中元素的频度</h4><ul><li>将序列转换为字典{元素：频度}，根据字典值排序。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">from random import randintdata = [randint(0, 10) for _ in range(20)]d = dict.fromkeys(data, 0)for x in data:    d[x] += 1res = sorted(((k,v) for k, v in d.items()), key=lambda x: x[1], reverse=True)[:3]print(res)# 使用heapq模块中的nlargest()函数import heapqres = heapq.nlargest(3, ((k,v) for k, v in d.items()), key=lambda x: x[1])print(res)Out:    [(9, 4), (1, 3), (4, 3)]    [(9, 4), (1, 3), (4, 3)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用标准库collections中Counter()对象。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">from collections import Countercnt = Counter(data)print(cnt)res = cnt.most_common(3)print(res)Out:    Counter({9: 4, 1: 3, 4: 3, 5: 3, 2: 2, 0: 1, 10: 1, 6: 1, 3: 1, 8: 1})    [(9, 4), (1, 3), (4, 3)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-元组"><a href="#2-元组" class="headerlink" title="2. 元组"></a>2. 元组</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>与列表一样，元组也是一个可以放置<strong>任意数据类型</strong>的有序集合，使用括号<code>()</code>将元素括起来就可以创建一个元组对象。<u><em>对于只有一个整数元素，需要加逗号才会返回一个元组对象，如（10,），否则只是一个整数。</em></u></p><p>由于元组也是一个序列，列表支持的索引和切片等操作，元组也支持。不同于列表的是，元组是一个不可变的容器对象，不能直接对元组进行修改。如果想对元组进行”改变“，只能创建新的元组。</p><ul><li>列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。</li><li>元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。</li></ul><h3 id="2-2-基本操作"><a href="#2-2-基本操作" class="headerlink" title="2.2 基本操作"></a>2.2 基本操作</h3><h4 id="2-2-1-索引与切片操作"><a href="#2-2-1-索引与切片操作" class="headerlink" title="2.2.1 索引与切片操作"></a>2.2.1 索引与切片操作</h4><p>与列表的索引和切片操作类似，可以根据索引取值和切片取值操作，但由于元组不可变，不能进行切片赋值操作。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 索引、切片t = (1, 2, 3, 4, 5)r1 = t[-1]r2 = t[1:-1]print(f"r1={r1}, r2={r2}")Out:    r1=5, r2=(2, 3, 4)# 切片赋值t = (1, 2, 3, 4, 5)t[1] = 'A'  # 报错：TypeError: 'tuple' object does not support item assignment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-修改元组"><a href="#2-2-2-修改元组" class="headerlink" title="2.2.2 修改元组"></a>2.2.2 修改元组</h4><p>元组是不可变对象，但对于元素为列表等可变对象时，可以对元素进行修改，而该元素指向的地址并不变，也就不违背不可变序列的要求。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 对元组中的可变对象进行修改，元组的地址和可变对象元素地址并未改变。t = (1, 2, 3, ['a', 'b'], 4)print(id(t))print(id(t[3]))t[3].append('c')print(id(t))print(id(t[3]))print(t)Out:    2037074887016    2037070848328    2037074887016    2037070848328    (1, 2, 3, ['a', 'b', 'c'], 4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-元组连接-复制"><a href="#2-2-3-元组连接-复制" class="headerlink" title="2.2.3 元组连接/复制"></a>2.2.3 元组连接/复制</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 连接t1 = (1, 2, 3)t2 = ('a', 'b', 'c')t_new = t1 + t2print(t_new)Out:    (1, 2, 3, 'a', 'b', 'c')# 复制t = ('A', 'B', 'C')t_new = t*2print(t_new)Out:    ('A', 'B', 'C', 'A', 'B', 'C')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-4-元组统计"><a href="#2-2-4-元组统计" class="headerlink" title="2.2.4 元组统计"></a>2.2.4 元组统计</h4><p>与列表一样，元组也拥有一些内置函数，用于统计元素个数、元素最大值/最小值等。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 统计元素个数t = (1, 2, 3, 4, 5)num = len(t)print(num)Out:    5# 返回列表元素最大值、最小值t = ('1', '2', '3', '4')num_max = max(t)num_min = min(t)print(f"最大值={num_max}, 最小值={num_min}")Out:    最大值=4, 最小值=1# 统计元素出现次数t = (1, 2, 3, 1, 4)num = t.count(1)print(num)Out:    2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-5-元组转换"><a href="#2-2-5-元组转换" class="headerlink" title="2.2.5 元组转换"></a>2.2.5 元组转换</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 将其他可迭代序列转换为元组l = [1, 'a', 2, 'b', 3, 'c']t = tuple(l)print(t)Out:    (1, 'a', 2, 'b', 3, 'c')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-6-元组排序"><a href="#2-2-6-元组排序" class="headerlink" title="2.2.6 元组排序"></a>2.2.6 元组排序</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 可以将元组转换为列表，使用列表的sort()进行排序操作，也可以直接使用内置函数sorted()对元组进行排序t = (3, 2, 1, 5, 4)r = sorted(t, reverse=True)print(r)Out:    [5, 4, 3, 2, 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-7-成员关系"><a href="#2-2-7-成员关系" class="headerlink" title="2.2.7 成员关系"></a>2.2.7 成员关系</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">t = ('huawei', 'meizu', 'vivo', 'iphone')print('huawei' in t)Out:    True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-8-元组排序"><a href="#2-2-8-元组排序" class="headerlink" title="2.2.8 元组排序"></a>2.2.8 元组排序</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""元组没有reverse()函数，但可以将元组转换为列表，使用列表的reverse()函数。元组可以使用reversed()返回一个迭代器。"""t = (3, 2, 1, 5, 4)r = reversed(t)print(r)print(tuple(r))Out:    <reversed object at 0x00000144D4DBC508>    (4, 5, 1, 2, 3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-进阶知识"><a href="#2-3-进阶知识" class="headerlink" title="2.3 进阶知识"></a>2.3 进阶知识</h3><h4 id="2-3-1-元组与列表对比"><a href="#2-3-1-元组与列表对比" class="headerlink" title="2.3.1 元组与列表对比"></a>2.3.1 元组与列表对比</h4><ul><li>元组和列表存储方式差异</li></ul><p>列表是动态的、可变的，需要存储指针来指向对应的元素，并且额外存储已经分配好的长度大小来实时追踪列表空间的使用情况。元组是静态的、不可变的，存储空间固定。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">l = []l.__sizeof__()  # 40l.append(1)l.__sizeof__()  # 72，分配存储4个int元素的空间 （72-40）/8 = 4l.extend([2, 3, 4]) l.__sizeof__()  # 72l.append(5)l.__sizeof__()  # 104<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>元组与列表的性能</li></ul><p>元组的性能速度要略优于列表。对于元组，如果占用空间不大，Python会暂时缓存这部分内存。当再次创建同样大小的元组时，Python就可以不用再向操作系统发出请求去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。</p><p>总结：</p><p>列表和元组都是有序的，可以存储任意数据类型的集合，主要区别：</p><ul><li>列表是动态的，长度可变，可以随意的增加、删减或改变元素。列表的存储空间略大于元组，性能略逊于元组。</li><li>元组是静态的，长度大小固定，不可以对元素进行增加、删减或者改变操作。元组相对于列表更加轻量级，性能稍优。</li></ul><h4 id="2-3-2-元组元素命名提高可读性"><a href="#2-3-2-元组元素命名提高可读性" class="headerlink" title="2.3.2 元组元素命名提高可读性"></a>2.3.2 元组元素命名提高可读性</h4><ul><li>定义数值常量</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">NAME, AGE, GENDER = range(3)student = ('Tom', 18, 'male')print(student[NAME] == 'Henry')  # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>使用枚举</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">from enum import IntEnumclass StudentEnum(IntEnum):    NAME = 0    AGE = 1    GENDER = 2student = ('Tom', 18, 'male')print(student[StudentEnum.NAME])  # Tom<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用具名元组</li></ul><p>collections.namedtuple是一个工厂函数，可以用来构建一个带字段名的元组和一个有名字的类。创建一个具名元组需要两个参数：一个是类名，一个是类的各个字段的名称，其中后者可以是由多个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。存放在对应字段里的数据要以一串参数的形式传入到构造函数中。可以通过字段名或者位置来获取一个字段的信息。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from collections import namedtupleStudent = namedtuple('Student', ['name', 'age', 'gender'])stu = Student('Tom', 18, 'male')print(stu.name) # Tom<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（三）：数据类型-数字与字符串</title>
      <link href="/posts/3b438966.html"/>
      <url>/posts/3b438966.html</url>
      
        <content type="html"><![CDATA[<p>Python中有6种标准的数据类型：数字（Number）、字符串（String）、列表（List）、元组（Tuple）、集合（Set）、字典（Dictionary）。</p><p>上述6种数据类型可分为两类：</p><ul><li>不可变数据类型：数字、字符串、元组。</li><li>可变数据类型：列表、集合、字典。</li></ul><p>同时，<strong>元组、列表、集合、字典也是容器类型</strong>，即可以存储不同类型的数据。元组、列表、字符串也是Python的序列类型，即数据是有序的，可通过下标索引访问特定元素。</p><h2 id="1-数字"><a href="#1-数字" class="headerlink" title="1. 数字"></a>1. 数字</h2><p>Python的数字类型中包括：整型（int）、浮点型（float）、布尔型（bool）、复数（complex）。其中，布尔型：表示真(True)、假(False)。0和空都表示False，如’ ‘、[ ]、{ }、None。非空表示True</p><ul><li>数值运算：加、减、乘、除、整除、求余（+、-、 *、 /、 //、 %）</li><li>10、2、8、16进制表示与转换<ul><li>二进制：用0b表示，如0b10表示10进制的2。</li><li>八进制：用0o表示，如0o10表示10进制的8。</li><li>十六进制：用0x表示，如0x10表示10进制的16。</li><li>bin( )：转换为二进制。</li><li>int( )：转换为十进制。</li><li>hex( )：转换为十六进制。</li><li>oct( )：转换为八进制。</li></ul></li><li>内建函数（BIF）</li></ul><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>abs()</td><td>取绝对值</td></tr><tr><td>ceil() / floor()</td><td>向上 / 向下取整</td></tr><tr><td>round()</td><td>四舍五入</td></tr><tr><td>min() / max()</td><td>最小值/最大值</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/3b438966/数字.png" style="zoom: 50%;"></p><h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.  字符串"></a>2.  字符串</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><ul><li>字符串是一个序列，可以使用单引号（’’）、双引号（””）或三引号（’’’ ‘’’，””” “””）创建。此外，三引号可定义多行字符串。</li><li>字符串中可包含转义字符，如换行（<code>\n</code> ）、单引号（<code>\'</code> ）。</li><li>非转义的原始字符串：字符串前加<code>r</code>，例如：<code>print(r'hello\nworld')</code>，换行符<code>\n</code>也会被输出，而不会产生换行。</li><li>unicode字符串：在字符串前加<code>u</code>，对字符串进行unicode编码。在Python3中，字符串默认是unicode编码，中文字符串前无需加<code>u</code>，而对于Python2，默认编码是ascii，在中文前需要加<code>u</code>。</li></ul><h3 id="2-2-常用操作"><a href="#2-2-常用操作" class="headerlink" title="2.2 常用操作"></a>2.2 常用操作</h3><h4 id="2-2-1-字符串拼接-合并"><a href="#2-2-1-字符串拼接-合并" class="headerlink" title="2.2.1 字符串拼接/合并"></a>2.2.1 字符串拼接/合并</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python"># +: 合并少数几个字符串s = "hello" + " " + "world!"print(s)Out:    hello world!# join: str.join(seq), str为连接符，seq为字符串 或 字符串为元素构成的序列s1 = 'python's2 = ['I', 'love', 'python']print('_'.join(s1))print('_'.join(s2))Out:    p_y_t_h_o_n    I_love_python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-字符串复制"><a href="#2-2-2-字符串复制" class="headerlink" title="2.2.2 字符串复制"></a>2.2.2 字符串复制</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = 'python'print(s*3)Out:    pythonpythonpython<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-字符串索引-切片"><a href="#2-2-3-字符串索引-切片" class="headerlink" title="2.2.3 字符串索引/切片"></a>2.2.3 字符串索引/切片</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 通过下标索引，默认从0开始s = 'python'result = s[1]print(result)Out:    y# 切片 [start:stop:step] start:开始索引，stop:结束索引，step: 步长，默认值为1s = 'python'r1 = s[1:]   # 从开始索引截取到字符串的最后r2 = s[:3]   # 从开头截取到结束索引之前r3 = s[1:3]  # 从开始索引截取到结束索引之前r4 = s[:]    # 截取所有字符串r5 = s[::-1] # 字符串反转print('r1=%s, r2=%s, r3=%s, r4=%s, r5=%s'% (r1, r2, r3, r4, r5)) # 格式化输出Out:    r1=ython, r2=pyt, r3=yt, r4=python, r5=nohtyp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-4-字符串的替换"><a href="#2-2-4-字符串的替换" class="headerlink" title="2.2.4 字符串的替换"></a>2.2.4 字符串的替换</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""功能：将字符串str中的子字符串old用新子字符串new替换。语法：str.replace(old, new[, max])参数：str为原始字符串，old为将被替换的子字符串，new为新字符串，max表示最多替换的次数，可选。返回：返回替换后的新字符串。"""s = 'I love python!'r = s.replace('python', 'java')print(r)Out:    I love java!s = 'abcabcabcabc'r = s.replace('ab', 'AB', 3)print(r)Out:    ABcABcABcabc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-5-字符串的匹配查找"><a href="#2-2-5-字符串的匹配查找" class="headerlink" title="2.2.5 字符串的匹配查找"></a>2.2.5 字符串的匹配查找</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""功能：检测字符串中是否包含子字符串语法：str.find(substr, beg=0, end=len(string))参数：substr为待查找的字符串，beg为开始索引，默认为0，end为结束索引，默认为字符串的长度。返回：如果包含则返回子字符串开始的索引值，否则返回-1。"""s = 'Always on the road.'r1 = s.find('road', 7, len(s))r2 = s.find('Road')print(r1, r2)Out:    14 -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与find()类似，index()也可以检测字符串中是否包含子字符串。不同的是，当查询不到待匹配的字符串时，会抛出异常。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""功能：检测字符串中是否包含子字符串语法：str.index(substr, beg=0, end=len(string))参数：substr为待查找的字符串，beg为开始索引，默认为0，end为结束索引，默认为字符串的长度。返回：如果包含子字符串返回开始的索引值，否则抛出异常。"""s = 'Always on the road.'r1 = s.index('road', 7, len(s))print(r1)Out:    14r2 = s.index('Road')# 异常ValueError: substring not found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-6-去除字符串两侧指定字符"><a href="#2-2-6-去除字符串两侧指定字符" class="headerlink" title="2.2.6 去除字符串两侧指定字符"></a>2.2.6 去除字符串两侧指定字符</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""功能：用于移除字符串头尾指定的字符语法：str.strip([char])参数：chars为待移除的字符序列返回：移除字符串头尾指定的字符生成的新字符串。"""s = ' Always on the road.\t\n'r = s.strip()print(r)Out:    'Always on the road.'s = 'abcdcdab'r = s.strip('ab')print(r)Out:    'cdcd'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与strip()类似的还有lstrip()、rstrip()两个函数，lstrip()用于去掉左侧的指定字符，rstrip()用于去掉右侧的指定字符。</p><h4 id="2-2-7-字符串按指定字符分隔"><a href="#2-2-7-字符串按指定字符分隔" class="headerlink" title="2.2.7 字符串按指定字符分隔"></a>2.2.7 字符串按指定字符分隔</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""功能：通过指定分隔符对字符串进行切片。语法：str.split(substr="", num=str.count(substr))参数：substr为分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等，num为分隔次数，默认为-1，即分隔所有。返回：返回分割后的字符串列表。"""s = ' Always on the road.\t\n'r = s.split()print(r)Out:    ['Always', 'on', 'the', 'road.']s='abcdabcdabcd'r = s.split('c', 2)print(r)Out:    ['ab', 'dab', 'dabcd']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-8-计算字符串的长度"><a href="#2-2-8-计算字符串的长度" class="headerlink" title="2.2.8 计算字符串的长度"></a>2.2.8 计算字符串的长度</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = 'Always on the road.'r = len(s)print(r)Out:    19<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-9-统计指定字符串出现的次数"><a href="#2-2-9-统计指定字符串出现的次数" class="headerlink" title="2.2.9 统计指定字符串出现的次数"></a>2.2.9 统计指定字符串出现的次数</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""功能：用于统计字符串里某个字符出现的次数。语法：str.count(substr, start=0,end=len(str))参数：substr为待匹配的子字符串，start和end分别为字符串开始、结束搜索的位置。返回：返回子字符串在字符串中出现的次数。"""s = 'Always on the road.'r = s.count('a')print(r)Out:    2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-10-判断是否包含指定字符串"><a href="#2-2-10-判断是否包含指定字符串" class="headerlink" title="2.2.10 判断是否包含指定字符串"></a>2.2.10 判断是否包含指定字符串</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = 'Always on the road.'print('road' in s)print('road' not in s)Out:    True    False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-11-字符串转换大小写"><a href="#2-2-11-字符串转换大小写" class="headerlink" title="2.2.11 字符串转换大小写"></a>2.2.11 字符串转换大小写</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 将每个单词首字母变为大写: title()s = 'I love python!'r = s.title()print(r)Out:    I Love Python!# 字符串字母全部转为小写/大写: lower()/upper()s = 'I love python!'r1 = s.lower()r2 = s.upper()print(r1)print(r2)Out:    i love python!    I LOVE PYTHON!# 字符串首字母大写: capitalize()s = 'i love python!'r = s.capitalize()print(r)Out:    I love python!# 大小写互换: swapcase()s = 'abcABC'r = s.swapcase()print(r)Out:    ABCabc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-11-格式化字符串"><a href="#2-2-11-格式化字符串" class="headerlink" title="2.2.11 格式化字符串"></a>2.2.11 格式化字符串</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""%-格式化格式化符号：%s：格式化字符串%d：格式化整数%f：格式化浮点数，可指定小数点后的精度"""s = ("lin", '1001')print("姓名:%s, 工号:%s"%s)Out:    姓名:lin, 工号:1001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""str.format()-格式化"""# 按默认位置填充print("{} {}".format("hello", "world")  )Out:    hello world# 按位置索引填充print("{1} {0}".format("world", "hello"))Out:    hello world# 通过参数填充print("姓名：{name}, 学号：{ID}".format(name="张三", ID="1002"))Out:    姓名：张三, 学号：1002# 通过字典设置参数data = {"name": "张三", "ID": "1002"}print("姓名：{name}, 学号：{ID}".format(**data))Out:    姓名：张三, 学号：1002<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python">"""f-string 格式化是Python3.6新引入的一种字符串格式化方法在形式上是以 f 或 F 修饰符引领的字符串（f'xxx' 或 F'xxx'），以大括号 {} 标明被替换的字段。在本质上并不是字符串常量，而是一个在运行时运算求值的表达式。"""# 解析变量name = "张三"ID = "1002"print(f"姓名: {name}, 学号: {ID}")Out:    姓名: 张三, 学号: 1002# 解析字典data = {"name": "张三", "ID": "1002"}print(f"姓名: {data['name']}, 学号: {data['ID']}")Out:    姓名: 张三, 学号: 1002# 表达式s1 = 'hello's2 = 'world'print(f'{s1+s2}')Out:    helloworld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/3b438966/字符串.png" alt></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（二）：基础语法</title>
      <link href="/posts/e8a303d6.html"/>
      <url>/posts/e8a303d6.html</url>
      
        <content type="html"><![CDATA[<p>Python是一种动态的、强类型语言。所谓<strong>动态类型</strong>是指类型检查操作是发生在程序执行阶段，像Python、JavaScript都属于这类型。其中，类型检查主要是验证类型约束的过程，查看变量及其类型，判断表达式是否合理。如果类型检查发生在编译阶段，就是静态类型语言，比如C、C++、Java等。而对于强类型，主要是指不管是在编译阶段还是运行阶段，一旦某种类型绑定到变量后，此变量便会持有此类型，并且不能同其他类型在计算表达式中混合使用。常见的强类型语言有：Python、Java、Scala、C#等。与之想对应的就是弱类型语言，可以进行混合类型运算，常见的有C、C++、JavaScript等。</p><h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1. 基础语法"></a>1. 基础语法</h2><h3 id="1-1-缩进"><a href="#1-1-缩进" class="headerlink" title="1.1 缩进"></a>1.1 缩进</h3><p>大部分的编程语言都是使用“{}”来表示一个代码段，而 Python 用缩进层次来组织代码块，默认一个缩进使用“四个空格”表示。</p><h3 id="1-2-编码"><a href="#1-2-编码" class="headerlink" title="1.2. 编码"></a>1.2. 编码</h3><ul><li><p>Python3中有两种表示字符序列的类型：bytes和str，其中bytes是包含8位值的序列，str是包含Unicode字符的序列。</p></li><li><p>Python2中两种表示字符序列的类型：str和unicode，其中str是包含8位值的序列，unicode是包含Unicode字符的序列。</p></li><li><p>使用encode方法将Unicode字符转换成二进制数据，使用decode方法将二进制数据解码成Unicode字符。</p></li><li><p>将Unicode字符表示为二进制数据最常用的编码方式为UTF-8。</p></li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># Python3中，利用辅助函数将str或bytes转换为strdef to_str(bytes_or_str):    if isinstance(bytes_or_str, str):        value = bytes_or_str    else:        value = bytes_or_str.decode('utf-8')    return value  # 返回str# 将str或bytes转换为bytesdef to_bytes(bytes_to_str):    if isinstance(bytes_to_str, bytes):        value = bytes_to_str    else:        value = bytes_to_str.encode('utf-8')    return value  # 返回bytes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-标识符"><a href="#1-3-标识符" class="headerlink" title="1.3. 标识符"></a>1.3. 标识符</h3><p>Python标识符命名规范：</p><ul><li>标识符由字母（<code>A~Z</code> 和 <code>a~z</code>）、数字和下划线组成，首字符必须以字母或下划线。</li><li>区分大小写。</li><li>不是能Python关键字。</li></ul><p>标识符编码习惯：</p><ul><li>见名知义，使用有意义的单词或词组，不要使用拼音。</li><li>采用下划线命名法或驼峰式命名法：<ul><li>使用下划线连接单词命名（推荐使用这种方式）：var_name。</li><li>小驼峰式命名：第一个单词小写，其他单词大写，如myName。</li><li>大驼峰式命名：每个单词首字母都为大写，如ClassName。</li></ul></li></ul><p>Google Python命名规范：</p><ul><li>模块和包：小写字母，尽量简单，可以使用“_”连接，如module_name，package_name。</li><li>类名：使用大驼峰式命名，如ClassName。</li><li>函数名和类中的方法名：全部使用小写字母，多个单词之间下划线连接，如function_name，method_name。</li><li>变量名（全局变量、局部变量、类变量、实例变量）：全局变量大写，局部变量名、类变量名、实例变量名小写，使用下划线连接，如GLOBAL_VAR_NAME, local_var_name, class_var_name, instance_var_name。</li><li>常量名：大写字母，使用下划线连接，如CONSTANT_NAME。</li><li>函数和方法的参数：小写字母，如function_parameter_name。</li><li>异常：使用大驼峰式命名，如ExceptionName。</li></ul><p>标识符以下划线开头：</p><ul><li>以单下划线“_”开头：受保护的变量，表示不能直接访问的类属性，需通过类提供的接口进行访问，不能用 <code>from module_name import *</code> 导入。只有类和子类对象可以访问这些变量。</li><li>双下划线“__”开头：私有成员，只有类对象可以访问。</li><li>双下划线开头和结尾：专用标识符，有特殊的身份，如 <code>__init__</code>。</li></ul><h3 id="1-4-注释"><a href="#1-4-注释" class="headerlink" title="1.4. 注释"></a>1.4. 注释</h3><ul><li>单行注释：<code>#</code> 开头。</li><li>多行注释：可以每一行都以<code>#</code>开头，也可以用<code>"""</code>或<code>'''</code>。</li></ul><h3 id="1-5-多行语句"><a href="#1-5-多行语句" class="headerlink" title="1.5. 多行语句"></a>1.5. 多行语句</h3><ul><li>使用斜杠（ \ ）将一行的语句分为多行显示。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = "Explicit is better than implicit." \    "Simple is better than complex."<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠( \ )。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = ("Explicit is better than implicit."     "Simple is better than complex.")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-6-引号"><a href="#1-6-引号" class="headerlink" title="1.6. 引号"></a>1.6. 引号</h3><p>Python支持单引号（’’）、双引号（””）、三引号（””” “””或’’’ ‘’’）表示字符串。三引号可以定义多行字符串，同时也可以进行多行注释。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 多行字符串s = """Explicit is better than implicit.Simple is better than complex."""# 多行注释"""注释第一行注释第二行"""<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-Python风格规范"><a href="#2-Python风格规范" class="headerlink" title="2. Python风格规范"></a>2. Python风格规范</h2><p>参考<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/" target="_blank" rel="noopener">Google Python风格规范</a></p><h3 id="2-1-空白"><a href="#2-1-空白" class="headerlink" title="2.1 空白"></a>2.1 空白</h3><h4 id="2-1-1-缩进"><a href="#2-1-1-缩进" class="headerlink" title="2.1.1 缩进"></a>2.1.1 缩进</h4><ul><li>用4个空格来缩进代码，不要使用Tab。</li><li>对于占据多行的表达式，除首行外其余各行都应该在通常缩进级别上再加4个空格。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 与开头分隔符对齐func = function_name(arg1, arg2,                     arg3, arg4)# 4个空格缩进，第一行无参数func = function_name(    arg1, arg2, arg3,     arg4)# 在字典中，与开头分隔符对齐dic = {    long_dictionary_key: value1 +                         value2,    ...}# 在字典中，4个空格缩进dic = {    long_dictionary_key:        long_dictionary_value,    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-空行"><a href="#2-1-2-空行" class="headerlink" title="2.1.2 空行"></a>2.1.2 空行</h4><ul><li>函数或者类之间用两个空行隔开。</li><li>在同一个类中，方法之间或者类与第一个方法之间，用一个空行隔开。</li></ul><h4 id="2-1-3-空格"><a href="#2-1-3-空格" class="headerlink" title="2.1.3 空格"></a>2.1.3 空格</h4><ul><li><p>括号内不要有空格。</p></li><li><p>不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加（行尾除外）。</p></li><li><p>参数列表, 索引或切片的左括号前不应加空格。</p></li><li>在使用赋值（=）、比较（==、&gt;、&lt;、!=、&lt;&gt;、&gt;=、&lt;=、is、is not、in、not in）、布尔（not、and、or）等操作符时，左右两侧各加一个空格。</li><li>当’=’用于指示关键字参数或默认参数值时, 不要在其两侧使用空格。</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># Tip1funcName(A[1], B[2], [1, 2, 3])# Tip2if x > y:    print(x, y)# Tip3arr[1], list[1:3]# Tip4a == b, not flag# Tip5funcName(id=None, score=None)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-行长度"><a href="#2-2-行长度" class="headerlink" title="2.2 行长度"></a>2.2 行长度</h3><ul><li><p>每行不超过80个字符，其中长的导入模块语句和注释里的URL除外。</p></li><li><p>不要使用反斜杠连接行，可以用圆括号、中括号和花括号连接。</p></li><li><p>如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接。</p></li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">funName(arg1, arg2, arg3, ...        argN-1, argN)x = ('This will build a very long long '     'long long long long long long string')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-表达式和语句"><a href="#2-3-表达式和语句" class="headerlink" title="2.3 表达式和语句"></a>2.3 表达式和语句</h3><ul><li><p>判断somelist是否为[]或””时，建议使用if not somelist来判断，而不是用if len(somelist) == 0检测长度来判断。</p></li><li><p>判断somelist为非空时，使用if somelist语句。</p></li><li><p>import语句总是放在文件开头。</p></li><li><p>文件中import模块划分为三部分，即标准库模块、第三方模块和自用模块，各部分按字母顺序排列。</p></li></ul><h3 id="2-4-注释"><a href="#2-4-注释" class="headerlink" title="2.4 注释"></a>2.4 注释</h3><h4 id="2-4-1-文档字符串"><a href="#2-4-1-文档字符串" class="headerlink" title="2.4.1 文档字符串"></a>2.4.1 文档字符串</h4><p>文档字符串是包, 模块, 类或函数里的第一个语句，是一种注释，可以通过访问<code>__doc__</code>属性，查看对象的文档字符串，或者调用help()函数来查看。</p><ul><li>文档字符串的缩进必须与定义中的所有其它语句保持一致。</li><li>使用三重双引号””” “””。</li><li>文档字符串应该包含：第一行简述功能，第二行为空行，第三行开始是具体描述。</li></ul><h4 id="2-4-2-函数和方法"><a href="#2-4-2-函数和方法" class="headerlink" title="2.4.2 函数和方法"></a>2.4.2 函数和方法</h4><p>函数的文档字符串应该包含函数做什么，输入和输出的详细描述。输入、输出等每一部分应该以一个标题行开始，标题行以冒号结尾。 除标题行外，其他内容应被缩进2个空格。</p><ul><li>Args: 列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 然后对该参数描述。</li><li>Returns: 描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略。</li><li>Raises: 列出与接口有关的所有异常。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python学习笔记（一）：Python全栈学习知识提纲与路线</title>
      <link href="/posts/88213f00.html"/>
      <url>/posts/88213f00.html</url>
      
        <content type="html"><![CDATA[<p>工作中Python作为主要开发语言，学习过一些基础，但比较零散，也常常忘记。工作中往往是有啥实现需求再去搜索相关内容。一直希望能够系统深入的学习Python及其应用，这里，简要梳理了Python的学习路线与核心知识提纲。</p><h2 id="一、Python全栈学习路线"><a href="#一、Python全栈学习路线" class="headerlink" title="一、Python全栈学习路线"></a>一、Python全栈学习路线</h2><p>Python的使用频率越来越高，应用场景很多，比如Web开发、爬虫、数据分析、数据挖掘、机器学习等等。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Note001/Python学习路线.png" alt></p><h2 id="二、Python核心知识提纲"><a href="#二、Python核心知识提纲" class="headerlink" title="二、Python核心知识提纲"></a>二、Python核心知识提纲</h2><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Note001/Python核心知识.png" alt></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据分布式集群基础环境搭建</title>
      <link href="/posts/d5114645.html"/>
      <url>/posts/d5114645.html</url>
      
        <content type="html"><![CDATA[<p>在学习大数据时，需要搭建一套分布式集群环境供学习使用。在没有足够服务器资源的情况下，这里我通过VMware虚拟机搭建一套分布式集群基础环境。</p><h2 id="1-VMware中安装CentOS7"><a href="#1-VMware中安装CentOS7" class="headerlink" title="1.VMware中安装CentOS7"></a>1.VMware中安装CentOS7</h2><p>首选需要在本地电脑上安装VMware，然后在VMware中安装CentOS。这里仅仅介绍如何在VMware中安装CentOS7。我使用的VMware版本为15.5.0，CentOS版本为：CentOS-7-x86_64-DVD-1908。</p><h3 id="1-1-下载CentOS镜像文件"><a href="#1-1-下载CentOS镜像文件" class="headerlink" title="1.1 下载CentOS镜像文件"></a>1.1 下载CentOS镜像文件</h3><p>进入<a href="https://www.centos.org/" target="_blank" rel="noopener">CentOS官网</a>，依次点击【Get CentOS Now】-&gt;【CentOS Linux DVD ISO】，进入到CentOS操作系统最新版的下载页面。如果想下载CentOS的历史版本，访问<a href="http://vault.centos.org/" target="_blank" rel="noopener">历史版本下载网站</a>，选择所需的版本下载。</p><h3 id="1-2-新建虚拟机"><a href="#1-2-新建虚拟机" class="headerlink" title="1.2 新建虚拟机"></a>1.2 新建虚拟机</h3><ul><li>Step 01：在VMware中，选择【文件】-&gt;【新建虚拟机】，打开【新建虚拟机向导】，选择【典型】配置，并进入下一步。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/d5114645/1-2-1.png" style="zoom: 40%;"></p><ul><li>Step 02：在新窗口中选择【稍后安装操作系统】，并进入下一步。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/d5114645/1-2-2.png" style="zoom:40%;"></p><ul><li>Step 03：选择客户机操作系统为【Linux】，系统版本为【CentOS 7 64位】，进入下一步。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/d5114645/1-2-3.png" style="zoom:40%;"></p><ul><li>Step 04：设置虚拟机名称和位置，并进入下一步。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/d5114645/1-2-4.png" style="zoom:40%;"></p><ul><li>Step 05：设置磁盘容量，默认为20 GB，可以根据需要调整。选择【将虚拟磁盘拆分成多个文件】，并进入下一步。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/d5114645/1-2-5.png" style="zoom:40%;"></p><ul><li>Step 06：在新窗口中，显示当前虚拟机的配置信息。可以单击【自定义硬件】对内存等配置进行调整。点击【完成】后，进入到新建的虚拟机主窗口。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/d51146451-2-6.png" style="zoom:40%;"></p><ul><li>Step 07：点击【编辑虚拟机设置】，选择【CD/DVD】，加载ISO映像文件，然后点击【确定】。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/d5114645/1-2-7.png" style="zoom:27%;"></p><h3 id="1-3-安装CentOS操作系统"><a href="#1-3-安装CentOS操作系统" class="headerlink" title="1.3 安装CentOS操作系统"></a>1.3 安装CentOS操作系统</h3><ul><li>Step 01：开启虚拟机，选择【Install CentOS 7】选项，回车开始进行安装。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/d5114645/1-3-1.png" style="zoom:40%;"></p><ul><li>Step 02：在语言选择窗口，选择【中文】。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/d5114645/1-3-2.png" style="zoom:40%;"></p><ul><li>Step 03：在安装信息摘要窗口，设置【安装位置】，这里我选择【自动配置分区】。【软件选择】这里选择了【GNOME桌面】，右侧的附加选项可以根据需要进行勾选，这里我选择了【开发工具】。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/d5114645/1-3-3.png" style="zoom:40%;"></p><ul><li>Step 04：用户设置窗口，设置了ROOT密码，并创建了一个管理员用户。配置完成后，点击【重启】，重启操作系统。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/d5114645/1-3-6.png" style="zoom:40%;"></p><h2 id="2-CentOS7集群基础环境配置"><a href="#2-CentOS7集群基础环境配置" class="headerlink" title="2.CentOS7集群基础环境配置"></a>2.CentOS7集群基础环境配置</h2><h4 id="2-1-系统环境配置"><a href="#2-1-系统环境配置" class="headerlink" title="2.1 系统环境配置"></a>2.1 系统环境配置</h4><h4 id="2-2-安装JDK"><a href="#2-2-安装JDK" class="headerlink" title="2.2 安装JDK"></a>2.2 安装JDK</h4><h4 id="2-3-克隆虚拟机"><a href="#2-3-克隆虚拟机" class="headerlink" title="2.3 克隆虚拟机"></a>2.3 克隆虚拟机</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集群环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7下MySQL安装与卸载</title>
      <link href="/posts/a85997d6.html"/>
      <url>/posts/a85997d6.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-MySQL数据库安装"><a href="#1-MySQL数据库安装" class="headerlink" title="1. MySQL数据库安装"></a>1. MySQL数据库安装</h2><h3 id="1-1-安装前准备"><a href="#1-1-安装前准备" class="headerlink" title="1.1 安装前准备"></a>1.1 安装前准备</h3><ul><li>下载并安装MySQL yum仓库</li></ul><p>访问<a href="http://repo.mysql.com/" target="_blank" rel="noopener">MySQL Yum 仓库下载页</a>，选择合适得版本下载。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 进入/usr/local/src目录下，在线下载rpm包wget http://repo.mysql.com/mysql57-community-release-el7-11.noarch.rpm#安装rpm包获得MySQL yum仓库sudo rpm -ivh mysql57-community-release-el7-11.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>选择发行版</li></ul><p>上面安装得rpm包中涵盖了多个版本的MySQL，以及一些基础组件。选择哪个版本，需要修改配置文件。这里我选择MySQL5.7，将配置文件中MySQL 5.7 Community Server的enabled属性值设为1，其余都为0</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 修改/etc/yum.repos.d/目录下的mysql-community.repo配置文件vim /etc/yum.repos.d/mysql-community.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>验证mysql5.7是否已启用</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">yum repolist enabled | grep mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-安装MySQL服务"><a href="#1-2-安装MySQL服务" class="headerlink" title="1.2 安装MySQL服务"></a>1.2 安装MySQL服务</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">yum install mysql-community-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-启动MySQL"><a href="#1-3-启动MySQL" class="headerlink" title="1.3 启动MySQL"></a>1.3 启动MySQL</h3><p>启动MySQL服务并检查状态:</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 启动MySQLsystemctl start mysqld.service#检查状态systemctl status mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-MySQL默认安装目录"><a href="#1-4-MySQL默认安装目录" class="headerlink" title="1.4 MySQL默认安装目录"></a>1.4 MySQL默认安装目录</h3><ul><li>运行脚本：在/usr/local/目录下</li><li>服务启动脚本mysqld.service：在/usr/lib/systemd/system/目录下</li><li>配置文件：/etc/my.cnf</li><li>日志文件：/var/log/mysqld.log</li><li>服务：/usr/sbin/mysqld</li></ul><h3 id="1-5-初始化root账户"><a href="#1-5-初始化root账户" class="headerlink" title="1.5 初始化root账户"></a>1.5 初始化root账户</h3><p>MySQL默认创建了‘root’@’localhost’账号，并创建了临时密码，密码打印在mysql日志中，找到并修改密码。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 获取临时密码 grep 'temporary password' /var/log/mysqld.log # 用获取的密码登录mysql -uroot -p # 登陆MySQL后，修改密码。密码规则：至少包含1个大写字母、1个小写字母、1个数字、1个特殊字符，总长度不小于8 ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-Navicat连接MySQL"><a href="#1-6-Navicat连接MySQL" class="headerlink" title="1.6 Navicat连接MySQL"></a>1.6 Navicat连接MySQL</h3><ul><li>打开服务器的3306端口</li><li>Navicat连接报错：Host ‘IP’ is not allowed to connect to this MySQL server，解决方法：</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 使用账号密码登陆mysql -uroot -p # 选择数据库 use mysql; # 允许任何主机连接 update user set host='%' where user='root'; # 刷新权限 flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：默认只允许root帐户在本地登录，如果要在其它机器上连接MySQL，必须修改root允许远程连接，如上述操作。或者添加一个允许远程连接的帐户。</p><h3 id="1-7-查看和修改密码策略"><a href="#1-7-查看和修改密码策略" class="headerlink" title="1.7 查看和修改密码策略"></a>1.7 查看和修改密码策略</h3><ul><li>查看密码策略</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">show variables like '%validate_password%';# 默认+--------------------------------------+--------+| Variable_name                        | Value  |+--------------------------------------+--------+| validate_password_check_user_name    | OFF    |    | validate_password_dictionary_file    |        || validate_password_length             | 8      |    # 密码最小长度| validate_password_mixed_case_count   | 1      |    # 密码至少要包含的小写字母个数和大写字母个数| validate_password_number_count       | 1      |    # 密码至少要包含的数字个数| validate_password_policy             | MEDIUM |    # 密码强度等级，对应等级为：0/LOW、1/MEDIUM、2/STRONG,默认为1| validate_password_special_char_count | 1      |    # 密码至少要包含的特殊字符数+--------------------------------------+--------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>修改密码策略</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 设置密码强度等级为LOWset global validate_password_policy=0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-8-MySQL用户管理"><a href="#1-8-MySQL用户管理" class="headerlink" title="1.8 MySQL用户管理"></a>1.8 MySQL用户管理</h3><ul><li>添加用户</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 选择数据库use mysql;# 创建新用户,%表示任意IP都可访问，localhost表示只有本机可以访问create user username@'%' identified by 'password';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>分配用户权限</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 命令格式：grant privilegesCode on dbName.tableName to username@host identified by "password";grant all privileges on *.* to username@'%' identified by 'password';# 刷新权限flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>privilegesCode</strong>表示授予的权限类型：all privileges（所有权限）、select（读取权限）、delete（删除权限）、update（更新权限）、create（创建权限）、drop（删除数据库、数据表权限）。</p><h2 id="2-MySQL数据库卸载"><a href="#2-MySQL数据库卸载" class="headerlink" title="2. MySQL数据库卸载"></a>2. MySQL数据库卸载</h2><ul><li>停止MySQL服务</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">systemctl stop mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>检查已安装的MySQL组件</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">yum list installed | grep mysql  # 或者用rpm -qa | grep -i mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如，在我的CentOS中已安装了以下组件：</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/article_card_img/1.png" alt></p><ul><li>卸载MySQL组件</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">yum remove mysql-community-client.x86_64 mysql-community-common.x86_64 mysql-community-devel.x86_64 mysql-community-libs.x86_64 mysql-community-libs-compat.x86_64 mysql-community-server.x86_64rpm -e --nodeps mysql57-community-release.noarch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>删除MySQL相关目录或文件</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 查找whereis mysql  # 或者用find / -name mysql进行全盘扫描# 删除查找出来的目录或文件rm -rf /usr/share/mysql /var/lib/mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除MySQL配置文件</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 删除/etc/my.cnfrm -rf /etc/my.cnf# 删除/var/log/mysqld.log，如果不删除这个文件，会导致新安装的mysql无法生存新密码，导致无法登陆rm -rf /var/log/mysqld.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>至此，基本完成了MySQL的卸载！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Superset开发环境搭建</title>
      <link href="/posts/8f56d411.html"/>
      <url>/posts/8f56d411.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Node-js安装配置"><a href="#1-Node-js安装配置" class="headerlink" title="1. Node.js安装配置"></a>1. Node.js安装配置</h2><p><strong>方式一：</strong></p><ul><li>下载源码，下载链接：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> ，这里我下载了最新版本：v12.16.0。</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 进入到/usr/local/src目录下，执行下面命令，在线下载nodejs。cd /usr/local/srcwget https://nodejs.org/dist/v12.16.0/node-v12.16.0.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>解压源码</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 解压源码tar -zxvf node-v12.16.0.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>编译安装</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">cd node-v12.16.0./configure --prefix=/usr/local/nodemakemake install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>配置环境变量</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 编辑配置文件vim /etc/profile# 设置环境变量export NODE_HOME=/usr/local/nodeexport PATH=$NODE_HOME/bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述这种方式，在编译环节比较耗时，我按照下面方式安装，使用官网提供的 二进制包进行安装。</p><p><strong>方式二：</strong></p><ul><li>下载安装包，下载地址：<a href="https://nodejs.org/dist/v12.16.0/node-v12.16.0-linux-x64.tar.gz" target="_blank" rel="noopener">https://nodejs.org/dist/v12.16.0/node-v12.16.0-linux-x64.tar.gz</a></li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 进入到/usr/local/src目录下，执行下面命令,下载编译好的安装包wget https://nodejs.org/dist/v12.16.0/node-v12.16.0-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>解压到/usr/local/目录下，并重命名为nodejs</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">tar -zxvf node-v12.16.0-linux-x64.tar.gz -C /usr/local/# 进入到/usr/local目录下，重命名mv node-v12.16.0-linux-x64 nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>添加软连接</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">ln -s /usr/local/nodejs/bin/node /usr/bin/nodeln -s /usr/local/nodejs/bin/npm  /usr/bin/npm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>验证</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">node -vnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>npm更换为淘宝镜像源</li></ul><p>npm安装插件是从国外服务器下载，受网络影响大，速度慢且可能出现异常。因此，我们使用淘宝镜像源下载插件。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">npm install -g cnpm --registry=https://registry.npm.taobao.org# 建立软连接ln -s /usr/local/nodejs/bin/cnpm  /usr/bin/cnpm# 查看cnpmcnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>安装yarn</li></ul><p>Yarn 是为了弥补npm的一些缺陷而出现，可以使用yarn相关命令进行编译。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 使用shell脚本安装yarncurl -o- -L https://yarnpkg.com/install.sh | bash# 配置使用yarn国内的源yarn config set registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-Superset开发环境配置"><a href="#2-Superset开发环境配置" class="headerlink" title="2. Superset开发环境配置"></a>2. Superset开发环境配置</h2><p>Superset开发环境配置在CentOS7，代码开发主要在Win10进行，采用Pycharm作为开发IDE，远程连接到CentOS7中配置的虚拟Python环境。</p><h3 id="2-1-安装系统依赖"><a href="#2-1-安装系统依赖" class="headerlink" title="2.1 安装系统依赖"></a>2.1 安装系统依赖</h3><p>安装以下Superset所需的系统依赖模块。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">yum install gcc gcc-c++ libffi-devel python-devel python-pip python-wheel openssl-devel cyrus-sasl-devel openldap-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-创建Python虚拟环境。"><a href="#2-2-创建Python虚拟环境。" class="headerlink" title="2.2 创建Python虚拟环境。"></a>2.2 创建Python虚拟环境。</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">pip install virtualenv# 在/usr/local/目录下创建python虚拟环境virtalenv superset_env# 虚拟环境激活与退出source superset_env/bin/activatedeactivate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-下载Superset源码"><a href="#2-3-下载Superset源码" class="headerlink" title="2.3 下载Superset源码"></a>2.3 下载Superset源码</h3><ul><li>从github上克隆Superset代码到本地，并检出指定版本，我们选择的版本为：0.25.6</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">git clone https://github.com/apache/incubator-supersetgit checkout 57e0564  # Github中版本0.28.1对应的SHA<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>Pycharm打开Superset项目文件</li></ul><p>打开项目文件，并配置Pycharm的Project Interpreter到远程服务器上创建的虚拟环境，并配置文件映射路径。比如，我的Python解释器路径为/usr/local/superset_env/bin/python，项目文件存放在/opt/incubator-superset中。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/superset_20200212/pycharm.png" alt></p><h3 id="2-4-修改元数据库"><a href="#2-4-修改元数据库" class="headerlink" title="2.4 修改元数据库"></a>2.4 修改元数据库</h3><p>Superset默认元数据库是SQLite，实际生产环境中可能需要更可靠的数据库（如MySQL、Oracle）来存储管理元数据。在编译安装前，我们先修改用MySQL替换默认的SQLite。</p><ul><li>安装依赖</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 安装在Python虚拟环境pip install mysqlclient<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>修改superset配置</li></ul><p>修改Superset配置文件config.py，我的路径为/opt/incubator-superset/superset/。</p><pre class="line-numbers language-lang-python"><code class="language-lang-python"># SQLALCHEMY_DATABASE_URI = 'sqlite:///' + os.path.join(DATA_DIR, 'superset.db')SQLALCHEMY_DATABASE_URI = 'mysql://db_user:password@db_hostname/superset?charset=utf8'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>db_user，password分别为MySQL数据库的用户名和密码，db_hostname为主机IP，superset为存储元数据的数据库，需要创建。</p><ul><li>创建superset数据库</li></ul><p>在MySQL中创建superset数据库，存储Superset的元数据。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">mysql -uroot -p   # 进入MySQL命令行create database superset;use superset;alter database superset character set utf8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-编译安装与初始化"><a href="#2-5-编译安装与初始化" class="headerlink" title="2.5 编译安装与初始化"></a>2.5 编译安装与初始化</h3><ul><li>编译</li></ul><p>激活Python虚拟环境，切换到/opt/incubator-superset/superset/assets目录下，执行以下命令进行编译。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(superset_env) [root@centos assets]# yarn(superset_env) [root@centos assets]# yarn run build    // npm run build  npm run dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>安装</li></ul><p>在安装过程中会安装各种Python依赖包，可能会报错，主要是依赖包版本问题或者找不到依赖包，需要针对报错提示进行安装。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 切换到/opt/incubator-superset/目录下(superset_env) [root@centos incubator-superset]# python setup.py install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可能会报错：Not a directory: ‘../superset/static/assets/package.json’</p><p>解决办法：删除”../superset/static/“目录下的assets文件，并将”../superset/“下的assets文件夹复制到”../superset/static/“目录下。</p><ul><li>初始化</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 创建创建管理员用户，根据提示输如用户名、邮箱、密码(superset_env) [root@centos incubator-superset]# fabmanager create-admin --app superset# 初始化数据库(superset_env) [root@centos incubator-superset]# superset db upgrade# 加载示例数据(superset_env) [root@centos incubator-superset]# superset load_examples# 初始化角色和权限(superset_env) [root@centos incubator-superset]# superset init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-启动Superset"><a href="#2-6-启动Superset" class="headerlink" title="2.6 启动Superset"></a>2.6 启动Superset</h3><p>可以采用以下两种方式启动。</p><p>方式一：在项目文件incubator-superset/superset/目录下新建run.py文件，文件内容为：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">from superset import appapp.run(debug=True, host='0.0.0.0', port=8088)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Pycharm运行run.py文件，访问Superset。由于我的Superset环境部署在CentOS服务器上，在本地访问：IP:8088。</p><p>方式二：命令行启动</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">(superset_env) [root@centos incubator-superset]# superset runserver -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 可视化工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Superset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git安装配置与基本使用</title>
      <link href="/posts/c6c40a41.html"/>
      <url>/posts/c6c40a41.html</url>
      
        <content type="html"><![CDATA[<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。我们在CentOS7环境下安装配置Git，并学习Git的基本操作。</p><h2 id="1-Git安装配置"><a href="#1-Git安装配置" class="headerlink" title="1. Git安装配置"></a>1. Git安装配置</h2><h3 id="1-1-Git安装"><a href="#1-1-Git安装" class="headerlink" title="1.1 Git安装"></a>1.1 Git安装</h3><h4 id="1-1-1-检查是否安装"><a href="#1-1-1-检查是否安装" class="headerlink" title="1.1.1 检查是否安装"></a>1.1.1 检查是否安装</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[root@centos ~]# git-bash: git: command not found  # 系统中未安装<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-1-2-在线安装Git"><a href="#1-1-2-在线安装Git" class="headerlink" title="1.1.2 在线安装Git"></a>1.1.2 在线安装Git</h4><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 在线安装yum install -y git# 查看安装版本git --version# 通过该种方式安装的版本可能较旧，我们卸载git，用下面源码方式进行安装yum remove git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-3-源码安装Git"><a href="#1-1-3-源码安装Git" class="headerlink" title="1.1.3 源码安装Git"></a>1.1.3 源码安装Git</h4><ul><li>下载Git特定版本，我们下载v2.24.1。</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 在线下载到/usr/local/src目录下wget https://github.com/git/git/archive/v2.24.1.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>安装依赖</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>安装Git</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 解压Git安装包到/usr/local/目录tar -zxvf v2.24.1.tar.gz -C /usr/local# 进入到解压目录cd git-2.24.1# 编译并安装Git，安装在/usr/local/git目录下make prefix=/usr/local/git allsudo make prefix=/usr/local/git install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>配置环境变量</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 编辑环境配置文件vim /etc/profile# 配置文件末尾添加export PATH=/usr/local/git/bin:$PATH# 生效source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>验证安装是否成功</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-Git配置，生成授权证书"><a href="#1-2-Git配置，生成授权证书" class="headerlink" title="1.2 Git配置，生成授权证书"></a>1.2 Git配置，生成授权证书</h3><p>公钥是代码托管服务(CodeHub)识别用户身份的一种认证方式。通过公钥，可以将本地git项目与代码托管服务(CodeHub)建立联系，可以将本地代码上传到代码托管服务(CodeHub)或者将代码托管服务(CodeHub)代码下载到本地。</p><ul><li>配置用户名和邮箱</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">git config --global user.name "Github的用户名"git config --global user.email "Github的注册邮箱"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>查看设置的信息</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">git config --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>检查是否已经有ssh秘钥</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[root@centos ~]# cd ~/.ssh[root@centos .ssh]# lsauthorized_keys  id_rsa  id_rsa.pub  known_hosts# 如果有id_rsa和id_rsa.pub文件，不需要再创建ssh key，如果没有则执行下一步<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>创建ssh key</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">ssh-keygen -t rsa -C "git的邮箱"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将id_rsa.pub中的公钥添加到Github中</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 复制id_rsa.pub文件内容cat ~/.ssh/id_rsa.pub# 添加到Github SSH keys：登录Github，点击Settings->点击New SSH key->添加ssh key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>测试是否配置成功</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HUE部署与使用</title>
      <link href="/posts/357898e8.html"/>
      <url>/posts/357898e8.html</url>
      
        <content type="html"><![CDATA[<p>HUE是一个开源的Apache Hadoop UI系统，基于Python Web框架Django实现。HUE是一个Web应用，设计初衷是简化用户和Hadoop集群间的交互。Hue几乎可以支持所有大数据框架：HDFS，HIVE，HBASE，Zookeeper，Sqoop2等。基于HUE图形化界面，可以操作HDFS的数据，执行Hive的SQL语句，浏览HBase数据库等等。Hue通过把这些大数据技术栈整合在一起，通过统一的Web UI来访问和管理，极大地提高了大数据用户和管理员的工作效率。</p><h2 id="1-HUE安装与部署"><a href="#1-HUE安装与部署" class="headerlink" title="1. HUE安装与部署"></a>1. HUE安装与部署</h2><h3 id="1-1-安装依赖包"><a href="#1-1-安装依赖包" class="headerlink" title="1.1 安装依赖包"></a>1.1 安装依赖包</h3><p>HUE安装之前需要安装配置好Python、MySQL、Java等环境，并安装以下依赖包。我的部署系统为CentOS7。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo yum -y install ant asciidoc cyrus-sasl-devel cyrus-sasl-gssapi cyrus-sasl-plain gcc gcc-c++ krb5-devel libtidy libxml2-devel libxslt-devel openldap-devel python-devel sqlite-devel openssl-devel mysql-devel gmp-devel<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>maven安装</li></ul><p>HUE编译时会用到maven，可以单独下安装包进行安装，也可以使用yum来安装。这里，我们通过安装包进行安装。下载maven安装包，下载地址：<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a> ，我下载的版本为3.6.3。</p><p>将安装包移动到/usr/local/src目录下，并解压到/usr/local/目录下，重命名为maven。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 解压到/usr/local/目录下tar -zxvf apache-maven-3.6.3-bin.tar.gz -C /usr/local/# 在/usr/local目录下，重命名maven解压包mv apache-maven-3.6.3 maven<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置环境变量：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 编辑/etc/profile文件vim /etc/profile# 添加maven环境变量MAVEN_HOME=/usr/local/mavenexport PATH=$PATH:$MAVEN_HOME/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令，使修改的环境变量文件生效。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证是否配置成功：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[root@centos local]# mvn -vApache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)Maven home: /usr/local/maven<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-2-安装HUE"><a href="#1-2-安装HUE" class="headerlink" title="1.2 安装HUE"></a>1.2 安装HUE</h3><p>下载HUE安装包，我这里下载的是CDH版本，下载地址：<a href="http://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/</a></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 将安装包解压到/usrl/local目录下，并重命名为huesudo tar -zxvf hue-3.9.0-cdh5.16.2.tar.gz -C /usr/local/# 重命名为huesudo mv hue-3.9.0-cdh5.16.2 hue# 修改/usr/local/hue目录所有者，授予hue用户权限sudo chown -R hue:hue /usr/local/hue# 使用普通用户hue编译，进入到hue目录下，执行以下命令make apps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-HUE配置"><a href="#1-3-HUE配置" class="headerlink" title="1.3 HUE配置"></a>1.3 HUE配置</h3><h4 id="1-3-1-HUE自身配置"><a href="#1-3-1-HUE自身配置" class="headerlink" title="1.3.1 HUE自身配置"></a>1.3.1 HUE自身配置</h4><p>进入到/usr/local/hue/desktop/conf/目录下，编辑配置文件hue.ini，修改以下几个参数。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># Set this to a random string, the longer the better.# This is used for secure hashing in the session store.secret_key=jFE93j;2[290-eiw.KEiwN2s3['d;/.q[eIW^y#e=+Iei*@Mn<qW5o# Webserver listens on this address and porthttp_host=0.0.0.0http_port=8888# Time zone nametime_zone=Asia/Shanghai<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>secret_key需要设置，不能为空，可参考<a href="http://archive.cloudera.com/cdh5/cdh/5/hue-3.9.0-cdh5.16.2/admin-manual/manual.html#web-server-configuration" target="_blank" rel="noopener">Hue Administration Guide</a>中Specifying the Secret Key部分。</p><h4 id="1-3-2-HUE与Hadoop集成配置"><a href="#1-3-2-HUE与Hadoop集成配置" class="headerlink" title="1.3.2 HUE与Hadoop集成配置"></a>1.3.2 HUE与Hadoop集成配置</h4><h5 id="1-3-2-1-修改Hadoop配置文件"><a href="#1-3-2-1-修改Hadoop配置文件" class="headerlink" title="1.3.2.1 修改Hadoop配置文件"></a>1.3.2.1 修改Hadoop配置文件</h5><ul><li>配置hdfs-site.xml文件</li></ul><p>进入到/usr/local/hadoop/etc/hadoop目录下，编辑hdfs-site.xml，添加如下内容：</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><property>    <name>dfs.webhdfs.enabled</name>    <value>true</value></property><property>    <name>dfs.permissions.enabled</name>    <value>false</value></property><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>配置core-site.xml文件</li></ul><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><property>    <name>hadoop.proxyuser.hue.hosts</name>    <value>*</value></property><property>    <name>hadoop.proxyuser.hue.groups</name>    <value>*</value></property><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>配置httpfs-site.xml文件</li></ul><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><property>    <name>httpfs.proxyuser.hue.hosts</name>    <value>*</value></property><property>    <name>httpfs.proxyuser.hue.groups</name>    <value>*</value></property><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>配置yarn-site.xml文件</li></ul><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><property>    <name>yarn.log-aggregation-enable</name>    <value>true</value></property><property>    <name>yarn.log-aggregation.retain-seconds</name>    <value>432000</value></property><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-2-2-修改HUE配置文件"><a href="#1-3-2-2-修改HUE配置文件" class="headerlink" title="1.3.2.2 修改HUE配置文件"></a>1.3.2.2 修改HUE配置文件</h5><p>修改HUE配置文件hue.ini，配置HDFS和YARN。</p><ul><li>配置HDFS</li></ul><pre class="line-numbers language-lang-ini"><code class="language-lang-ini">[hadoop]  # Configuration for HDFS NameNode  # ------------------------------------------------------------------------  [[hdfs_clusters]]    # HA support by using HttpFs    [[[default]]]      # Enter the filesystem uri      fs_defaultfs=hdfs://centos:8020         # NameNode logical name.      ## logical_name=      # Use WebHdfs/HttpFs as the communication mechanism.      # Domain should be the NameNode or HttpFs host.      # Default port is 14000 for HttpFs.      webhdfs_url=http://centos:50070/webhdfs/v1      # Change this if your HDFS cluster is Kerberos-secured      ## security_enabled=false      # In secure mode (HTTPS), if SSL certificates from YARN Rest APIs      # have to be verified against certificate authority      ## ssl_cert_ca_verify=True      # Directory of the Hadoop configuration      hadoop_conf_dir=/usr/local/hadoop/etc/hadoop      hadoop_hdfs_home=/usr/local/hadoop      hadoop_bin=/usr/local/hadoop/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>配置Yarn</li></ul><pre class="line-numbers language-lang-ini"><code class="language-lang-ini"># Configuration for YARN (MR2)  # ------------------------------------------------------------------------  [[yarn_clusters]]    [[[default]]]      # Enter the host on which you are running the ResourceManager      resourcemanager_host=centos      # The port where the ResourceManager IPC listens on      resourcemanager_port=8032      # Whether to submit jobs to this cluster      submit_to=True      # Resource Manager logical name (required for HA)      ## logical_name=      # Change this if your YARN cluster is Kerberos-secured      ## security_enabled=false      # URL of the ResourceManager API      resourcemanager_api_url=http://centos:8088      # URL of the ProxyServer API      proxy_api_url=http://centos:8088      # URL of the HistoryServer API      history_server_api_url=http://centos:19888      # URL of the Spark History Server      ## spark_history_server_url=http://localhost:18088      # In secure mode (HTTPS), if SSL certificates from YARN Rest APIs      # have to be verified against certificate authority      ## ssl_cert_ca_verify=True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-3-HUE与Hive集成配置"><a href="#1-3-3-HUE与Hive集成配置" class="headerlink" title="1.3.3 HUE与Hive集成配置"></a>1.3.3 HUE与Hive集成配置</h4><p> 进入到/usr/local/hue/desktop/conf目录下，修改HUE配置文件hue.ini，修改内容如下：</p><pre class="line-numbers language-lang-ini"><code class="language-lang-ini">############################################################################ Settings to configure Beeswax with Hive###########################################################################[beeswax]  # Host where HiveServer2 is running.  # If Kerberos security is enabled, use fully-qualified domain name (FQDN).  hive_server_host=centos  # Port where HiveServer2 Thrift server runs on.  hive_server_port=10000  # Hive configuration directory, where hive-site.xml is located  hive_conf_dir=/usr/local/hive/conf  # Timeout in seconds for thrift calls to Hive service  ## server_conn_timeout=120<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 启动hive服务：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">nohup bin/hive --service metastore &nohup bin/hive --service hiveserver2 &<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-3-4-HUE与MySQL集成配置"><a href="#1-3-4-HUE与MySQL集成配置" class="headerlink" title="1.3.4 HUE与MySQL集成配置"></a>1.3.4 HUE与MySQL集成配置</h4><p>修该HUE配置文件HUE.ini，修改内容如下：</p><pre class="line-numbers language-lang-ini"><code class="language-lang-ini">## [[[mysql]]]# Name to show in the UI.engine=mysqlhost=IPport=3306user=huepassword=Hue1234!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-5-HUE与HBase集成配置"><a href="#1-3-5-HUE与HBase集成配置" class="headerlink" title="1.3.5 HUE与HBase集成配置"></a>1.3.5 HUE与HBase集成配置</h4><p>待补充。。。</p><h4 id="1-3-6-HUE元数据库修改为MySQL"><a href="#1-3-6-HUE元数据库修改为MySQL" class="headerlink" title="1.3.6 HUE元数据库修改为MySQL"></a>1.3.6 HUE元数据库修改为MySQL</h4><p>HUE默认使用SQLite作为元数据库，不推荐在生产环境中使用这个数据库。这里介绍将MySQL作为元数据库。</p><ul><li>创建hue数据库</li></ul><p>在MySQL中创建一个hue数据库：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">mysql> create database hue;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>修改配置文件HUE.ini</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[[database]]    engine=mysql    host=IP    port=3306    user=hue    password=Hue1234!    name=hue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>初始化数据库</li></ul><p>进入到/usr/local/hue/build/env/bin目录下，执行以下命令：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">./hue syncdb./hue migrate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>未完待续。。。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive入门教程</title>
      <link href="/posts/73248e8e.html"/>
      <url>/posts/73248e8e.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Hive是一个构建在Hadoop之上的数据仓库基础架构，它可以将结构化的数据文件映射成表，并提供类SQL查询功能。可以将SQL语句转化为MapReduce任务，并在Hadoop上进行运行，以此来完成整个的数据的提取、转化和加载（Extract-Transform-Load，ETL），减少直接编写MapReduce的复杂度。</p><p>Hive主要有两方面的用途：一是作为大数据统计分析工具，Hive为数据的查询、处理和分析提供了友好的接口；二是作为数据仓库构建工具，在Hadoop的分布式文件系统（HDFS）中加载和转换非结构化、结构化或半结构化数据。</p><p>特点：</p><ul><li>操作简单，学习成本低：Hive提供类似SQL的声明性语言，即HQL，使得熟悉SQL的用户可以很快上手进行大数据分析。</li><li>封装程度高、扩展性强：Hive将很多数据统计逻辑封装成了可直接使用的函数，且支持自定义函数来进行扩展。</li><li>统一的元数据管理：可以与 presto / impala／sparksql 等共享数据。</li><li>执行延迟高：不适合做数据的实时处理，但适合做海量数据的离线处理。</li></ul><h2 id="二、Hive体系架构"><a href="#二、Hive体系架构" class="headerlink" title="二、Hive体系架构"></a>二、Hive体系架构</h2><h3 id="2-1-Hive架构组件"><a href="#2-1-Hive架构组件" class="headerlink" title="2.1 Hive架构组件"></a>2.1 Hive架构组件</h3><p>Hive体系架构包括如下组件：用户访问接口（CLI、JDBC/ODBC Client、WUI）、Thrift Server、元数据Metastore、Driver组件（Complier、Optimizer和Executor），如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/hive_20200208/Hive体系架构.jpg" style="zoom:50%;"></p><ul><li>用户访问接口</li></ul><p>用户访问接口主要有三种：CLI、JDBC/ODBC客户端和WUI。CLI启动时，会同时启动一个Hive副本。JDBC/ODBC客户端是Hive基于JDBC或ODBC驱动的客户端，通过JDBC或ODBC驱动，连接至Thrift Server。WUI是通过浏览器访问Hive。</p><ul><li>Thrift Server</li></ul><p>提供JDBC和ODBC接入的能力,用来进行可扩展且跨语言的服务的开发，hive集成了该服务，能让不同的编程语言调用hive的接口。</p><ul><li>Driver组件</li></ul><p>是Hive的核心组件，包括Complier、Executor和Optimizer，主要作用是对HQL查询语句进行解析、编译、优化，并生成执行计划，然后存储在HDFS，调用MapReduce计算框架执行。</p><ul><li>元数据Metastore</li></ul><p>存储Hive的元数据，包括表的名字、表的列和分区及其属性，表的属性(是否为外部表等)，表的数据所在目录等。Hive元数据存储在关系数据库中，支持mysql、derby、oracle等数据库。</p><ul><li><p>数据存储</p><p>Hive的数据存储在HDFS中，大部分的查询、计算由MapReduce完成。</p></li></ul><h3 id="2-2-Hive的HQL执行过程"><a href="#2-2-Hive的HQL执行过程" class="headerlink" title="2.2 Hive的HQL执行过程"></a>2.2 Hive的HQL执行过程</h3><p>HQL查询的执行过程主要是由解释器、编译器、优化器完成HQL查询语句从词法分析、语法分析、编译、优化以及查询计划的生成。生成的查询计划存储在HDFS中，并在随后又MapReduce调用生成。具体主要包括以下三步：</p><p>步骤1：Hive通过CLI、JDBC/ODBC，或HWI接入相关查询。</p><p>步骤2：通过Driver (Complier、Optimizer和Executor)，进行编译，分析优化，最后变成可执行的MapReduce。</p><p>步骤3：将生成的MapReduce查询任务提交Hadoop执行。</p><p>HQL解析和执行过程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/hive_20200208/HQL解析执行过程.jpg" style="zoom: 50%;"></p><h3 id="2-3-数据库连接模式"><a href="#2-3-数据库连接模式" class="headerlink" title="2.3 数据库连接模式"></a>2.3 数据库连接模式</h3><p> Hive将元数据存储在RDBMS中，有三种模式可以连接到数据库：</p><ul><li>单用户模式</li></ul><p>此模式连接到一个In-memory 的数据库Derby，Derby是Hive自带的数据库，默认只能有一个连接，用户连接到Hive后，会在当前目录生成一个metastore文件来存放操作元数据信息，不同的用户连接到Hive看到的信息不一致。</p><ul><li>多用户模式</li></ul><p>通过网络连接到一个关系型数据库中，如MySQL，是最经常使用到的模式。这样多个用户操作的元数据信息统一存放到关系型数据库，这样不同用户可以操作相同的对象。</p><ul><li>远程服务器模式</li></ul><p>用于非Java客户端访问元数据库，在服务器端启动MetaStoreServer，客户端利用Thrift协议通过MetaStoreServer访问元数据库。</p><h2 id="三、Hive的数据类型和文件格式"><a href="#三、Hive的数据类型和文件格式" class="headerlink" title="三、Hive的数据类型和文件格式"></a>三、Hive的数据类型和文件格式</h2><h3 id="3-1-数据类型"><a href="#3-1-数据类型" class="headerlink" title="3.1 数据类型"></a>3.1 数据类型</h3><p>Hive支持的数据类型分为两类，即基本数据类型和复杂数据类型。</p><h4 id="3-1-1-基本数据类型"><a href="#3-1-1-基本数据类型" class="headerlink" title="3.1.1 基本数据类型"></a>3.1.1 基本数据类型</h4><div class="table-container"><table><thead><tr><th>数据类型</th><th>长度</th><th>示例</th></tr></thead><tbody><tr><td>TINYINT</td><td>1byte有符号整数</td><td>10</td></tr><tr><td>SMALLINT</td><td>2byte有符号整数</td><td>10</td></tr><tr><td>INT</td><td>4byte有符号整数</td><td>10</td></tr><tr><td>BIGINT</td><td>8byte有符号整数</td><td>10</td></tr><tr><td>BOOLEAN</td><td>布尔类型，true或者false</td><td>TRUE</td></tr><tr><td>FLOAT</td><td>单精度浮点数</td><td>3.1415</td></tr><tr><td>DOUBLE</td><td>双精度浮点数</td><td>3.1415</td></tr><tr><td>STRING</td><td>字符序列</td><td>“Hello World”</td></tr><tr><td>TIMESTAMP</td><td>时间类型</td><td>“2020-02-10 00:00:00”</td></tr></tbody></table></div><h4 id="3-1-2-复杂数据类型"><a href="#3-1-2-复杂数据类型" class="headerlink" title="3.1.2 复杂数据类型"></a>3.1.2 复杂数据类型</h4><div class="table-container"><table><thead><tr><th>数据类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>STRUCT</td><td>和C语言中的STRUCT类似，都可以通过“点”符号访问元素内容。</td><td>STRUCT(‘John’,’Doe’)</td></tr><tr><td>MAP</td><td>MAP是一组键-值对元组集合，使用数组表示法（例如[‘key’]）可以访问元素。</td><td>MAP(‘first’,’John’,’last’,’Doe’)</td></tr><tr><td>ARRAY</td><td>数组是一组具有相同类型和名称的变量的集合，通过下标进行访问。</td><td>ARRAY(‘John’,’Doe’)</td></tr></tbody></table></div><h3 id="3-2-记录和字段分隔符"><a href="#3-2-记录和字段分隔符" class="headerlink" title="3.2 记录和字段分隔符"></a>3.2 记录和字段分隔符</h3><p>Hive中默认记录和字段分隔符：</p><div class="table-container"><table><thead><tr><th>分隔符</th><th>描述</th></tr></thead><tbody><tr><td>\n</td><td>对于文本文件来说，每行都是一条记录，因此换行符可以分割记录</td></tr><tr><td>^A</td><td>用于分隔字段（列）,在CREATE TABLE 语句中可以使用八进制编码”\001”表示</td></tr><tr><td>^B</td><td>用于分隔ARRAY或者STRUCT中的元素，或用于MAP中键值对之间的分隔，在CREATE TABLE语句中可以使用八进制”\002”表示</td></tr><tr><td>^C</td><td>用于MAP中键和值之间的分割。在CREATE TABLE语句中可以使用八进制编码\003表示</td></tr></tbody></table></div><h3 id="3-3-文件格式"><a href="#3-3-文件格式" class="headerlink" title="3.3 文件格式"></a>3.3 文件格式</h3><div class="table-container"><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>TEXTFILE</td><td>行存储。Hive的默认文件格式，数据默认不做压缩，磁盘开销大，数据解析开销大。</td></tr><tr><td>SEQUENCEFILE</td><td>数据以二进制键值对格式存储，是Hadoop API提供的一种二进制文件支持，其具有使用方便、可分割、可压缩的特点。</td></tr><tr><td>RCFILE</td><td>行列存储相结合的存储方式，1.其将数据按行分块，保证同一个record在一个块上，避免读一个记录需要读取多个block。2.块数据列式存储，有利于数据压缩和快速的列存取。</td></tr><tr><td>PARQUET</td><td>列存储。通过按列进行高效压缩和特殊的编码技术，从而在降低存储空间的同时提高了 IO 效率。</td></tr></tbody></table></div><h2 id="四、Hive的常用DDL操作"><a href="#四、Hive的常用DDL操作" class="headerlink" title="四、Hive的常用DDL操作"></a>四、Hive的常用DDL操作</h2><h3 id="4-1-数据库操作"><a href="#4-1-数据库操作" class="headerlink" title="4.1 数据库操作"></a>4.1 数据库操作</h3><h4 id="4-1-1-创建数据库"><a href="#4-1-1-创建数据库" class="headerlink" title="4.1.1 创建数据库"></a>4.1.1 创建数据库</h4><ul><li>语法</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">CREATE DATABASE [IF NOT EXISTS] db_name  --不加IF NOT EXISTS，如果创建的数据库存在，则会报异常[LOCATION hdfs_path];    --可指定hive数据库存储在HDFS上的位置，默认位置是在HDFS上的目录/user/hive/warehouse下面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>示例</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">CREATE DATABASE IF NOT EXISTS test_db;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-1-2-查看数据库"><a href="#4-1-2-查看数据库" class="headerlink" title="4.1.2 查看数据库"></a>4.1.2 查看数据库</h4><ul><li>语法</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">--查看所有的数据库SHOW DATABASES;-- 查看指定数据库的信息DESC DATABASE db_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>示例</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">-- 查看所有的数据库，test_db为上一步创建的数据库0: jdbc:hive2://localhost:10000> SHOW DATABASES;+----------------+--+| database_name  |+----------------+--+| default        || test_db        |+----------------+--+2 rows selected (0.02 seconds)-- 查看指定数据库的信息0: jdbc:hive2://localhost:10000> DESC DATABASE test_db;+----------+----------+----------------------------------------------------+-------------+-------------+-------------+--+| db_name  | comment  |                      location                      | owner_name  | owner_type  | parameters  |+----------+----------+----------------------------------------------------+-------------+-------------+-------------+--+| test_db  |          | hdfs://localhost:8020/user/hive/warehouse/test_db.db | root        | USER        |             |+----------+----------+----------------------------------------------------+-------------+-------------+-------------+--+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-1-3-切换数据库"><a href="#4-1-3-切换数据库" class="headerlink" title="4.1.3 切换数据库"></a>4.1.3 切换数据库</h4><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">USE db_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-1-4-删除数据库"><a href="#4-1-4-删除数据库" class="headerlink" title="4.1.4 删除数据库"></a>4.1.4 删除数据库</h4><ul><li>语法</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">DROP DATABASE [IF EXISTS] db_name [RESTRICT|CASCADE];-- 默认行为是RESTRICT，如果数据库不是空的,则删除失败。如果要删除数据库及其中的表，则使用CASCADE。IF EXISTS可选，如果不加，当数据库不存在时，删除会报错。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>示例</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">DROP DATABASE test_db;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-2-表操作"><a href="#4-2-表操作" class="headerlink" title="4.2 表操作"></a>4.2 表操作</h3><h4 id="4-2-1-创建表"><a href="#4-2-1-创建表" class="headerlink" title="4.2.1 创建表"></a>4.2.1 创建表</h4><h5 id="4-2-1-1-内部表（管理表）"><a href="#4-2-1-1-内部表（管理表）" class="headerlink" title="4.2.1.1 内部表（管理表）"></a>4.2.1.1 内部表（管理表）</h5><ul><li>语法</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">CREATE  TABLE [IF NOT EXISTS] tbl_name(col_name data_type,...)[ROW FORMAT row_format] -- 指定分隔符[STORED AS file_format] -- 设置存储文件格式[LOCATION hdfs_path]    -- 指定表的存储位置/*ROW FORMAT DELIMITED  分隔符设置开始语句FIELDS TERMINATED BY ‘\001’  设置字段与字段之间的分隔符COLLECTION ITEMS TERMINATED BY ‘\002’  设置一个复杂类型（array,struct)字段的各个item之间的分隔符MAP KEYS TERMINATED BY '\003'   设置一个复杂类型(Map)字段的key、value之间的分隔符LINES TERMINATED BY： 设置行与行之间的分隔符*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>示例</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">/*CREATE TABLE Product(product_id INT, product_name STRING, product_type STRING, sale_price DOUBLE)ROW FORMAT DELIMITEDFIELDS TERMINATED BY ',';*/0: jdbc:hive2://localhost:10000> use test_db;0: jdbc:hive2://localhost:10000> CREATE TABLE Product. . . . . . . . . . . . . . . .> (product_id INT,. . . . . . . . . . . . . . . .>  product_name STRING,. . . . . . . . . . . . . . . .>  product_type STRING,. . . . . . . . . . . . . . . .>  sale_price DOUBLE). . . . . . . . . . . . . . . .> ROW FORMAT DELIMITED. . . . . . . . . . . . . . . .> FIELDS TERMINATED BY ',';0: jdbc:hive2://localhost:10000> desc product;  -- 查看表信息+---------------+------------+----------+--+|   col_name    | data_type  | comment  |+---------------+------------+----------+--+| product_id    | int        |          || product_name  | string     |          || product_type  | string     |          || sale_price    | double     |          |+---------------+------------+----------+--+0: jdbc:hive2://localhost:10000> show create table product;  --查看table的存储路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建表后，hive会在仓库目录中建一个表目录： /user/hive/warehouse/test_db.db/product。</p><p>删除内部表时，元数据和数据都会被删除。</p><h5 id="4-2-1-2-外部表"><a href="#4-2-1-2-外部表" class="headerlink" title="4.2.1.2 外部表"></a>4.2.1.2 外部表</h5><ul><li>语法</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">CREATE EXTERNAL TABLE [IF NOT EXISTS] tbl_name(col_name data_type,...)[ROW FORMAT row_format] -- 指定分隔符[STORED AS file_format] -- 设置存储文件格式[LOCATION hdfs_path]    -- 指定表的存储位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>示例</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">0: jdbc:hive2://localhost:10000> CREATE EXTERNAL TABLE Product_E   -- 创建外部表. . . . . . . . . . . . . . . .> (product_id INT,. . . . . . . . . . . . . . . .>  product_name STRING,. . . . . . . . . . . . . . . .>  product_type STRING,. . . . . . . . . . . . . . . .>  sale_price DOUBLE). . . . . . . . . . . . . . . .> ROW FORMAT DELIMITED. . . . . . . . . . . . . . . .> FIELDS TERMINATED BY ','. . . . . . . . . . . . . . . .> LOCATION '/user/hive/external/product_e';   -- 指定存储路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除外部表时，只删除metastore上的元数据，不删除HDFS中的表数据。</p><h5 id="4-2-1-3-分区表"><a href="#4-2-1-3-分区表" class="headerlink" title="4.2.1.3 分区表"></a>4.2.1.3 分区表</h5><p>分区表一般在数据量比较大，且有明确的分区字段时使用。根据分区字段将数据分子目录存储，用分区字段作为查询条件查询效率会比较高。</p><ul><li>语法</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">CREATE  TABLE [IF NOT EXISTS] tbl_name(col_name data_type,...)[PARTITIONED BY (col_name data_type, ...)]  -- 分区表分区规则[ROW FORMAT row_format] -- 指定分隔符[STORED AS file_format] -- 设置存储文件格式[LOCATION hdfs_path]    -- 指定表的存储位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>示例</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">0: jdbc:hive2://localhost:10000> CREATE TABLE Product_p. . . . . . . . . . . . . . . .> (product_id INT,. . . . . . . . . . . . . . . .>  product_name STRING,. . . . . . . . . . . . . . . .>  product_type STRING,. . . . . . . . . . . . . . . .>  sale_price DOUBLE). . . . . . . . . . . . . . . .> PARTITIONED BY  (city STRING) -- 按照城市进行分区. . . . . . . . . . . . . . . .> ROW FORMAT DELIMITED. . . . . . . . . . . . . . . .> FIELDS TERMINATED BY ',';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2-2-修改表"><a href="#4-2-2-修改表" class="headerlink" title="4.2.2 修改表"></a>4.2.2 修改表</h4><ul><li>修改表名</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">ALTER TABLE tbl_name_old RENAME TO tbl_name_new/*tbl_name_old: 原表tbl_name_new: 重命名后的表*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>修改字段</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">/*col_name_old: 原字段名col_name_new: 新字段名data_type_new: 新字段类型col_comment: 字段注释FIRST: 将字段放在第一列AFTER: 将字段放在col_name之后 */ALTER TABLE tbl_name CHANGE [COLUMN] col_name_old col_name_new data_type_new[CONMMENT col_comment][FIRST|AFTER col_name];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>添加字段</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">ALTER TABLE tbl_name ADD COLUMNS (col_name data_type,...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-2-3-清空-删除表"><a href="#4-2-3-清空-删除表" class="headerlink" title="4.2.3 清空/删除表"></a>4.2.3 清空/删除表</h4><ul><li>清空内部表的数据</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">-- 清空整个表或表指定分区中的数据TRUNCATE TABLE tbl_name [PARTITION (partition_column = partition_col_value,  ...)];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>目前，TRUNCATE只能用于内部表的清空操作，用于外部表会抛出异常。</p><ul><li>删除表</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">DROP TABLE tbl_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>内部表：不仅会删除表的元数据，同时会删除 HDFS 上的数据。</p><p>外部表：只会删除表的元数据，不会删除 HDFS 上的数据。</p><p>删除视图引用的表时，不会给出警告（但视图已经无效了，必须由用户删除或重新创建）。</p><h4 id="4-2-4-查看表"><a href="#4-2-4-查看表" class="headerlink" title="4.2.4 查看表"></a>4.2.4 查看表</h4><ul><li>查看表信息</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">DESC [EXTENDED|FORMATTED] tbl_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看表列表</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SHOW TABLES [IN database_name];-- 可以指定查看database_name中的表列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>查看表的分区列表</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SHOW PARTITIONS tbl_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看表的创建语句</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SHOW CREATE TABLE tbl_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="五、Hive的常用DML操作"><a href="#五、Hive的常用DML操作" class="headerlink" title="五、Hive的常用DML操作"></a>五、Hive的常用DML操作</h2><h3 id="5-1-导入数据到表"><a href="#5-1-导入数据到表" class="headerlink" title="5.1 导入数据到表"></a>5.1 导入数据到表</h3><ul><li>语法</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">LOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] INTO TABLE tbl_name [PARTITION (partcol1=val1,...)]/*LOCAL: 表示从本地导入数据，缺省则表示从HDFS中导入。filepath: 数据文件路径或目录，建议使用绝对路径。OVERWRITE: 删除原表中的数据，添加新的数据，缺省则表示在原表中追加。*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>示例</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">-- 从本地导入LOAD DATA LOCAL INPATH '/opt/product1.txt' INTO TABLE product_p PARTITION (city='Shanghai');LOAD DATA LOCAL INPATH '/opt/product2.txt' INTO TABLE product_p PARTITION (city='Jiangsu');-- 查看导入的数据0: jdbc:hive2://localhost:10000> SELECT * FROM product_p where city='Jiangsu';+-----------------------+-------------------------+-------------------------+-----------------------+-----------------+--+| product_p.product_id  | product_p.product_name  | product_p.product_type  | product_p.sale_price  | product_p.city  |+-----------------------+-------------------------+-------------------------+-----------------------+-----------------+--+| 1                     | T恤                      | 衣服                      | 70.0                  | Jiangsu         || 2                     | 尺子                      | 办公用品                    | 12.0                  | Jiangsu         || 3                     | 牛仔裤                     | 衣服                      | 180.0                 | Jiangsu         || 4                     | 手机                      | 电子产品                    | 5500.0                | Jiangsu         || 5                     | 钢笔                      | 办公用品                    | 35.0                  | Jiangsu         || 6                     | 风衣                      | 衣服                      | 350.0                 | Jiangsu         || 7                     | 笔记本电脑                   | 电子产品                    | 7000.0                | Jiangsu         |+-----------------------+-------------------------+-------------------------+-----------------------+-----------------+--+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-插入数据到表"><a href="#5-2-插入数据到表" class="headerlink" title="5.2 插入数据到表"></a>5.2 插入数据到表</h3><ul><li>语法</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">INSERT OVERWRITE TABLE tbl_name [PARTITION (partcol1=val1, ...)] select_statement FROM from_statement;-- INSERT OVERWRITE会覆盖原数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">INSERT INTO TABLE tbl_name [PARTITION (partcol1=val1, ...)] select_statement FROM from_statement;-- INSERT INTO在原数据后追加<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>示例</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">INSERT INTO TABLE product SELECT product_id, product_name, product_type, sale_price FROM product_p WHERE city='Shanghai';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-3-Hive数据查询"><a href="#5-3-Hive数据查询" class="headerlink" title="5.3 Hive数据查询"></a>5.3 Hive数据查询</h3><h4 id="5-3-1-单表查询"><a href="#5-3-1-单表查询" class="headerlink" title="5.3.1 单表查询"></a>5.3.1 单表查询</h4><ul><li>语法</li></ul><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT select_expr,...FROM tbl_name[WHERE where_condition][GROUP BY col_list [HAVING having_condition]][ORDER BY col_list][CLUSTER BY col_list | [DISTRIBUTE BY col_list] [SORT BY col_list]][LIMIT rows]/*select_expr: 查询的字段tbl_name: 表名where_condition: 查询数据的限制条件GROUP BY col_list: 按字段列表col_list进行分组，可以是多个字段LIMIT rows: 返回指定行数的数据HAVING having_condition: 对GROUP BY语句产生分组的结果进行条件过滤*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Hive有四种排序方式：ORDER BY、SORT BY、DISTRIBUTE BY、CLUSTER BY。</p><p>ORDER BY：最常用的一种排序，是一种全局排序，与关系型数据库中的ORDER BY类似。该种排序方式是所有的数据在一个reducer上面进行排序，所以一般使用这个函数进行排序的时候速度较慢。此外，在严格模式下(hive.mapred.mode=strict)，ORDER BY必须和LIMIT一起使用，否则会报错。</p><p>SORT BY：在每个 Reducer 中进行排序，可以保证每个 Reducer 的输出数据是有序的，但不能保证全局有序。</p><p>DISTRIBUTE BY：控制map的输出在reducer上如何划分。一般与SORT BY结合使用实现全局排序。</p><p>CLUSTER BY：同时具备DISTRIBUTE BY和SORT BY的功能，要求DISTRIBUTE BY和SORT BY所用的字段要相同，可以保证数据在全局是有序的。</p><h4 id="5-3-2-多表联结查询"><a href="#5-3-2-多表联结查询" class="headerlink" title="5.3.2 多表联结查询"></a>5.3.2 多表联结查询</h4><p>Hive 支持内连接，左连接，右连接，全连接，左半连接（Hive专用）。</p><ul><li>INNER JOIN ON / JOIN ON（内连接）</li></ul><p>取两个表的交集，即两表中都存在的记录。</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT t1.*, t2.* FROM t1 JOIN t2 ON (t1.key1 = t2.key1 AND t1.key2 = t2.key2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>LEFT [OUTER] JOIN ON（左【外】连接）</li></ul><p>以JOIN左边的表为主表，返回的数据行数跟主表相同，保留左边表的字段值，右表关联不上的字段为NULL。</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT t1.*, t2.* FROM t1 LEFT JOIN t2 ON (t1.key1 = t2.key1 AND t1.key2 = t2.key2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>RIGHT [OUTER] JOIN ON（右【外】连接）</li></ul><p>以JOIN右边的表为主表，返回的数据行数跟主表相同，保留右边表的字段值，左表关联不上的字段为NULL。</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT t1.*, t2.* FROM t1 RIGHT JOIN t2 ON (t1.key1 = t2.key1 AND t1.key2 = t2.key2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>FULL [OUTER] JOIN ON（全【外】连接）</li></ul><p>返回两个表的并集，不符合ON条件的用NULL表示。</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT t1.*, t2.* FROM t1 FULL JOIN t2 ON (t1.key1 = t2.key1 AND t1.key2 = t2.key2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>LEFT SEMI JOIN ON（左半连接）</li></ul><p>以JOIN左边的表为主表，不拼接两个表的字段，而是两个表根据ON子句中设置的过滤条件做交集，并返回主表的记录。</p><pre class="line-numbers language-lang-sql"><code class="language-lang-sql">SELECT t1.* FROM t1 LEFT SEMI JOIN t2 ON (t1.key1 = t2.key1 AND t1.key2 = t2.key2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="六、Hive函数"><a href="#六、Hive函数" class="headerlink" title="六、Hive函数"></a>六、Hive函数</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux环境Sqoop的安装与配置</title>
      <link href="/posts/620e2f13.html"/>
      <url>/posts/620e2f13.html</url>
      
        <content type="html"><![CDATA[<p>Sqoop是Hdoop与关系型数据库之间传递数据的工具，可以实现Mysql等关系型数据库与Hadoop的HDFS、HIVE、HBASE等数据存储系统间数据互传。Sqoop有Sqoop1和Sqoop2两个版本，但它们不兼容，并且官方并不建议在生产环境中使用sqoop2。我们这里用的是Sqoop1，在CentOS7系统中安装配置Sqoop。</p><h2 id="1-Sqoop安装与配置"><a href="#1-Sqoop安装与配置" class="headerlink" title="1. Sqoop安装与配置"></a>1. Sqoop安装与配置</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p>下载Sqoop安装包，这里我下载的是CDH版本，下载地址为：<a href="http://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/</a></p><ul><li>将安装包移动到/usr/local/src目录下，解压到/usr/local/目录下，重命名为sqoop</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 解压tar -zxvf sqoop-1.4.6-cdh5.16.2.tar.gz -C /usr/local/# 重命名mv sqoop-1.4.6-cdh5.16.2 sqoop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>配置环境变量</li></ul><p>打开环境变量配置文件，添加以下内容：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 打开配置文件 vim /etc/profile # 添加Sqoop环境变量 export SQOOP_HOME=/usr/local/sqoopexport PATH=$PATH:$SQOOP_HOME/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>环境变量生效</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h3><ul><li>修改Sqoop配置文件sqoop-env.sh</li></ul><p>进入到/usr/local/sqoop/conf目录下，拷贝sqoop-env-template.sh为sqoop-env.sh。编辑sqoop-env.sh，添加以下配置：</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">export HADOOP_COMMON_HOME=/usr/local/hadoopexport HADOOP_MAPRED_HOME=/usr/local/hadoopexport HBASE_HOME=/usr/local/hbaseexport HIVE_HOME=/usr/local/hive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>将JDBC驱动移动到/usr/local/sqoop/lib目录下</li></ul><p>下载<a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">JDBC驱动</a>，我下载的版本包是mysql-connector-java-5.1.48.tar.gz。</p><pre class="line-numbers language-lang-shell"><code class="language-lang-shell"># 解压 tar -zxvf mysql-connector-java-5.1.48.tar.gz # 进入到解压目录，将mysql-connector-java-5.1.48.jar移动到/usr/local/sqoop/lib目录下 cd mysql-connector-java-5.1.48 cp mysql-connector-java-5.1.48.jar /usr/local/sqoop/lib/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>验证</li></ul><pre class="line-numbers language-lang-shell"><code class="language-lang-shell">sqoop help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sqoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习环境搭建(四)--Spark单机环境搭建</title>
      <link href="/posts/f28d3f89.html"/>
      <url>/posts/f28d3f89.html</url>
      
        <content type="html"><![CDATA[<p>Apache Spark 是一个大数据处理通用引擎，基于Hadoop环境，Hadoop YARN为Spark提供资源调度框架，Hadoop HDFS为Spark提供底层的分布式文件存储。</p><h2 id="1-Spark安装与配置"><a href="#1-Spark安装与配置" class="headerlink" title="1. Spark安装与配置"></a>1. Spark安装与配置</h2><h3 id="1-1-Spark安装"><a href="#1-1-Spark安装" class="headerlink" title="1.1 Spark安装"></a>1.1 Spark安装</h3><p>下载Spark安装包，下载地址：<a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">http://spark.apache.org/downloads.html</a> ，这里我下载版本为<code>spark-2.4.4-bin-hadoop2.6</code>。</p><ul><li>将安装包移动到/usr/local/src目录下，并解压到/usr/local/目录下，重命名为spark</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">tar -zxvf spark-2.4.4-bin-hadoop2.6.tar.gz -C /usr/local/# 将解压到/usr/local/目录下的文件夹重命名mv spark-2.4.4-bin-hadoop2.6/ spark<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>配置环境变量</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 打开配置文件 vim /etc/profile # 添加Spark环境变量 export SPARK_HOME=/usr/local/sparkexport PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>环境变量生效</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-Local模式运行"><a href="#1-2-Local模式运行" class="headerlink" title="1.2 Local模式运行"></a>1.2 Local模式运行</h3><p>Local 模式是单机运行，它采用单节点多线程方式运行，不用部署，开箱即用，适合日常测试开发。</p><p>进入到/usr/local/spark/bin目录下，执行以下命令启动spark。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 启动spark-shellspark-shell --master local[2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>local</strong>：只启动一个工作线程；</li><li><strong>local[k]</strong>：启动 k 个工作线程；</li><li><strong>local[*]</strong>：启动跟 cpu 数目相同的工作线程数。</li></ul><p>可以通过 Web UI 查看作业的执行情况，访问地址：IP:4040</p><h2 id="2-Scala安装与配置"><a href="#2-Scala安装与配置" class="headerlink" title="2.Scala安装与配置"></a>2.Scala安装与配置</h2><p>Spark 是基于 Scala 语言进行开发的，分别提供了基于 Scala、Java、Python 语言的 API。这里分别介绍在CentOS7和win10系统中安装Scala。</p><h3 id="2-1-在CentOS7中安装Scala"><a href="#2-1-在CentOS7中安装Scala" class="headerlink" title="2.1 在CentOS7中安装Scala"></a>2.1 在CentOS7中安装Scala</h3><h4 id="2-1-1-前置条件"><a href="#2-1-1-前置条件" class="headerlink" title="2.1.1 前置条件"></a>2.1.1 前置条件</h4><p>Scala 的运行依赖于JDK，需要预先安装好JDK，我安装的JDK 1.8版本。JDK安装可参考<a href="https://www.linwang93.cn/2020/02/03/da-shu-ju-xue-xi-huan-jing-da-jian-yi-hadoop-dan-ji-huan-jing-da-jian/">Hadoop单机环境搭建</a>中的介绍。</p><h4 id="2-1-2-安装与配置"><a href="#2-1-2-安装与配置" class="headerlink" title="2.1.2 安装与配置"></a>2.1.2 安装与配置</h4><ul><li>下载Scala，下载地址：<a href="https://www.scala-lang.org/download/" target="_blank" rel="noopener">https://www.scala-lang.org/download/</a></li><li>将安装包移动到/usr/local目录下，解压，将解压文件夹重命名</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 解压tar -zxvf scala-2.13.1.tgz# 重命名mv scala-2.13.1/ scala<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>配置环境</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">vim ~/.bash_profile# 添加scala配置export SCALA_HOME=/usr/local/scalaexport PATH=$PATH:$SCALA_HOME/bin# 环境生效source ~/.bash_profile<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>验证是否安装成功</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[root@centos local]# scalascala># 退出:quit  # 或 ctrl + D<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-在Win10中安装Scala"><a href="#2-2-在Win10中安装Scala" class="headerlink" title="2.2 在Win10中安装Scala"></a>2.2 在Win10中安装Scala</h3><h4 id="2-2-1-前置条件"><a href="#2-2-1-前置条件" class="headerlink" title="2.2.1 前置条件"></a>2.2.1 前置条件</h4><p>在Win10环境下安装好JDK环境，安装可参考Win10安装配置Java开发环境的介绍。</p><h4 id="2-2-2-安装与配置"><a href="#2-2-2-安装与配置" class="headerlink" title="2.2.2 安装与配置"></a>2.2.2 安装与配置</h4><ul><li>安装Scala插件</li></ul><p>我们使用IDEA作为开发工具，默认不支持 Scala 语言的开发，需要通过插件进行扩展，安装Scala插件。</p><ul><li>安装Scala SDK</li></ul><p>官网下载安装包进行安装，下载地址：<a href="https://www.scala-lang.org/download/" target="_blank" rel="noopener">https://www.scala-lang.org/download/</a></p><p>这里我的系统是Win10，下载 scala-2.12.7msi 版本的安装包后，一直点击下一步进行安装，安装完成后会自动配置好环境变量。</p><ul><li>创建Scala项目</li></ul><p>新建项目，选择创建<code>Scala—IDEA</code>工程：</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Spark_20200203/1.png" style="zoom:50.5%;"></p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Spark_20200203/2.png" style="zoom:46%;"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习环境搭建(三)--Hive单机环境搭建</title>
      <link href="/posts/73be190e.html"/>
      <url>/posts/73be190e.html</url>
      
        <content type="html"><![CDATA[<p>Hive是一个架构在Hadoop之上的数据仓库工具，可以将结构化的数据文件映射成为一张数据库表，并提供类SQL的查询功能，为大数据查询和分析提供方便。这里在阿里云服务器上搭建Hive单机伪分布环境。</p><h2 id="1-Hive安装与配置"><a href="#1-Hive安装与配置" class="headerlink" title="1. Hive安装与配置"></a>1. Hive安装与配置</h2><h3 id="1-1-下载与安装"><a href="#1-1-下载与安装" class="headerlink" title="1.1 下载与安装"></a>1.1 下载与安装</h3><p>下载Hive安装包，这里我下载版本为 <code>cdh5.16.2</code>。下载地址：<a href="http://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/</a></p><ul><li>将安装包移动到/usr/local/src目录下，并解压到/usr/local/目录下，重命名为hive</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">tar -zxvf hive-1.1.0-cdh5.16.2.tar.gz -C /usr/local/# 将解压到/usr/local/目录下的文件夹重命名mv hive-1.1.0-cdh5.16.2 hive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>配置环境变量</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 打开配置文件 vim /etc/profile # 添加Hive环境变量 export HIVE_HOME=/usr/local/hiveexport PATH=$PATH:$HIVE_HOME/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>环境变量生效</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-MySQL数据库安装"><a href="#1-2-MySQL数据库安装" class="headerlink" title="1.2 MySQL数据库安装"></a>1.2 MySQL数据库安装</h3><p>采用MySQL数据库保存Hive的元数据，而不采用Hive自带的derby来存储元数据。</p><h4 id="1-2-1-安装前准备"><a href="#1-2-1-安装前准备" class="headerlink" title="1.2.1 安装前准备"></a>1.2.1 安装前准备</h4><ul><li>下载并安装MySQL yum仓库</li></ul><p>可以到<a href="http://repo.mysql.com/" target="_blank" rel="noopener">MySQL Yum 仓库下载页</a>选择合适的版本</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 下载rpm包wget http://repo.mysql.com/mysql57-community-release-el7-11.noarch.rpm# 安装rpm包获得MySQL yum仓库sudo rpm -ivh mysql57-community-release-el7-11.noarch.rpm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>选择一个发行版</li></ul><p>修改配置文件，选择MySQL5.7版本</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 修改/etc/yum.repos.d/目录下的mysql-community.repo配置文件，启用想安装的MySQL版本，这里我们选择MySQL5.7vi /etc/yum.repos.d/mysql-community.repo# 将配置文件中MySQL 5.7 Community Server的enabled属性值为1，其余都为0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>验证mysql5.7是否已启用</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[root@centos yum.repos.d]# yum repolist enabled | grep mysqlmysql-connectors-community/x86_64 MySQL Connectors Community                 141mysql-tools-community/x86_64      MySQL Tools Community                      105mysql57-community/x86_64          MySQL 5.7 Community Server                 404<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-安装MySQL"><a href="#1-2-2-安装MySQL" class="headerlink" title="1.2.2 安装MySQL"></a>1.2.2 安装MySQL</h4><p>安装MySQL，并自动安装依赖包</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"> yum install mysql-community-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-2-3-启动MySQL"><a href="#1-2-3-启动MySQL" class="headerlink" title="1.2.3 启动MySQL"></a>1.2.3 启动MySQL</h4><p>启动MySQL服务并检查状态</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 启动MySQLsystemctl start mysqld.service#检查状态systemctl status mysqld.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-4-修改MySQL密码"><a href="#1-2-4-修改MySQL密码" class="headerlink" title="1.2.4 修改MySQL密码"></a>1.2.4 修改MySQL密码</h4><p>MySQL默认创建了’root’@’localhost’账号，并创建了临时密码，密码打印在mysql日志中，找到并修改密码</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 获取临时密码grep 'temporary password' /var/log/mysqld.log# 用获取的密码登录MySQLmysql -uroot -p# 登陆MySQL后，修改密码。密码规则：至少包含1个大写字母、1个小写字母、1个数字、1个特殊字符，总长度不小于8ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-5-Navicat连接MySQL"><a href="#1-2-5-Navicat连接MySQL" class="headerlink" title="1.2.5 Navicat连接MySQL"></a>1.2.5 Navicat连接MySQL</h4><ul><li>打开服务器的3306端口</li><li>Navicat连接报错：Host ‘IP’ is not allowed to connect to this MySQL server，解决方法：</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 使用账号密码登陆MySQLmysql -uroot -p# 选择数据库use mysql;# 允许任何主机连接update user set host='%' where user='root';# 刷新权限flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-6-创建hive数据库"><a href="#1-2-6-创建hive数据库" class="headerlink" title="1.2.6 创建hive数据库"></a>1.2.6 创建hive数据库</h4><p>在MySQL中创建一个数据库，用来保存hive元数据</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 创建hive数据库，进入到mysql命令行mysql> create database hive;# 将hive数据库的字符编码设置为latin1mysql> alter database hive character set latin1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-Hive配置"><a href="#1-3-Hive配置" class="headerlink" title="1.3 Hive配置"></a>1.3 Hive配置</h3><h4 id="1-3-1-修改配置"><a href="#1-3-1-修改配置" class="headerlink" title="1.3.1 修改配置"></a>1.3.1 修改配置</h4><ul><li>hive-env.sh</li></ul><p>进入/usr/local/hive/conf目录，拷贝Hive的环境配置模板<code>flume-env.sh.template</code></p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">cp hive-env.sh.template hive-env.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改<code>hive-env.sh</code>，指定Hadoop的安装路径</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">HADOOP_HOME=/usr/local/hadoop<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>hive-site.xml</li></ul><p>在/usr/local/hive/conf目录下，新建 hive-site.xml 文件，主要是配置存放元数据的MySQL的地址、驱动、用户名和密码等信息：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 编辑hive-site.xml文件vim hive-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><?xml version="1.0" encoding="UTF-8" standalone="no"?><?xml-stylesheet type="text/xsl" href="configuration.xsl"?><configuration>  <property>    <name>javax.jdo.option.ConnectionURL</name>    <value>jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&amp;useSSL=false</value>    <description>JDBC connect string for a JDBC metastore</description>  </property>  <property>    <name>javax.jdo.option.ConnectionDriverName</name>    <value>com.mysql.jdbc.Driver</value>    <description>Driver class name for a JDBC metastore</description>  </property>  <property>    <!--MySQL用户名-->      <name>javax.jdo.option.ConnectionUserName</name>    <value>USERNAME</value>    <description>username to use against metastore database</description>  </property>  <property>    <!--MySQL密码-->      <name>javax.jdo.option.ConnectionPassword</name>    <value>PASSWORD</value>    <description>password to use against metastore database</description>  </property></configuration><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-2-添加数据库驱动"><a href="#1-3-2-添加数据库驱动" class="headerlink" title="1.3.2 添加数据库驱动"></a>1.3.2 添加数据库驱动</h4><p>由于Hive在连接MySQL时需要JDBC驱动，所以首先需要<a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">下载</a>对应版本的驱动，然后将驱动移动到/usr/local/hive/lib中。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 解压tar -zxvf mysql-connector-java-5.1.48.tar.gz# 进入到解压目录，将mysql-connector-java-5.1.48.jar移动到/usr/local/hive/lib目录下cd mysql-connector-java-5.1.48cp mysql-connector-java-5.1.48.jar /usr/local/hive/lib/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3-3-初始化元数据库"><a href="#1-3-3-初始化元数据库" class="headerlink" title="1.3.3 初始化元数据库"></a>1.3.3 初始化元数据库</h4><ul><li>当使用的 hive 是 1.x 版本时，可以不进行初始化操作，Hive 会在第一次启动的时候会自动进行初始化，但不会生成所有的元数据信息表，只会初始化必要的一部分，在之后的使用中用到其余表时会自动创建。</li><li>当使用的 hive 是 2.x 版本时，必须手动初始化元数据库。初始化命令：</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># schematool 命令在/usr/local/hive/bin目录下schematool -dbType mysql -initSchema<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里我使用的是 CDH 的<code>hive-1.1.0-cdh5.16.2.tar.gz</code>，对应 <code>Hive 1.1.0</code> 版本，可以跳过这一步。</p><h4 id="1-3-4-启动"><a href="#1-3-4-启动" class="headerlink" title="1.3.4 启动"></a>1.3.4 启动</h4><p>启动hive之前，请先启动hadoop集群</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 启动hive[root@centos ~]# hive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-HiveServer2-beeline配置"><a href="#2-HiveServer2-beeline配置" class="headerlink" title="2. HiveServer2/beeline配置"></a>2. HiveServer2/beeline配置</h2><p>Hive内置了HiveServer2服务，允许远程客户端可以使用各种编程语言向 Hive 提交请求并检索结果，支持多客户端并发访问和身份验证。HiveServer2 拥有自己的 CLI 工具——Beeline。Beeline 是一个基于 SQLLine 的 JDBC 客户端。</p><h3 id="2-1-修改Hadoop配置"><a href="#2-1-修改Hadoop配置" class="headerlink" title="2.1 修改Hadoop配置"></a>2.1 修改Hadoop配置</h3><p>修改 /usr/local/hadoop/etc/hadoop/目录下hadoop 的 core-site.xml 配置文件，增加如下配置，指定 hadoop 的 root 用户可以代理本机上所有的用户。</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><property>    <name>hadoop.proxyuser.root.hosts</name>    <value>*</value></property><property>    <name>hadoop.proxyuser.root.groups</name>    <value>*</value></property><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-启动hiveserver2"><a href="#2-2-启动hiveserver2" class="headerlink" title="2.2 启动hiveserver2"></a>2.2 启动hiveserver2</h3><p>进入到/usr/local/hive/bin目录下，执行以下命令：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[root@centos bin]# hiveserver2# 打开另一个命令窗口，执行以下命令，出现10000的端口号表示成功开启netstat -nltp | grep 10000[root@centos bin]# netstat -nltp | grep 10000tcp        0      0 0.0.0.0:10000           0.0.0.0:*               LISTEN      17080/java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hivesever2每次要手动启动，因此设置为进程，后台运行。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[root@centos ~]# nohup hive --service hiveserver2 &<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-beeline的使用"><a href="#2-3-beeline的使用" class="headerlink" title="2.3 beeline的使用"></a>2.3 beeline的使用</h3><p>进入/usr/local/hive/bin目录下，执行以下命令进入beeline 交互式命令行，连接hive</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[root@centos bin]# beeline -u jdbc:hive2://localhost:10000 -n root# -u : 指定元数据库的链接信息  -n : 指定用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>还有一种方式也可以去连接</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 先执行 beeline[root@centos bin]# beelinebeeline># 再执行以下命令进行连接!connect jdbc:hive2://localhost:10000 -n root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习环境搭建(二)--HBase单机环境搭建</title>
      <link href="/posts/a32d9546.html"/>
      <url>/posts/a32d9546.html</url>
      
        <content type="html"><![CDATA[<p>HBase是一种分布式存储的数据库，技术上来讲，它更像是分布式存储而不是分布式数据库。HBase的运行有三种模式：单机模式、伪分布式模式、分布式模式。出于学习目的，我们只在一台阿里云服务器上部署单机伪分布环境。</p><h2 id="1-HBase安装前配置"><a href="#1-HBase安装前配置" class="headerlink" title="1. HBase安装前配置"></a>1. HBase安装前配置</h2><p>HBase 需要依赖JDK环境，JDK安装可参考<a href="https://www.linwang93.cn/2020/02/03/da-shu-ju-xue-xi-huan-jing-da-jian-yi-hadoop-dan-ji-huan-jing-da-jian/">Hadoop单机环境搭建</a>中的介绍。</p><h2 id="2-HBase安装与配置"><a href="#2-HBase安装与配置" class="headerlink" title="2. HBase安装与配置"></a>2. HBase安装与配置</h2><p>安装HBase前，需要预先安装 Hadoop。Hadoop 的安装方式可参考<a href="https://www.linwang93.cn/2020/02/03/da-shu-ju-xue-xi-huan-jing-da-jian-yi-hadoop-dan-ji-huan-jing-da-jian/">Hadoop单机环境搭建</a>。</p><h3 id="2-1-下载与安装"><a href="#2-1-下载与安装" class="headerlink" title="2.1 下载与安装"></a>2.1 下载与安装</h3><p>下载HBase安装包，HBase版本要与 Hadoop 的版本兼容，不然会出现各种 Jar 包冲突。这里我安装的 Hadoop 版本为 <code>hadoop-2.6.0-cdh5.16.2</code>，为保持版本一致，选择的 HBase 版本为 <code>hbase-1.2.0-cdh5.16.2</code>，下载地址为：<a href="http://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/</a></p><ul><li>将安装包移动到/usr/local/src目录下，并解压到/usr/local/目录下，重命名为hbase</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">tar -zxvf hbase-1.2.0-cdh5.16.2.tar.gz -C /usr/local/# 将解压到/usr/local/目录下的文件夹重命名mv hbase-1.2.0-cdh5.16.2/ hbase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>配置环境变量</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 打开配置文件 vim /etc/profile # 添加HBase环境变量 export HBASE_HOME=/usr/local/hbaseexport PATH=$HBASE_HOME/bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>环境变量生效</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看HBase版本，确定hbase安装成功</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hbase version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-单机伪集群配置"><a href="#2-2-单机伪集群配置" class="headerlink" title="2.2 单机伪集群配置"></a>2.2 单机伪集群配置</h3><h4 id="2-2-1-修改配置"><a href="#2-2-1-修改配置" class="headerlink" title="2.2.1 修改配置"></a>2.2.1 修改配置</h4><ul><li>hbase-env.sh</li></ul><p>修改/usr/local/hbase/conf/目录下的hbase-env.sh文件，添加如下环境变量</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">export JAVA_HOME=/usr/local/javaexport HBASE_HOME=/usr/local/hbaseexport PATH=$PATH:$HBASE_HOME/binexport HBASE_MANAGES_ZK=true   # Hbase自带zookeeper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>hbase-site.xml</li></ul><p>配置/usr/local/hbase/conf/hbase-site.xml，打开并编辑hbase-site.xml</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">vim /usr/local/hbase/conf/hbase-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><configuration>    <!--指定HBase以分布式模式运行-->       <property>        <name>hbase.cluster.distributed</name>        <value>true</value>    </property>    <!--指定HBase数据存储路径为HDFS上的hbase目录,hbase目录不需要预先创建，程序会自动创建-->       <property>        <name>hbase.rootdir</name>        <value>hdfs://localhost:8020/hbase</value>    </property></configuration><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-启动"><a href="#2-2-2-启动" class="headerlink" title="2.2.2 启动"></a>2.2.2 启动</h4><p>切换至/usr/local/hbase/bin目录，执行以下命令：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">start-hbase.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-2-3-验证是否启动成功"><a href="#2-2-3-验证是否启动成功" class="headerlink" title="2.2.3 验证是否启动成功"></a>2.2.3 验证是否启动成功</h4><ul><li>使用<code>jps</code>命令查看进程</li></ul><p>HBase的进程:  HMaster，HRegionServer，HBase内置的Zookeeper的进程: HQuorumPeer，其余的为 HDFS 和 YARN 的进程。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[root@centos bin]# jps3168 ResourceManager2178 NameNode5302 Jps3254 NodeManager2759 DataNode4844 HMaster2445 SecondaryNameNode4974 HRegionServer4767 HQuorumPeer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>访问HBase Web UI界面，访问地址：IP:60010</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习环境搭建(一)--Hadoop单机环境搭建</title>
      <link href="/posts/6dd29b8f.html"/>
      <url>/posts/6dd29b8f.html</url>
      
        <content type="html"><![CDATA[<p>Hadoop有三种运行模式：单机模式、伪分布式模式、全分布式集群模式。<strong>单机模式</strong>：Hadoop的默认模式（非分布式模式），无需进行其他配置即可运行。非分布式即单Java进程，用于开发和调试。<strong>伪分布式模式</strong>：Hadoop可以在单节点上以伪分布式的方式运行，Hadoop进程以分离的Java进程来运行，节点既作为NameNode也作为DataNode，同时读取的是HDFS中的文件。<strong>分布式模式</strong>：使用多个节点构成集群环境来运行Hadoop。</p><p>为了搭建一个大数据学习环境，这里仅在一台阿里云服务器(CentOS7.7)搭建一个伪分布式的Hadoop平台。后续有条件再进行Hadoop分布式平台的搭建。</p><h2 id="1-Hadoop安装前配置"><a href="#1-Hadoop安装前配置" class="headerlink" title="1. Hadoop安装前配置"></a>1. Hadoop安装前配置</h2><h3 id="1-1-安装Java环境"><a href="#1-1-安装Java环境" class="headerlink" title="1.1 安装Java环境"></a>1.1 安装Java环境</h3><p>Java环境推荐使用 Oracle 的JDK，在<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">官网</a>下载所需版本的 JDK，这里我下载的版本为<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK 1.8</a>。</p><ul><li>将下载的JDK移动到/usr/local/src目录下，并解压到/usr/local/目录下，重命名为java</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">tar -zxvf jdk-8u241-linux-x64.tar.gz -C /usr/local/mv jdk1.8.0_241 java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>编辑环境变量，并添加如下配置</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">vim /etc/profileexport JAVA_HOME=/usr/local/javaexport JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>环境变量配置生效</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>验证JAVA是否安装成功</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">java -versionjavajavac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="1-2-配置免密登录"><a href="#1-2-配置免密登录" class="headerlink" title="1.2 配置免密登录"></a>1.2 配置免密登录</h3><ul><li>安装SSH server</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">sudo yum install openssh-server  # 服务器上已经安装<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>修改sshd_config配置</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">vim /etc/ssh/sshd_config# 在文件中设置如下属性：（按 / 可以进入搜索模式，按esc退出搜索模式）PubkeyAuthentication yesPermitRootLogin yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>重启ssh服务</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">service sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>登录本机，需要密码才能登录</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">ssh localhost<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>退出ssh，利用 ssh-keygen 生成密钥，并将密钥加入到授权</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">exit # 退出上一步登录的ssh localhostcd ~/.ssh/  # 若没有该目录，请先执行一次ssh localhostssh-keygen -t rsa   # 需要连续敲击三次回车# 写入公匙到授权文件cat ./id_rsa.pub >> ./authorized_keys chmod 600 authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>免密登录</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">ssh localhost<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-Hadoop安装与配置"><a href="#2-Hadoop安装与配置" class="headerlink" title="2. Hadoop安装与配置"></a>2. Hadoop安装与配置</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>下载Hadoop安装包，这里我下载的是CDH版本，下载地址为：<a href="http://archive.cloudera.com/cdh5/cdh/5/" target="_blank" rel="noopener">http://archive.cloudera.com/cdh5/cdh/5/</a> </p><ul><li>将安装包移动到/usr/local/src目录下，并解压到/usr/local/目录下，重命名为hadoop</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">tar -zxvf hadoop-2.6.0-cdh5.16.2.tar.gz -C /usr/local/mv hadoop-2.6.0-cdh5.16.2 hadoop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>配置环境变量</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 打开配置文件vim /etc/profile# 添加Hadoop环境变量export HADOOP_HOME=/usr/local/hadoopexport PATH=$PATH:${HADOOP_HOME}/bin:${HADOOP_HOME}/sbin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>环境变量生效</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">source /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>验证Hadoop 是否可用</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hadoop version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-2-单机伪分布配置"><a href="#2-2-单机伪分布配置" class="headerlink" title="2.2 单机伪分布配置"></a>2.2 单机伪分布配置</h3><h4 id="2-2-1-HDFS环境搭建"><a href="#2-2-1-HDFS环境搭建" class="headerlink" title="2.2.1 HDFS环境搭建"></a>2.2.1 HDFS环境搭建</h4><h5 id="2-2-1-1-修改配置"><a href="#2-2-1-1-修改配置" class="headerlink" title="2.2.1.1 修改配置"></a>2.2.1.1 修改配置</h5><p>进入 <code>/usr/local/hadoop/etc/hadoop/</code> 目录下，修改以下配置：</p><ul><li><p>hadoop-env.sh</p><p>修改hadoop-env.sh文件，在文件开始处添加Hadoop和Java环境变量。</p></li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">vim /usr/local/hadoop/etc/hadoop/hadoop-env.sh# 添加export JAVA_HOME=/usr/local/javaexport HADOOP_HOME=/usr/local/hadoopexport PATH=$PATH:/usr/local/hadoop/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>core-site.xml</p><p>修改配置文件 core-site.xml </p></li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">vim /usr/local/hadoop/etc/hadoop/core-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><configuration>    <property>        <!--指定 hadoop 存储临时文件的目录-->        <name>hadoop.tmp.dir</name>        <value>file:/usr/local/hadoop/tmp</value>        <description>Abase for other temporary directories.</description>    </property>    <property>        <!--指定namenode的hdfs协议文件系统的通信地址-->        <name>fs.defaultFS</name>        <value>hdfs://localhost:8020</value>    </property></configuration><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>hdfs-site.xml</p><p>修改配置文件hdfs-site.xml</p></li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">vim /usr/local/hadoop/etc/hadoop/hdfs-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><configuration>    <property>        <!--指定hdfs的副本数-->        <name>dfs.replication</name>        <value>1</value>    </property>    <property>        <!--指定hdfs中namenode数据(元数据)的存放地点-->        <name>dfs.namenode.name.dir</name>        <value>file:/usr/local/hadoop/tmp/dfs/name</value>    </property>    <property>        <!--指定hdfs中datanode的存储位置-->        <name>dfs.datanode.data.dir</name>        <value>file:/usr/local/hadoop/tmp/dfs/data</value>    </property></configuration><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-1-2-关闭防火墙"><a href="#2-2-1-2-关闭防火墙" class="headerlink" title="2.2.1.2 关闭防火墙"></a>2.2.1.2 关闭防火墙</h5><p>不关闭防火墙可能导致无法访问 Hadoop 的 Web UI 界面。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 查看防火墙状态sudo firewall-cmd --state# 关闭防火墙:sudo systemctl stop firewalld.service# 或禁止防火墙开机启动systemctl disable firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-1-3-初始化"><a href="#2-2-1-3-初始化" class="headerlink" title="2.2.1.3 初始化"></a>2.2.1.3 初始化</h5><p>第一次启动 Hadoop 时需要进行初始化，进入到/usr/local/hadoop/bin/目录下，执行以下命令：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">hdfs namenode -format<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-2-1-4-启动HDFS"><a href="#2-2-1-4-启动HDFS" class="headerlink" title="2.2.1.4 启动HDFS"></a>2.2.1.4 启动HDFS</h5><p>进入到/usr/local/hadoop/sbin/目录下，执行以下命令：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">start-dfs.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-2-1-5-验证是否启动成功"><a href="#2-2-1-5-验证是否启动成功" class="headerlink" title="2.2.1.5 验证是否启动成功"></a>2.2.1.5 验证是否启动成功</h5><ul><li>执行jps命令</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[root@centos sbin]# jps3137 DataNode3395 Jps3276 SecondaryNameNode3022 NameNode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>成功启动后，查看Web UI界面，访问：IP:50070</li></ul><h4 id="2-2-2-YARN环境搭建"><a href="#2-2-2-YARN环境搭建" class="headerlink" title="2.2.2 YARN环境搭建"></a>2.2.2 YARN环境搭建</h4><h5 id="2-2-2-1-修改配置"><a href="#2-2-2-1-修改配置" class="headerlink" title="2.2.2.1 修改配置"></a>2.2.2.1 修改配置</h5><p>进入 <code>/usr/local/hadoop/etc/hadoop/</code> 目录下，修改以下配置：</p><ul><li><p>mapred-site.xml</p><p>如果没有mapred-site.xml，则拷贝一份样例文件后再修改</p></li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">cp mapred-site.xml.template mapred-site.xmlvim mapred-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在mapred-site.xml添加如下内容：</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><configuration>    <property>        <name>mapreduce.framework.name</name>        <value>yarn</value>    </property></configuration><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>yarn-site.xml</p><p>编辑yarn-site.xml，添加如下内容：</p></li></ul><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><configuration>    <property>        <!--配置NodeManager上运行的附属服务。需要配置成mapreduce_shuffle后才可以在Yarn上运行MapReduce程序。-->        <name>yarn.nodemanager.aux-services</name>        <value>mapreduce_shuffle</value>    </property></configuration><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-2-2-启动服务"><a href="#2-2-2-2-启动服务" class="headerlink" title="2.2.2.2 启动服务"></a>2.2.2.2 启动服务</h5><p>进入 <code>/usr/local/hadoop/sbin/</code> 目录下，启动 YARN：</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">start-yarn.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-2-2-3-验证是否启动成功"><a href="#2-2-2-3-验证是否启动成功" class="headerlink" title="2.2.2.3 验证是否启动成功"></a>2.2.2.3 验证是否启动成功</h5><ul><li>执行 <code>jps</code> 命令，查看 <code>NodeManager</code> 和 <code>ResourceManager</code> 服务是否已经启动</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">[root@centos sbin]# jps3168 ResourceManager2178 NameNode3254 NodeManager2759 DataNode3595 Jps2445 SecondaryNameNode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查看Web UI界面，访问：IP:8088</li></ul><h2 id="3-安装过程中的问题"><a href="#3-安装过程中的问题" class="headerlink" title="3.安装过程中的问题"></a>3.安装过程中的问题</h2><ol><li><p>访问Hadoop Web UI界面时，50070和8088端口无法访问</p><p>原因是阿里云服务器未开放该端口，需要配置阿里云安全组规则。</p><p>配置参考：<a href="https://www.cnblogs.com/ergexy/p/9718732.html" target="_blank" rel="noopener">https://www.cnblogs.com/ergexy/p/9718732.html</a></p></li><li><p>Hadoop多次（两次以上）初始化后，无法启动DataNode节点</p><p>解决参考：<a href="https://blog.csdn.net/lukabruce/article/details/80277846" target="_blank" rel="noopener">https://blog.csdn.net/lukabruce/article/details/80277846</a></p></li><li><p>执行start-hdfs.sh时，报错：WARN util.NativeCodeLoader: Unable to load native-hadoop</p><p>安装的是Hadoop CDH版本，从cloudera官网下载安装包解压后，在hadoop/lib/native/下没有库文件。可以下载Hadoop的其他发行版本，将native文件夹中的内容复制到安装的CDH版本native目录下。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10安装配置Java开发环境</title>
      <link href="/posts/26c0f6e1.html"/>
      <url>/posts/26c0f6e1.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍在Win10系统下安装Java JDK，并配置Java JDK环境变量。</p><h2 id="1-下载并安装Java-JDK"><a href="#1-下载并安装Java-JDK" class="headerlink" title="1. 下载并安装Java JDK"></a>1. 下载并安装Java JDK</h2><p>进入<a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">Java JDK</a>下载页面，选择JDK版本。我们选择下载<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">JDK 8u241</a>的Windows x64版本，需要选中上面的Accept License Agreement后，点击jdk-8u241-windows-x64.exe下载。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Java_20200120/1-1.png" style="zoom:50%;"></p><p>下载完成后，找到下载文件，双击进行安装，具体操作步骤如下：</p><p>步骤01：双击安装包，修改安装位置，默认在C盘。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Java_20200120/1-2.png" style="zoom:50%;"></p><p>步骤02：更改安装位置后，点击下一步进行安装，安装过程中弹出jre安装位置，更改jre安装位置，建议和jdk同路径下。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Java_20200120/1-3.png" style="zoom:50%;"></p><p>步骤03：设置好jre位置后，点击下一步继续安装，直至完成。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Java_20200120/1-4.png" style="zoom:50%;"></p><h2 id="2-配置Java-JDK环境变量"><a href="#2-配置Java-JDK环境变量" class="headerlink" title="2. 配置Java JDK环境变量"></a>2. 配置Java JDK环境变量</h2><p>安装完Java JDK后不能直接使用，还需配置系统的环境变量。</p><p>步骤01：选中此电脑，右击选择<strong>属性</strong>，选择<strong>高级系统设置</strong>，选择<strong>环境变量</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Java_20200120/2-1.png" style="zoom:40%;"></p><p>步骤02：在环境变量窗口，新建系统变量，变量名：<strong>JAVA_HOME</strong>，变量值为JDK的安装目录，点击确定。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Java_20200120/2-2.png" style="zoom:40%;"></p><p>步骤03：修改系统变量中的Path变量，点击新建，添加新的变量值：<strong>%JAVA_HOME%\bin</strong>，<strong>%JAVA_HOME%\jre\bin</strong>，点击确定。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Java_20200120/2-3.png" style="zoom:50%;"></p><p>步骤04：新建系统变量，变量名：<strong>CLASSPATH</strong>，变量值：<strong>.;%JAVA_HOME%\lib\dt.jar; %JAVA_HOME%\lib\tools.jar;</strong>，点击确定。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Java_20200120/2-4.png" style="zoom:50%;"></p><p>步骤05：上述配置完成后，点击确定。</p><p>步骤06：验证Java是否安装成功。WINDOWS+R键，输入cmd，进入命令行界面。在命令行界面，分别输入java -verison、java、javac，有如下输出，则说明配置成功。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Java_20200120/2-5.png" style="zoom:40%;"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件安装与配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7部署Python和virtualenvwrapper</title>
      <link href="/posts/e3623c79.html"/>
      <url>/posts/e3623c79.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-升级Python2"><a href="#1-升级Python2" class="headerlink" title="1. 升级Python2"></a>1. 升级Python2</h2><p>CentOS7系统目前默认python环境版本号为2.7.5，在实际的开发、测试环境中我们可能需要更高的版本。Centos7系统自带软件可能依赖python2.7.5版本，故不能直接卸载原版本，我们需要保留原版本，并安装新版本。</p><h3 id="1-1-查看系统和Python版本"><a href="#1-1-查看系统和Python版本" class="headerlink" title="1.1 查看系统和Python版本"></a>1.1 查看系统和Python版本</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 查看系统版本cat /etc/centos-release# 查看Python版本python -V<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-安装新版Python2"><a href="#1-2-安装新版Python2" class="headerlink" title="1.2 安装新版Python2"></a>1.2 安装新版Python2</h3><ul><li>安装依赖</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">yum install gcc* openssl openssl-devel ncurses-devel.x86_64  bzip2-devel sqlite-devel python-devel zlib<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>下载Python安装包</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">wget https://www.python.org/ftp/python/2.7.17/Python-2.7.17.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>解压安装包到/usr/local/目录下，并配置、编译、安装</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">tar -zxvf Python-2.7.17.tgz -C /usr/local/cd Python-2.7.17./configure --prefix=/usr/local   make  make altinstall  # 不要使用make install,这样会覆盖原有的python版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>环境配置</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># 备份旧版本并验证mv /usr/bin/python /usr/bin/python2.7.5  python2.7.5  # 连接新版本并查看最新Python版本ln -s /usr/local/bin/python2.7 /usr/bin/python  python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>更改yum配置</li></ul><p>编辑/usr/bin/yum和/usr/libexec/urlgrabber-ext-down两个文件，将首行的#!/usr/bin/python 改为 #!/usr/bin/python2.7.5。</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">vim /usr/bin/yumvim /usr/libexec/urlgrabber-ext-down<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-3-安装pip"><a href="#1-3-安装pip" class="headerlink" title="1.3 安装pip"></a>1.3 安装pip</h3><ul><li>下载</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">wget https://bootstrap.pypa.io/get-pip.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>安装</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">python get-pip.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>建立软连接</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">ln -s /usr/local/bin/pip2.7 /usr/bin/pip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-安装Python3"><a href="#2-安装Python3" class="headerlink" title="2. 安装Python3"></a><strong>2. 安装Python3</strong></h2><blockquote><p>CentOS7默认安装了Python2，在CentOS7中安装Python3，并设置为默认。</p></blockquote><h3 id="2-1-安装lrzsz"><a href="#2-1-安装lrzsz" class="headerlink" title="2.1 安装lrzsz"></a>2.1 安装lrzsz</h3><p>windows与CentOS互传文件</p><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">yum -y install lrzsz # 上传文件：rz# 下载文件：sz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2-安装Python3"><a href="#2-2-安装Python3" class="headerlink" title="2.2 安装Python3"></a>2.2 安装Python3</h3><ul><li>安装依赖 </li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">yum -y groupinstall "Development tools"yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>在线下载或本地上传rz</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">wget https://www.python.org/downloads/release/python-376/# 或 rz上传本地安装包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>解压</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">tar zxvf Python-3.7.6.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>切换到解压目录，配置、编译、安装</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">cd Python-3.7.6./configure --prefix=/usr/local/python3makemake install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>创建软链接（将python3设置为默认python）</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">ln -s /usr/local/python3/bin/python3 /usr/bin/pythonln -s /usr/local/python3/bin/pip3 /usr/bin/pip<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>更改yum配置</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash"># yum采用Python2作为命令解释器，在修改默认Python后，需修改下述文件vim /usr/bin/yum vim /usr/libexec/urlgrabber-ext-downvim /usr/bin/yum-config-manager# 将首行的Python都修改为Python2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-安装配置虚拟环境virtualenvwrapper"><a href="#3-安装配置虚拟环境virtualenvwrapper" class="headerlink" title="3. 安装配置虚拟环境virtualenvwrapper"></a><strong>3. 安装配置虚拟环境virtualenvwrapper</strong></h2><h3 id="3-1-安装virtualenvwrapper"><a href="#3-1-安装virtualenvwrapper" class="headerlink" title="3.1 安装virtualenvwrapper"></a>3.1 安装virtualenvwrapper</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">pip3 install virtualenvwrapper<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-配置virtualenvwrapper"><a href="#3-2-配置virtualenvwrapper" class="headerlink" title="3.2 配置virtualenvwrapper"></a>3.2 配置virtualenvwrapper</h3><ul><li>创建存放虚拟环境的目录</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">mkdir ~/.virtualenvs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>编辑.bashrc文件</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">vim ~/.bashrc# 在文件中加入：export WORKON_HOME=~/.virtualenvs # 指定virtualenvwrapper环境的目录export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3 # 指定通过哪个python版本来创建虚拟环境export VIRTUALENVWRAPPER_VIRTUALENV=/usr/local/python3/bin/virtualenvsource /usr/local/python3/bin/virtualenvwrapper.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使修改环境变量生效</li></ul><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">source ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-3-修改快捷键"><a href="#3-3-修改快捷键" class="headerlink" title="3.3 修改快捷键"></a>3.3 修改快捷键</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">alias mkv='mkvirtualenv' # 创建一个虚拟环境alias rmv='rmvirtualenv' # 删除虚拟环境alias lsv='lsvirtualenv' # 查看所有的虚拟环境alias cdv='cdvirtualenv' # 切换到虚拟环境的目录alias cds='cdsitepackages' # 切换到虚拟环境的site-packages目录alias lss='lssitepackages' # 查看虚拟环境site-packages目录的文件unalias mkv # 取消别名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-创建虚拟环境"><a href="#3-4-创建虚拟环境" class="headerlink" title="3.4 创建虚拟环境"></a>3.4 创建虚拟环境</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">mkv venv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-5-进入和退出虚拟环境"><a href="#3-5-进入和退出虚拟环境" class="headerlink" title="3.5 进入和退出虚拟环境"></a>3.5 进入和退出虚拟环境</h3><pre class="line-numbers language-lang-bash"><code class="language-lang-bash">workon venv # 切换虚拟环境deactivate # 退出虚拟环境<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> virtualenvwrapper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas快速入门</title>
      <link href="/posts/54cc6129.html"/>
      <url>/posts/54cc6129.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>  <strong>Pandas</strong>是Python的核心数据分析库，一个强大的分析结构化数据的工具集；它的使用基础是Numpy（提供高性能的矩阵运算）；用于数据挖掘和数据分析，同时也提供数据清洗功能。Pandas有Series（1维）和DataFrame（2维）两种主要的数据结构。DataFrame是一个表格型的数据结构，包含有一组有序的列，每列可以是不同的值类型(数值、字符串、布尔型等)，DataFrame即有行索引也有列索引。Series是一种类似于一维数组的对象，是由一组数据(各种NumPy数据类型)以及一组与之相关的数据标签(即索引)组成。</p><h2 id="2-Pandas快速入门"><a href="#2-Pandas快速入门" class="headerlink" title="2. Pandas快速入门"></a>2. Pandas快速入门</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><h4 id="2-1-1-Series"><a href="#2-1-1-Series" class="headerlink" title="2.1.1 Series"></a>2.1.1 Series</h4><p>  <strong>Series</strong>是一维索引标记的数组，能够保存任何数据类型（整数、字符串、浮点数、Python对象等）。创建Series的基本方法：</p><pre class="line-numbers language-lang-python"><code class="language-lang-python">import pandas as pd   # 在使用pandas模块时需要先引入 s = pd.Series(data, index=index)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中，data可以是字典、多维数组 、标量等；索引index是轴标签列表。</p><ul><li><p>data为多维数组</p><p>索引index的长度要和数据data的长度相同。如果没有传递索引，将默认创建值索引，即<code>[0，1，...，len(data)-1]</code>。</p></li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport pandas as pds = pd.Series(np.random.randn(5), index=['a', 'b', 'c', 'd', 'e']) # 指定索引Out:    a    0.110595    b    0.990848    c    0.382866    d   -0.536102    e   -0.062049    dtype: float64s = pd.Series(np.random.randn(5)) # 不指定索引Out:    0   -0.721240    1    0.126976    2    0.465630    3   -0.375598    4    0.894133    dtype: float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>data为字典</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 未指定索引，使用Python版本> = 3.6且Pandas版本> = 0.23，则索引将按dict的插入顺序排序，否则将按字典键的词法顺序排序。d = {'b': 1, 'a': 0, 'c': 2}s = pd.Series(d)Out:   # 索引为字典中的键    b    1    a    0    c    2    dtype: int64# 指定索引d = {'a': 0., 'b': 1., 'c': 2.}s = pd.Series(d, index=['b', 'c', 'd', 'a'])Out:    b    1.0    c    2.0    d    NaN      a    0.0    dtype: float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>NaN（不是数字）是Pandas中使用的标准<strong>缺失数据</strong>标记</p></blockquote><ul><li><p>data为标量</p><p>必须提供索引，<code>Series</code> 按<strong>索引</strong>长度重复该标量值。</p></li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = pd.Series(5., index=['a', 'b', 'c'])Out:    a    5.0    b    5.0    c    5.0    dtype: float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-数据帧（DataFrame）"><a href="#2-1-2-数据帧（DataFrame）" class="headerlink" title="2.1.2 数据帧（DataFrame）"></a>2.1.2 数据帧（DataFrame）</h4><p>  <strong>DataFrame</strong>是一个二维标记数据结构，具有可能不同类型的列，可以将其视为电子表格或SQL表。DataFrame可以接受的数据：列表、字典、Series字典、多维数组字典、列表字典等。</p><ul><li>data为Series构成的字典</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">d = {'one': pd.Series([1., 2., 3.], index=['a', 'b', 'c']),     'two': pd.Series([1., 2., 3., 4.], index=['a', 'b', 'c', 'd'])}df = pd.DataFrame(d)Out:       one  two    a  1.0  1.0    b  2.0  2.0    c  3.0  3.0    d  NaN  4.0# 指定索引index和列columnsd = {'one': pd.Series([1., 2., 3.], index=['a', 'b', 'c']),     'two': pd.Series([1., 2., 3., 4.], index=['a', 'b', 'c', 'd'])}df = pd.DataFrame(d, index=['d', 'b', 'a'], columns=['two', 'three'])Out:    two three d  4.0   NaN b  2.0   NaN a  1.0   NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>data为多维数组字典或列表字典</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 不传递索引d = {'one': [1., 2., 3., 4.], 'two': [4., 3., 2., 1.]}df = pd.DataFrame(d)Out:       one  two    0  1.0  4.0    1  2.0  3.0    2  3.0  2.0    3  4.0  1.0# 传递索引d = {'one': [1., 2., 3., 4.], 'two': [4., 3., 2., 1.]}df = pd.DataFrame(d, index=['a', 'b', 'c', 'd'])Out:       one  two    a  1.0  4.0    b  2.0  3.0    c  3.0  2.0    d  4.0  1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>data为字典列表</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">data = [{'a': 1, 'b': 2}, {'a': 5, 'b': 10, 'c': 20}]df = pd.DataFrame(data, index=['first', 'second'])  # index为行索引Out:            a   b     c    first   1   2   NaN    second  5  10  20.0# 指定输出列data = [{'a': 1, 'b': 2}, {'a': 5, 'b': 10, 'c': 20}]df = pd.DataFrame(data, index=['first', 'second'], columns=['a', 'b'])Out:            a   b    first   1   2    second  5  10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-查看数据"><a href="#2-2-查看数据" class="headerlink" title="2.2 查看数据"></a>2.2 查看数据</h3><h4 id="2-2-1-查看Series数据"><a href="#2-2-1-查看Series数据" class="headerlink" title="2.2.1 查看Series数据"></a>2.2.1 查看Series数据</h4><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">s.head(n) / s.tail(n)</td><td style="text-align:center">查看Series对象的前n / 后n个元素</td></tr><tr><td style="text-align:center">s.shape</td><td style="text-align:center">获取Series对象的size，返回一个元组</td></tr><tr><td style="text-align:center">s.shape[0]</td><td style="text-align:center">返回Series对象的元素个数</td></tr><tr><td style="text-align:center">s.dtypes</td><td style="text-align:center">查看数据类型</td></tr><tr><td style="text-align:center">s.index</td><td style="text-align:center">获取Series索引</td></tr><tr><td style="text-align:center">s.describe()</td><td style="text-align:center">查看汇总统计</td></tr><tr><td style="text-align:center">s.T</td><td style="text-align:center">转置数据</td></tr><tr><td style="text-align:center">s.values</td><td style="text-align:center">获取s值</td></tr></tbody></table></div><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport pandas as pds = pd.Series([1,2,3], index = ['a', 'b', 'c']) # 查看前2个元素s.head(2)Out:    a    1    b    2    dtype: int64# 获取sizes.shapeOut:    (3,)# 查看索引s.indexOut:    Index(['a', 'b', 'c'], dtype='object')# 获取值s.valuesOut:    [1,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-2-查看DataFrame数据"><a href="#2-2-2-查看DataFrame数据" class="headerlink" title="2.2.2 查看DataFrame数据"></a>2.2.2 查看DataFrame数据</h4><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">df.head(n) / df.tail(n)</td><td style="text-align:center">查看df的前n行 / 后n行</td></tr><tr><td style="text-align:center">df.shape</td><td style="text-align:center">获取df的size，返回一个元组</td></tr><tr><td style="text-align:center">df.shape[0]</td><td style="text-align:center">获取df的行数</td></tr><tr><td style="text-align:center">df.shape[1]</td><td style="text-align:center">获取df的列数</td></tr><tr><td style="text-align:center">df.dtypes</td><td style="text-align:center">查看各列数据类型</td></tr><tr><td style="text-align:center">df.index</td><td style="text-align:center">显示行索引</td></tr><tr><td style="text-align:center">df.columns</td><td style="text-align:center">显示列索引</td></tr><tr><td style="text-align:center">df.describe()</td><td style="text-align:center">查看数值型列的汇总统计</td></tr><tr><td style="text-align:center">df.T</td><td style="text-align:center">转置数据</td></tr><tr><td style="text-align:center">df.values</td><td style="text-align:center">获取df值</td></tr></tbody></table></div><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport pandas as pddf = pd.DataFrame({'ID': ['001', '002', '003', '004'],                   'NAME': ['zhangsan', 'lisi', 'wangwu', 'zhaoliu'],                   'SCORE': [90, 100, 80, 85]})# 查看前2行df.head(2)Out:    ID      NAME  SCORE0  001  zhangsan     901  002      lisi    100# 获取sizedf.shapeOut:    (4, 3)# 获取行数df.shape[0]Out:    4# 查看列索引df.columnsOut:    Index(['ID', 'NAME', 'SCORE'], dtype='object')# 获取值df.valuesOut:    [['001' 'zhangsan' 90]     ['002' 'lisi' 100]     ['003' 'wangwu' 80]     ['004' 'zhaoliu' 85]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-数据选择"><a href="#2-3-数据选择" class="headerlink" title="2.3 数据选择"></a>2.3 数据选择</h3><h4 id="2-3-1-Series数据选择"><a href="#2-3-1-Series数据选择" class="headerlink" title="2.3.1 Series数据选择"></a>2.3.1 Series数据选择</h4><ul><li>将Series看作多维数组—通过索引选择数据</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = pd.Series([1,2,3], index = ['a', 'b', 'c']) # 显式索引切片s['b':'c']Out:    b    2    c    3    dtype: int64# 隐式整数索引切片s[0:1]Out:    a    1    dtype: int64# 掩码s[s > 1]Out:    b    2    c    3    dtype: int64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Series看作字典—通过键值选择数据</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = pd.Series([1,2,3], index = ['a', 'b', 'c']) s['b']list(s.items())'b' in sOut:    2    [('a', 1), ('b', 2), ('c', 3)]    True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用索引函数—loc、iloc</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># loc: 通过显示索引切片或取值s.loc['a']Out:    1# iloc: 通过隐式索引切片或取值s.iloc[1]Out:    2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-2-DataFrame数据选择"><a href="#2-3-2-DataFrame数据选择" class="headerlink" title="2.3.2 DataFrame数据选择"></a>2.3.2 DataFrame数据选择</h4><blockquote><p>以下示例用鸢尾花数据集来展示DataFrame数据选择用法；鸢尾花数据集每行一条记录，每条记录都有4项特征：花萼长度（Sepal.Length）、花萼宽度（Sepal.Width）、花瓣长度（Petal.Length）、花瓣宽度（Petal.Width），Species表示该条记录表示的鸢尾花属于哪种。</p></blockquote><h5 id="2-3-2-1-切片选择（-）"><a href="#2-3-2-1-切片选择（-）" class="headerlink" title="2.3.2.1 切片选择（[]）"></a>2.3.2.1 切片选择（[]）</h5><ul><li>使用列名</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">import numpy as npimport pandas as pd# 导入鸢尾花数据集   iris = pd.read_csv('E:\data\iris_dataset\iris.csv', usecols=[1, 2, 3, 4, 5]).head(5)Out:    Sepal.Length  Sepal.Width  Petal.Length  Petal.Width Species0           5.1          3.5           1.4          0.2  setosa1           4.9          3.0           1.4          0.2  setosa2           4.7          3.2           1.3          0.2  setosa3           4.6          3.1           1.5          0.2  setosa4           5.0          3.6           1.4          0.2  setosa# df[col]：根据列名，并以Series形式返回，不支持df[col1, col2]iris['Sepal.Length']type(iris['Sepal.Length'] Out:      0    5.1    1    4.9    2    4.7    3    4.6    4    5.0    Name: Sepal.Length, dtype: float64    <class 'pandas.core.series.Series'># df[[col]]iris[['Sepal.Length', 'Sepal.Width']]  # 得到带有列名的新DataFrametype(iris[['Sepal.Length', 'Sepal.Width']])Out:      Sepal.Length  Sepal.Width0           5.1          3.51           4.9          3.02           4.7          3.23           4.6          3.14           5.0          3.6<class 'pandas.core.frame.DataFrame'><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用布尔数组</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 筛选符合条件的行iris[iris['Sepal.Length'] > 5]Out:    Sepal.Length  Sepal.Width  Petal.Length  Petal.Width Species0           5.1          3.5           1.4          0.2  setosa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>选取行</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">iris[0:2]Out:     Sepal.Length  Sepal.Width  Petal.Length  Petal.Width Species0           5.1          3.5           1.4          0.2  setosa1           4.9          3.0           1.4          0.2  setosa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-2-2-按标签选择（loc）"><a href="#2-3-2-2-按标签选择（loc）" class="headerlink" title="2.3.2.2 按标签选择（loc）"></a>2.3.2.2 按标签选择（loc）</h5><blockquote><p>.loc是基于标签索引来选择，包括行标签（index）和列标签（column）。</p></blockquote><ul><li>使用行标签选择行</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 单个行标签，选择一行iris.loc[1] # 不能使用单个列标签Out:    Sepal.Length       4.9    Sepal.Width          3    Petal.Length       1.4    Petal.Width        0.2    Species         setosa    Name: 1, dtype: object# 选择一行iris.loc[1,:] # 输出与上面相同# 选择不连续行iris.loc[[0,2],:]Out:     Sepal.Length  Sepal.Width  Petal.Length  Petal.Width Species0           5.1          3.5           1.4          0.2  setosa2           4.7          3.2           1.3          0.2  setosa# 选择连续行iris.loc[0:1,:]Out:     Sepal.Length  Sepal.Width  Petal.Length  Petal.Width Species0           5.1          3.5           1.4          0.2  setosa1           4.9          3.0           1.4          0.2  setosa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用列标签选择列</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 选择一列iris.loc[:,'Sepal.Length']Out:    0    5.1    1    4.9    2    4.7    3    4.6    4    5.0    Name: Sepal.Length, dtype: float64# 选择多列iris.loc[:,['Sepal.Length','Sepal.Width']]Out:     Sepal.Length  Sepal.Width0           5.1          3.51           4.9          3.02           4.7          3.23           4.6          3.14           5.0          3.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>同时使用行、列标签选择</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">iris.loc[0:1,['Sepal.Length','Sepal.Width']]Out:    Sepal.Length  Sepal.Width0           5.1          3.51           4.9          3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用布尔数组，用于筛选符合某些条件的行</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">iris.loc[iris['Sepal.Length']>5]Out:    Sepal.Length  Sepal.Width  Petal.Length  Petal.Width Species0           5.1          3.5           1.4          0.2  setosairis.loc[(iris['Sepal.Length']>=5) & (iris['Sepal.Width']>3.5), ['Sepal.Length', 'Sepal.Width']]Out:    Sepal.Length  Sepal.Width4           5.0          3.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-2-3-按位置选择（iloc）"><a href="#2-3-2-3-按位置选择（iloc）" class="headerlink" title="2.3.2.3 按位置选择（iloc）"></a>2.3.2.3 按位置选择（iloc）</h5><blockquote><p>.iloc是基于位置索引来选择，包括行、列位置编号</p></blockquote><ul><li>使用行位置索引</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 选择一行iris.iloc[2] # 等价于 iris.iloc[2,:]Out:    Sepal.Length       4.7    Sepal.Width        3.2    Petal.Length       1.3    Petal.Width        0.2    Species         setosa    Name: 2, dtype: object# 选择多行iris.iloc[:2]  # iris.iloc[0:2], iris.iloc[:2,:]Out:    Sepal.Length  Sepal.Width  Petal.Length  Petal.Width Species0           5.1          3.5           1.4          0.2  setosa1           4.9          3.0           1.4          0.2  setosa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用列位置索引</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 选择一列iris.iloc[:,0]Out:    0    5.1    1    4.9    2    4.7    3    4.6    4    5.0    Name: Sepal.Length, dtype: float64# 选择连续多列iris.iloc[:,0:2]Out:     Sepal.Length  Sepal.Width0           5.1          3.51           4.9          3.02           4.7          3.23           4.6          3.14           5.0          3.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>同时使用行、列位置索引</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">iris.iloc[1:3,1:3]Out:     Sepal.Width  Petal.Length1          3.0           1.42          3.2           1.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用布尔数组，用于筛选符合某些条件的行</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python">iris.iloc[np.array(iris['Sepal.Length']>5),:] 或 iris.iloc[list(iris['Sepal.Length']>5),:]Out:     Sepal.Length  Sepal.Width  Petal.Length  Petal.Width Species0           5.1          3.5           1.4          0.2  setosa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-2-4-通过标签索引定位元素（at）"><a href="#2-3-2-4-通过标签索引定位元素（at）" class="headerlink" title="2.3.2.4 通过标签索引定位元素（at）"></a>2.3.2.4 通过标签索引定位元素（at）</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 定位单元格，通过行、列索引，快速定位DataFrame的元素iris.at[1,'Sepal.Length']Out:    4.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-2-5-通过位置索引定位元素（iat）"><a href="#2-3-2-5-通过位置索引定位元素（iat）" class="headerlink" title="2.3.2.5 通过位置索引定位元素（iat）"></a>2.3.2.5 通过位置索引定位元素（iat）</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 通过行、列位置索引（整数索引），快速定位DataFrame的元素iris.iat[1,0]Out:    4.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-2-6-筛选符合包含在序列中的数据（isin）"><a href="#2-3-2-6-筛选符合包含在序列中的数据（isin）" class="headerlink" title="2.3.2.6  筛选符合包含在序列中的数据（isin）"></a>2.3.2.6  筛选符合包含在序列中的数据（isin）</h5><pre class="line-numbers language-lang-python"><code class="language-lang-python">iris[iris['Sepal.Length'].isin([4.9,5.0])]Out:    Sepal.Length  Sepal.Width  Petal.Length  Petal.Width Species1           4.9          3.0           1.4          0.2  setosa4           5.0          3.6           1.4          0.2  setosa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-数据处理"><a href="#2-4-数据处理" class="headerlink" title="2.4 数据处理"></a>2.4 数据处理</h3><h4 id="2-4-1-缺失值"><a href="#2-4-1-缺失值" class="headerlink" title="2.4.1 缺失值"></a>2.4.1 缺失值</h4><blockquote><p>Pandas主要使用值np.nan来表示缺失的数据。 默认情况下，它不包含在计算中。</p></blockquote><ul><li>检查缺失值（pd.isnull()，pd.notnull()）</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 生成测试数据import numpy as npimport pandas as pdnp.random.seed(666)dates = pd.date_range('20190901', periods=4)df = pd.DataFrame(np.random.randn(4, 4), index=dates, columns=list('ABCD'))df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + ['E'])df1.loc[dates[0]:dates[1], 'E'] = 1Out:                 A         B         C         D    E2019-09-01  0.824188  0.479966  1.173468  0.909048  1.02019-09-02 -0.571721 -0.109497  0.019028 -0.943761  1.02019-09-03  0.640573 -0.786443  0.608870 -0.931012  NaN2019-09-04  0.978222 -0.736918 -0.298733 -0.460587  NaN<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python"># pd.isnull（isnull是isna别名）: 检查DataFrame对象中的空值，并返回一个Boolean数组pd.isnull(df1) # 等价于pd.isna(df1)、df1.isnull()Out:             A      B      C      D      E2019-09-01  False  False  False  False  False2019-09-02  False  False  False  False  False2019-09-03  False  False  False  False   True2019-09-04  False  False  False  False   True# pd.notnull(): 检查DataFrame对象中的非空值，并返回一个Boolean数组pd.notnull(df1) # 等价于pd.notna(df1)、df1.notna()Out:             A     B     C     D      E2019-09-01  True  True  True  True   True2019-09-02  True  True  True  True   True2019-09-03  True  True  True  True  False2019-09-04  True  True  True  True  False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除含有缺失值的行或列（df.dropna()）</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># df.dropna(axis=0, how='any'): axis=0表示index行,axis=1表示columns列，默认为0；how:"all"表示这一行或列中的元素全部缺失才删除这一行或列，"any"表示这一行或列中只要有元素缺失，就删除这一行或列。# df.dropna(): 删除所有包含空值的行df1.dropna()Out:                  A         B         C         D    E2019-09-01  0.824188  0.479966  1.173468  0.909048  1.02019-09-02 -0.571721 -0.109497  0.019028 -0.943761  1.0# df.dropna(axis=1)：删除所有包含空值的列df1.dropna(axis=1)Out:               A         B         C         D2019-09-01  0.824188  0.479966  1.173468  0.9090482019-09-02 -0.571721 -0.109497  0.019028 -0.9437612019-09-03  0.640573 -0.786443  0.608870 -0.9310122019-09-04  0.978222 -0.736918 -0.298733 -0.460587<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>填充缺失值</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># df.fillna(value)：用value值替换DataFrame对象中所有的空值df1.fillna(value=5)Out:                  A         B         C         D    E2019-09-01  0.824188  0.479966  1.173468  0.909048  1.02019-09-02 -0.571721 -0.109497  0.019028 -0.943761  1.02019-09-03  0.640573 -0.786443  0.608870 -0.931012  5.02019-09-04  0.978222 -0.736918 -0.298733 -0.460587  5.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-2-排序"><a href="#2-4-2-排序" class="headerlink" title="2.4.2 排序"></a>2.4.2 排序</h4><blockquote><p>Pandas 支持三种排序方式，按索引标签排序，按列里的值排序，按两种方式混合排序。</p></blockquote><h5 id="2-4-2-1-按索引排序"><a href="#2-4-2-1-按索引排序" class="headerlink" title="2.4.2.1 按索引排序"></a>2.4.2.1 按索引排序</h5><ul><li>Series按索引排序</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># Series.sort_index(ascending=True, inplace=False, na_position='last'): 默认ascending=True为升序排序; inplace默认为False，当inplace=True时，修改原数据; na_position默认为'last',将NaN放在最后。s = pd.Series([1,2,np.nan, 3], index = ['d', 'b', 'c', 'a'])s.sort_index()Out:    a    3.0    b    2.0    c    NaN    d    1.0    dtype: float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>DataFrame按索引排序</li></ul><pre class="line-numbers language-lang-python"><code class="language-lang-python"># DataFrame.sort_index(axis=0, ascending=True, inplace=False, na_position='last')import numpy as npimport pandas as pdnp.random.seed(666)df = pd.DataFrame({    'one': pd.Series(np.random.randn(3), index=['a', 'b', 'c']),    'two': pd.Series(np.random.randn(4), index=['a', 'b', 'c', 'd']),    'three': pd.Series(np.random.randn(3), index=['b', 'c', 'd'])})df1 = df.reindex(index=['a', 'd', 'c', 'b'], columns=['three', 'two', 'one'])Out:      three       two       onea       NaN  0.909048  0.824188d -0.786443  0.019028       NaNc  0.640573 -0.109497  1.173468b -0.943761 -0.571721  0.479966# df1.sort_index(axis=1)df1.sort_index(axis=1)Out:        one     three       twoa  0.824188       NaN  0.909048d       NaN -0.786443  0.019028c  1.173468  0.640573 -0.109497b  0.479966 -0.943761 -0.571721# df1['one'].sort_index()df1['one'].sort_index()Out:    a    0.824188    b    0.479966    c    1.173468    d         NaN    Name: one, dtype: float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-4-2-2-按值排序"><a href="#2-4-2-2-按值排序" class="headerlink" title="2.4.2.2 按值排序"></a>2.4.2.2 按值排序</h5><ul><li>Series按值排序</li></ul><pre><code>df.sort_values(axis=0, ascending=True, inplace=False, na_position='last')</code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python">s = pd.Series([np.nan, 1, 3, 7, 5])s.sort_values(na_position = 'first')Out:    0    NaN    1    1.0    2    3.0    4    5.0    3    7.0    dtype: float64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>DataFrame按值排序</li></ul><pre><code>df.sort_values(by=['列名'], ascending=True, inplace=False, na_position='last')</code></pre><p>参数说明：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>by</td><td>指定排序列名</td></tr><tr><td>ascending</td><td>排序方式，默认为升序</td></tr><tr><td>inplace</td><td>是否用排序后的数据集替换原数据，默认为False，即不替换</td></tr><tr><td>na_position</td><td>缺失值存放的位置，默认放在最后</td></tr></tbody></table></div><pre class="line-numbers language-lang-python"><code class="language-lang-python">df = pd.DataFrame({    'one': ['1', '3', '2', np.nan, '4'],    'two': [np.nan, 9, 8, 7, 10],    'three': [A, C, E, F, np.nan]})df.sort_values(by=['two', 'three'], ascending=[True, False], na_position='last')Out:   one   two   three3  NaN   7.0     F2    2   8.0     A1    3   9.0     C4    4  10.0   NaN0    1   NaN     E<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-3-去重"><a href="#2-4-3-去重" class="headerlink" title="2.4.3 去重"></a>2.4.3 去重</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">df.drop_duplicates(subset=None, keep='first', inplace=False)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数说明：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>subset</td><td>用来指定特定的列，默认所有列</td></tr><tr><td>keep</td><td>值选项{‘first’, ‘last’, False}，保留重复元素中的第一个、最后一个，或全部删除，默认保留第一项</td></tr><tr><td>inplace</td><td>是直接在原来数据上修改还是保留一个副本</td></tr></tbody></table></div><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 以单列去重df = pd.DataFrame({'A':[1,1,2,3,3], 'B':['a','b','c','d','d']})df1 = df.drop_duplicates(subset=['A'], keep='first', inplace=False)Out:       A  B    0  1  a    2  2  c    3  3  d# 以多列去重df = pd.DataFrame({'A':[1,1,2,3,3], 'B':['a','b','c','d','e']})df1 = df.drop_duplicates(subset=['A', 'B'], keep='first', inplace=False)Out:       A  B    0  1  a    1  1  b    2  2  c    3  3  d    4  3  e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-4-合并"><a href="#2-4-4-合并" class="headerlink" title="2.4.4 合并"></a>2.4.4 合并</h4><ul><li>merge</li></ul><pre><code>pd.merge(left, right, how='inner', on=None, left_on=None, right_on=None, left_index=False, right_index=False,             sort=True, suffixes=('_x', '_y'), copy=True, indicator=False, validate=None)</code></pre><p>参数说明：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>left / right</td><td>两个DataFrame对象。</td></tr><tr><td>how</td><td>合并方式：’left’, ‘right’, ‘outer’, ‘inner’，默认为’inner’。</td></tr><tr><td>on</td><td>指定要联结的列，left和right两个DataFrame有相同column情况下使用。</td></tr><tr><td>left_on / right_on</td><td>两个DataFrame没有相同情况下，指明左边和右边的参考列。</td></tr><tr><td>left_index / right_index</td><td>指定是否以行标签索引为参考进行合并。</td></tr><tr><td>sort</td><td>合并结果是否按on指定的参考column进行排序。</td></tr><tr><td>suffixes</td><td>合并后如果有重复column，分别加上后缀。</td></tr><tr><td>indicator</td><td>在合并的DataFrame中新增名为_merge的一列，指明每一行合并键源自哪个DataFrame。</td></tr><tr><td>validate</td><td>判断合并键中是否存在重复项。</td></tr></tbody></table></div><pre class="line-numbers language-lang-python"><code class="language-lang-python"># 指定一参考列，how='inner'left = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'],                       'A': ['A0', 'A1', 'A2', 'A3'],                       'B': ['B0', 'B1', 'B2', 'B3']}) right = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'],                      'C': ['C0', 'C1', 'C2', 'C3'],                       'D': ['D0', 'D1', 'D2', 'D3']})result = pd.merge(left, right, on='key') # 默认how='inner'Out:      key   A   B   C   D    0  K0  A0  B0  C0  D0    1  K1  A1  B1  C1  D1    2  K2  A2  B2  C2  D2    3  K3  A3  B3  C3  D3# 指定两参考列，how='inner'left = pd.DataFrame({'key1': ['K0', 'K0', 'K1', 'K2'],                      'key2': ['K0', 'K1', 'K0', 'K1'],                       'A': ['A0', 'A1', 'A2', 'A3'],                      'B': ['B0', 'B1', 'B2', 'B3']})right = pd.DataFrame({'key1': ['K0', 'K1', 'K1', 'K2'],                       'key2': ['K0', 'K2', 'K0', 'K0'],                      'C': ['C0', 'C1', 'C2', 'C3'],                       'D': ['D0', 'D1', 'D2', 'D3']}) result = pd.merge(left, right, on=['key1', 'key2'])Out:      key1 key2   A   B   C   D    0   K0   K0  A0  B0  C0  D0    1   K1   K0  A2  B2  C2  D2# how='left'，等价于SQL中的LEFT OUTER JOIN，以left DataFrame中的key为基准result = pd.merge(left, right, how='left', on=['key1', 'key2'])Out:      key1 key2   A   B    C    D    0   K0   K0  A0  B0   C0   D0    1   K0   K1  A1  B1  NaN  NaN    2   K1   K0  A2  B2   C2   D2    3   K2   K1  A3  B3  NaN  NaN#  how='right'，等价于SQL中的RIGHT OUTER JOIN，以right DataFrame中的key为基准result = pd.merge(left, right, how='right', on=['key1', 'key2'])Out:      key1 key2    A    B   C   D    0   K0   K0   A0   B0  C0  D0    1   K1   K0   A2   B2  C2  D2    2   K1   K2  NaN  NaN  C1  D1    3   K2   K0  NaN  NaN  C3  D3# how='outer'，等价于SQL中的FULL OUTER JOIN，以left和right DataFrame中的key并集为基准result = pd.merge(left, right, how='outer', on=['key1', 'key2'])      key1 key2    A    B    C    D    0   K0   K0   A0   B0   C0   D0    1   K0   K1   A1   B1  NaN  NaN    2   K1   K0   A2   B2   C2   D2    3   K2   K1   A3   B3  NaN  NaN    4   K1   K2  NaN  NaN   C1   D1    5   K2   K0  NaN  NaN   C3   D3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python">#  使用validate参数自动检查合并键中是否重复项。validate默认为None，可设置为'one_to_one、one_to_many、many_to_one、many_to_many'。left = pd.DataFrame({'A' : [1,2], 'B' : [1, 2]})right = pd.DataFrame({'A' : [4,5,6], 'B': [2, 2, 2]})result = pd.merge(left, right, on='B', how='outer', validate="one_to_one") # 报错result =  pd.merge(left, right, on='B', how='outer', validate="one_to_many") Out:   A_x  B  A_y0    1  1  NaN1    2  2  4.02    2  2  5.03    2  2  6.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python">#  indicator= True，_merge结果可能为：left_only，right_only，both。df1 = pd.DataFrame({'col1': [0, 1], 'col_left': ['a', 'b']})df2 = pd.DataFrame({'col1': [1, 2, 2], 'col_right': [2, 2, 2]})result = pd.merge(df1, df2, on='col1', how='outer', indicator=True) Out:    col1 col_left  col_right      _merge0     0        a        NaN   left_only1     1        b        2.0        both2     2      NaN        2.0  right_only3     2      NaN        2.0  right_only<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>concat</li></ul><pre><code>pd.concat(objs, axis=0, join='outer', ignore_index=False, keys=None, levels=None, names=None, verify_integrity=False, copy=True)</code></pre><p>常用参数说明：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>objs</td><td>要连接的对象，如Series、DataFrame。</td></tr><tr><td>axis</td><td>沿着哪个轴向连接，axis = {0, 1}，默认值为0，沿着行的方向；axis=1，沿着列的方向。</td></tr><tr><td>join</td><td>处理非合并方向的行（列），join = {‘outer’, ‘inner’}，默认值为’outer’。</td></tr><tr><td>ignore_index</td><td>默认值为False，合并后是否重建索引。</td></tr><tr><td>keys</td><td>创建层次化索引，默认值为None。</td></tr></tbody></table></div><pre class="line-numbers language-lang-python"><code class="language-lang-python">df1 = pd.DataFrame({'A': ['A0', 'A1', 'A2', 'A3'],                     'B': ['B0', 'B1', 'B2', 'B3'],                     'C': ['C0', 'C1', 'C2', 'C3'],                     'D': ['D0', 'D1', 'D2', 'D3']},                     index=[0, 1, 2, 3])df2 = pd.DataFrame({'B': ['B2', 'B3', 'B6', 'B7'],                     'D': ['D2', 'D3', 'D6', 'D7'],                     'F': ['F2', 'F3', 'F6', 'F7']},                    index=[2, 3, 6, 7]) # 沿着列合并，join='outer'result = pd.concat([df1, df2], axis=1, sort=False)Out:     A    B    C    D    B    D    F0   A0   B0   C0   D0  NaN  NaN  NaN1   A1   B1   C1   D1  NaN  NaN  NaN2   A2   B2   C2   D2   B2   D2   F23   A3   B3   C3   D3   B3   D3   F36  NaN  NaN  NaN  NaN   B6   D6   F67  NaN  NaN  NaN  NaN   B7   D7   F7# join='inner'result = pd.concat([df1, df2], axis=1, join='inner')Out:    A   B   C   D   B   D   F2  A2  B2  C2  D2  B2  D2  F23  A3  B3  C3  D3  B3  D3  F3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python"># ignore_index: 重建索引result = pd.concat([df1, df2], ignore_index=True, sort=False)Out:     A   B    C   D    F0   A0  B0   C0  D0  NaN1   A1  B1   C1  D1  NaN2   A2  B2   C2  D2  NaN3   A3  B3   C3  D3  NaN4  NaN  B2  NaN  D2   F25  NaN  B3  NaN  D3   F36  NaN  B6  NaN  D6   F67  NaN  B7  NaN  D7   F7# axis = 1result = pd.concat([df1, df2], axis=1, ignore_index=True, sort=False)Out:     0    1    2    3    4    5    60   A0   B0   C0   D0  NaN  NaN  NaN1   A1   B1   C1   D1  NaN  NaN  NaN2   A2   B2   C2   D2   B2   D2   F23   A3   B3   C3   D3   B3   D3   F36  NaN  NaN  NaN  NaN   B6   D6   F67  NaN  NaN  NaN  NaN   B7   D7   F7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>append</li></ul><pre><code>df.append(other, ignore_index=False, verify_integrity=False, sort=None)说明：竖方向合并，即添加行。other: 要添加的对象，如DataFrame, Series, list, dict等; ignore_index: 是否重建标签。</code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python">df3 = pd.DataFrame({'A': ['A4', 'A5', 'A6', 'A7'],                    'B': ['B4', 'B5', 'B6', 'B7'],                     'C': ['C4', 'C5', 'C6', 'C7'],                     'D': ['D4', 'D5', 'D6', 'D7']},                     index=[2, 3, 4, 5]) # verify_integrity=Truedf1.append(df3, verify_integrity=True) # 存在重复索引时报错df1.append(df3)Out:    A   B   C   D0  A0  B0  C0  D01  A1  B1  C1  D12  A2  B2  C2  D23  A3  B3  C3  D32  A4  B4  C4  D43  A5  B5  C5  D54  A6  B6  C6  D65  A7  B7  C7  D7# ignore_index=True，重建索引df1.append(df3, ignore_index=True)Out:    A   B   C   D0  A0  B0  C0  D01  A1  B1  C1  D12  A2  B2  C2  D23  A3  B3  C3  D34  A4  B4  C4  D45  A5  B5  C5  D56  A6  B6  C6  D67  A7  B7  C7  D7# 添加多个对象s1 = pd.Series(['X0', 'X1', 'X2', 'X3'], index=['A', 'B', 'C', 'D'])s2 = pd.Series(['Y0', 'Y1', 'Y2', 'Y3'], index=['A', 'B', 'C', 'D'])result = df1.append([s1, s2], ignore_index=True, sort=False)Out:    A   B   C   D0  A0  B0  C0  D01  A1  B1  C1  D12  A2  B2  C2  D23  A3  B3  C3  D30  X0  X1  X2  X31  Y0  Y1  Y2  Y3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-5-分组"><a href="#2-4-5-分组" class="headerlink" title="2.4.5 分组"></a>2.4.5 分组</h4><pre class="line-numbers language-lang-python"><code class="language-lang-python">np.random.seed(666)df = pd.DataFrame({'A': ['foo', 'bar', 'foo', 'bar',                        'foo', 'bar', 'foo', 'foo'],                   'B': ['one', 'one', 'two', 'three',                        'two', 'two', 'one', 'three'],                   'C': np.random.randn(8),                   'D': np.random.randn(8)})Out:     A      B         C         D0  foo    one  0.824188  0.6405731  bar    one  0.479966 -0.7864432  foo    two  1.173468  0.6088703  bar  three  0.909048 -0.9310124  foo    two -0.571721  0.9782225  bar    two -0.109497 -0.7369186  foo    one  0.019028 -0.2987337  foo  three -0.943761 -0.460587# 根据一列分组result = df.groupby('A')for item in result:    print(item)  # 元组类型Out:('bar',      A      B         C         D         1  bar    one  0.479966 -0.786443         3  bar  three  0.909048 -0.931012         5  bar    two -0.109497 -0.736918)('foo',      A      B         C         D         0  foo    one  0.824188  0.640573         2  foo    two  1.173468  0.608870         4  foo    two -0.571721  0.978222         6  foo    one  0.019028 -0.298733         7  foo  three -0.943761 -0.460587)# 对分组后的结果进行聚合计算result = df.groupby('A').mean()Out:          C         DA                      bar  0.426506 -0.818124foo  0.100240  0.293669# 根据多列分组result = df.groupby(['A', 'B']).sum()Out:               C         DA   B                        bar one    0.479966 -0.786443    three  0.909048 -0.931012    two   -0.109497 -0.736918foo one    0.843216  0.341841    three -0.943761 -0.460587    two    0.601747  1.587092<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Next主题的Hexo博客搭建与配置</title>
      <link href="/posts/2306985b.html"/>
      <url>/posts/2306985b.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>  Hexo是一个快速、简洁且高效的博客框架，使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。</p><h2 id="2-博客搭建"><a href="#2-博客搭建" class="headerlink" title="2. 博客搭建"></a>2. 博客搭建</h2><h3 id="2-1-准备环境"><a href="#2-1-准备环境" class="headerlink" title="2.1 准备环境"></a>2.1 准备环境</h3><ol><li>注册一个github账号。</li><li>安装node.js，参考：<a href="https://jingyan.baidu.com/article/48b37f8dd141b41a646488bc.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/48b37f8dd141b41a646488bc.html</a></li><li>安装Git，下载地址：<a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a></li></ol><h3 id="2-2-创建github仓库"><a href="#2-2-创建github仓库" class="headerlink" title="2.2 创建github仓库"></a>2.2 创建github仓库</h3><p>   新建一个名为<code>username.github.io</code>的仓库，比如，你的github用户名为zhangsan，则新建仓库zhangsan.github.io。</p><h3 id="2-3-配置SSH-key"><a href="#2-3-配置SSH-key" class="headerlink" title="2.3 配置SSH key"></a>2.3 配置SSH key</h3><ul><li>创建一个SSH key。（在Git bash命令行输入）</li></ul><pre><code>$ cd ~/. ssh    # 检查本机是否已存在ssh密钥</code></pre><p>如果提示：No such file or directory，则说明是第一次使用Git。然后，在命令行输入以下命令</p><pre><code>$ ssh-keygen -t rsa -C "邮箱地址"</code></pre><p>连续三次回车，在用户目录下生成一个密钥文件（.ssh\id_rsa.pub）。</p><ul><li>添加密钥到github</li></ul><p>  复制id_rsa.pub文件中的内容并添加到github。打开github个人主页，进入Settings -&gt; SSH and GPG keys -&gt; New SSH key:</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Hexo_20190505/1.png" style="zoom:50%;"></p><ul><li>测试是否添加成功</li></ul><pre><code>$ ssh -T git@github.com$ yes</code></pre><p>返回”You’ve successfully authenticated”，则说明添加成功。</p><h3 id="2-4-绑定域名"><a href="#2-4-绑定域名" class="headerlink" title="2.4 绑定域名"></a>2.4 绑定域名</h3><p>  可以不绑定域名，直接用默认的username.github.io来访问，也可以购买一个属于自己的域名。首先，需要注册一个域名，可以到<a href="https://sg.godaddy.com/zh/offers/domains/godaddycom?isc=gennbacn07&amp;countryview=1&amp;currencyType=CNY&amp;utm_source=Baidu&amp;utm_medium=cpc&amp;utm_term=Title&amp;utm_campaign=2019Brandzone%5FPC&amp;utm_content=Brandzone%5FPC&amp;gclid=CNql2LbdheICFYNOvAod4QMBcA&amp;gclsrc=ds" target="_blank" rel="noopener">godaddy</a>网站注册，也可以使用国内的<a href="https://wanwang.aliyun.com/?spm=5176.8142029.735711.62.3dbd6d3e5uxczh" target="_blank" rel="noopener">阿里云</a>，价格也比较便宜。我个人是使用的阿里云注册域名。</p><p>  然后，需要绑定域名。域名配置常用的两种方式：CNAME和A记录。</p><ul><li><p>添加CNAME记录指向<github账号名称>.github.io</github账号名称></p><p>类型选择为CNAME；</p><p>主机记录即域名前缀为：www;</p><p>记录值填写为<github账号名称>.github.io</github账号名称></p><p>解析线路，TTL默认即可。</p></li><li><p>添加A记录指向<github账号名称>.github.io对应的IP地址，可以通过CMD命令行输入：ping  <github账号名称>.github.io来查看。</github账号名称></github账号名称></p><p>类型选择为A；</p><p>主机记录及域名前缀为：@；</p><p>记录值填写IP；</p><p>解析线路，默认。</p></li><li><p>github仓库设置</p><ul><li>打开博客仓库Settings: …/github.io/Settings</li><li>在Custom domain下填写域名</li><li>在github项目根目录创建一个名为CNAME的文件（无后缀），里面填写域名。把CNAME文件Copy一份到本地项目站点目录source文件夹下，主要原因是github中的文件在每次提交后被覆盖。</li></ul></li></ul><h3 id="2-5-安装Hexo"><a href="#2-5-安装Hexo" class="headerlink" title="2.5 安装Hexo"></a>2.5 安装Hexo</h3><p>   在命令行（即Git Bash）运行一下命令：</p><pre><code>npm install -g hexo-cli</code></pre><p>初始化Hexo，在命令行运行以下命令：</p><pre><code>$ hexo init &lt;folder&gt;  # &lt;folder&gt;为存放Hexo初始化文件的路径，即站点目录，如我的目录为E：\hexo$ cd &lt;folder&gt;$ npm install</code></pre><p>运行结束后，在路径下生成hexo文件夹，文件夹目录：</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><p>注：</p><ul><li>站点配置文件：站点目录下的<code>_config.yml</code>，路径为<code>&lt;folder&gt;\_config.yml</code></li><li>主题配置文件：站点目录下themes文件夹下的，主题文件夹下的<code>_config.yml</code>，路径为<code>&lt;folder&gt;\themes\&lt;主题文件夹&gt;\_config.yml</code></li></ul><p>  在命令行（即Git Bash）运行以下命令：</p><pre><code>$ hexo g # 生成$ hexo s # 启动服务</code></pre><p>执行以上命令之后，会在public文件夹生成相关html文件，这些文件将来都是要提交到github。</p><p>打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到博客内容。</p><p>至此，Hexo已初步搭建在本地。</p><h3 id="2-6-上传到Github"><a href="#2-6-上传到Github" class="headerlink" title="2.6 上传到Github"></a>2.6 上传到Github</h3><p>配置_config.yml中有关deploy部分</p><pre><code>deploy:  type: git  repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git  branch: master</code></pre><p>还需要安装一个插件，运行以下命令：</p><pre><code>$ npm install hexo-deployer-git --save</code></pre><h3 id="2-7-常用hexo命令"><a href="#2-7-常用hexo命令" class="headerlink" title="2.7 常用hexo命令"></a>2.7 常用hexo命令</h3><pre><code>hexo new "postName"               #新建文章hexo new page "pageName"          #新建页面hexo generate                     #生成静态页面至public目录hexo server                       #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy                       #部署到GitHubhexo help                         #查看帮助hexo version                      #查看Hexo的版本</code></pre><p>命令缩写：</p><pre><code>hexo new = hexo nhexo generate = hexo ghexo server = hexo shexo deploy = hexo d</code></pre><p>本地修改，添加文章后，执行以下命令发布到github仓库</p><pre><code>hexo cleanhexo ghexo d</code></pre><h2 id="3-主题配置与优化"><a href="#3-主题配置与优化" class="headerlink" title="3. 主题配置与优化"></a>3. 主题配置与优化</h2><p>  在 Hexo 中有两份主要的配置文件，其名称都是 <code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p><h3 id="3-1-主题安装"><a href="#3-1-主题安装" class="headerlink" title="3.1 主题安装"></a>3.1 主题安装</h3><p>  Hexo博客支持很多主题风格，其中<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next</a>主题是Github上Star最多的主题。我主要是基于Next6主题进行的配置与优化。</p><p>*　下载Ｎext主题</p><p>在hexo站点目录下，启动Git Bash，运行以下命令：</p><pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>Next主题被下载到站点目录中themes文件夹下。</p><ul><li>启用Next主题</li></ul><p>打开<strong>站点配置文件</strong>：_config.yml，找到theme字段，将其值更改为next。</p><pre><code># Extensions# Plugins: https://hexo.io/plugins/# Themes: https://hexo.io/themes/theme: next# plugins: hexo-generate-feed</code></pre><h3 id="3-2-基本信息配置"><a href="#3-2-基本信息配置" class="headerlink" title="3.2 基本信息配置"></a>3.2 基本信息配置</h3><ul><li><blockquote><p>基本信息：博客标题、作者、描述、语言等等。</p></blockquote></li></ul><p>打开站点配置文件_config.yml，找到Site模块</p><pre><code>title: 标题subtitle: 副标题description: 描述keywords: 关键词author: 作者language: 语言（简体中文是zh-CN）timezone: 网站时区（Hexo 默认使用您电脑的时区）</code></pre><h3 id="3-3-主题配置"><a href="#3-3-主题配置" class="headerlink" title="3.3 主题配置"></a>3.3 主题配置</h3><h4 id="3-3-1-Next主题设定"><a href="#3-3-1-Next主题设定" class="headerlink" title="3.3.1 Next主题设定"></a>3.3.1 Next主题设定</h4><p>  Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持四种 Scheme:</p><pre><code>## Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini</code></pre><ul><li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li><li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li><li>Pisces - 双栏 Scheme，小家碧玉似的清新</li><li>Gemini- 左侧网站信息及目录，块+片段结构布局</li></ul><p>Scheme 的切换通过更改 <strong>主题配置文件</strong>，搜索 scheme 关键字，将你需用启用的 scheme 前面注释 <code>#</code> 去除即可。本人使用的是Gemini风格，可以选择自己喜欢的风格。</p><h4 id="3-3-2-菜单设置"><a href="#3-3-2-菜单设置" class="headerlink" title="3.3.2 菜单设置"></a>3.3.2 菜单设置</h4><p>  刚开始默认的菜单比较少，不满足我们的要求，可以自己添加。菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 <a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a> 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景。</p><p>打开<strong>主题配置文件</strong>，找到Menu Settings</p><pre><code>menu:  home: / || home                                 # 首页  archives: /archives/ || archive                 # 归档  categories: /categories/ || th                  # 分类  tags: /tags/ || tags                            # 标签  about: /about/ || user                          # 关于  #search: /search/ || search                     # 搜索  #schedule: /schedule/ || calendar               # 日程表  #sitemap: /sitemap.xml || sitemap               # 站点地图  #commonweal: /404/ || heartbeat                 # 公益404# Enable / Disable menu icons / item badges.    menu_settings:  icons: true       # 是否显示各个页面的图标  badges: true      # 是否显示分类/标签/归档页的内容量</code></pre><p>设置的菜单名称并不直接用于界面上的展示。Hexo 在生成的时候将使用这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放在 NexT 主题目录下<code>languages/{language}.yml</code>。</p><h4 id="3-3-3-侧栏设置"><a href="#3-3-3-侧栏设置" class="headerlink" title="3.3.3 侧栏设置"></a>3.3.3 侧栏设置</h4><blockquote><p>侧栏设置：位置、显示与否、文章间距、返回顶部按钮等等</p></blockquote><p>打开<strong>主题配置文件</strong>，找到sidebar字段。</p><pre><code>sidebar:  position: left        # 侧栏位置，只对Pisces和Gemini两种风格有效  #position: right  # Muse | Mist: 320     # 设置侧栏宽度，对于每一种风格默认宽度如注释内容所示  # Pisces | Gemini: 240  #width: 300  #  - post    expand on posts automatically. Default.  #  - always  expand for all pages automatically.  #  - hide    expand only when click on the sidebar toggle icon.  #  - remove  totally remove sidebar including sidebar toggle.  display: post    # 侧栏显示时机，只对Muse|Mist两种风格有效  offset: 12       # 文章间距，只对Pisces|Gemini两种风格有效  onmobile: false  # 是否在手机上显示侧边栏，只对Muse|Mist两种风格有效  dimmer: false    # 单击页面的任何空白部分关闭边栏，只对Muse|Mist有效back2top:  enable: true  # Back to top in sidebar.  sidebar: true  # Scroll percent label in b2t button.  scrollpercent: true   # 返回顶部按钮的百分比</code></pre><h3 id="3-4-主题优化"><a href="#3-4-主题优化" class="headerlink" title="3.4 主题优化"></a>3.4 主题优化</h3><h4 id="3-4-1-设置菜单页面"><a href="#3-4-1-设置菜单页面" class="headerlink" title="3.4.1 设置菜单页面"></a>3.4.1 设置菜单页面</h4><ul><li>添加分类模块</li></ul><pre><code>$ hexo n page categories</code></pre><p>执行上述命令，在站点目录的source文件夹下生成一个categories文件夹，打开categories文件夹中的index.md文件，将title设置为title:分类，type设置为type: categories。同时，参考3.3.2，将categories注释取消。</p><ul><li>添加标签模块</li></ul><pre><code>$ hexo new page tags</code></pre><p>执行上述命令，在source文件夹下生成一个tags文件夹，打开tags文件夹中的index.md文件，将title设置为title: 标签，type设置为type: tags。参考3.3.2，将tags注释取消。</p><ul><li>添加关于模块</li></ul><pre><code>$ hexo new page about</code></pre><p>执行上述命令，在source文件夹下生成一个about文件夹，打开index.md文件，可以添加信息。参考3.3.2，取消about注释。</p><ul><li><p>添加搜索功能</p><ul><li>安装插件</li></ul><p>在站点目录下，启动Git Bash，运行以下命令：</p><pre><code>$ npm install hexo-generator-searchdb --save</code></pre><ul><li>修改站点配置文件</li></ul><p>在站点配置文件中，添加以下内容：</p><pre><code># 搜索search:  path: search.xml  field: post  format: html  limit: 10000</code></pre><ul><li>修改主题配置文件</li></ul><p>在主题配置文件中，搜索local_search字段，将enable修改为true。</p><pre><code>local_search:  enable: true  # If auto, trigger search by changing input.  # If manual, trigger search by pressing enter key or search button.  trigger: auto  # Show top n results per article, show all results by setting to -1  top_n_per_article: 1  # Unescape html strings to the readable one.  unescape: false</code></pre></li></ul><h4 id="3-4-2-设置头像"><a href="#3-4-2-设置头像" class="headerlink" title="3.4.2 设置头像"></a>3.4.2 设置头像</h4><p>  编辑<strong>主题配置文件</strong>，修改字段avatar，值设置成头像的链接地址。其中头像的链接地址可以是</p><div class="table-container"><table><thead><tr><th style="text-align:left">地址</th><th style="text-align:left">值</th></tr></thead><tbody><tr><td style="text-align:left">完整的互联网URI</td><td style="text-align:left"><code>http://example.com/avatar.png</code></td></tr><tr><td style="text-align:left">站点内的地址</td><td style="text-align:left">将头像放置主题目录下的 <code>source/uploads/</code> （新建 uploads 目录若不存在） <br>配置为：<code>avatar: /uploads/avatar.png</code><br>或者放置在 <code>source/images/</code> 目录下  <br>配置为：<code>avatar: /images/avatar.png</code></td></tr></tbody></table></div><pre><code>avatar:  url: /images/avatar.gif     # 头像路径  # If true, the avatar would be dispalyed in circle.  rounded: false        # 头像边框形状是否设置为圆形  # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.  opacity: 1  # If true, the avatar would be rotated with the cursor.  rotated: false   # 鼠标移动到头像上，是否发生旋转</code></pre><h4 id="3-4-3-设置RSS"><a href="#3-4-3-设置RSS" class="headerlink" title="3.4.3 设置RSS"></a>3.4.3 设置RSS</h4><ol><li>安装hexo-generator-feed插件</li></ol><pre><code>$ npm install hexo-generator-feed --save</code></pre><ol><li>打开<strong>站点配置文件</strong>，在Extensions之后添加：</li></ol><pre><code># RSS订阅feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '</code></pre><ol><li>打开<strong>主题配置文件</strong>，找到rss，设置为</li></ol><pre><code>rss: /atom.xml</code></pre><h4 id="3-4-4-添加阅读全文按钮"><a href="#3-4-4-添加阅读全文按钮" class="headerlink" title="3.4.4 添加阅读全文按钮"></a>3.4.4 添加阅读全文按钮</h4><p>  在主页会显示多篇文章，如果想每篇文章只显示部分内容，其余内容需要点击<strong>阅读全文</strong>按钮来进一步查看，则需要在每篇文章中添加：</p><pre><code>显示的内容&lt;!--more--&gt;不显示的内容</code></pre><h4 id="3-4-5-修改文章内链接样式"><a href="#3-4-5-修改文章内链接样式" class="headerlink" title="3.4.5 修改文章内链接样式"></a>3.4.5 修改文章内链接样式</h4><p>  打开themes\next\source\css_common\components\post\post.styl，在末尾添加</p><pre><code>// 文章内链接文本样式.post-body p a {  color: #0593d3;  border-bottom: none;  border-bottom: 1px solid #0593d3;  &amp;:hover {    color: #fc6423;    border-bottom: none;    border-bottom: 1px solid #fc6423;  }}</code></pre><h4 id="3-4-6-添加评论系统—Valine"><a href="#3-4-6-添加评论系统—Valine" class="headerlink" title="3.4.6 添加评论系统—Valine"></a>3.4.6 添加评论系统—Valine</h4><ol><li>注册LeanCloud</li></ol><p>  注册后需要创建一个应用，名字可以随便起，我的应用名称为&lt;域名&gt;.counter。然后进入<strong>应用</strong>-&gt;<strong>设置</strong>-&gt;<strong>应用Key</strong>，获取<strong>App ID</strong>和<strong>App Key</strong>。</p><ol><li>打开<strong>主题配置文件</strong>，</li></ol><pre><code>valine:  enable: true   appid: 填写App ID  appkey: 填写App Key  notify: true    # mail notifier, See: https://github.com/xCss/Valine/wiki  verify: true    # Verification code  placeholder: 欢迎交流讨论...   # comment box placeholder  avatar: mm   # gravatar style  guest_info: nick,mail,link   # custom comment header  pageSize: 10    # pagination size  language:    # language, available values: en, zh-cn  visitor: false  comment_count: true</code></pre><ol><li>添加域名</li></ol><p>  在LeanCloud中，选择<strong>设置</strong>-&gt;<strong>安全中心</strong>-&gt;<strong>Web安全域名</strong>，添加自己的博客域名。</p><h4 id="3-4-7-添加文章阅读量"><a href="#3-4-7-添加文章阅读量" class="headerlink" title="3.4.7 添加文章阅读量"></a>3.4.7 添加文章阅读量</h4><ol><li>利用LeanCloud的统计功能，基于3.4.6创建的应用，添加一个名为Counter的类（Class）。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Hexo_20190505/2.png" style="zoom:50%;"></p><ol><li>修改<strong>主题配置文件</strong>，找到leancloud配置项，添加app_id和app_key。</li></ol><pre><code>leancloud_visitors:  enable: true  app_id: 添加LeanCloud App ID  app_key: 添加LeanCloud App Key  security: false  betterPerformance: false</code></pre><h4 id="3-4-8-统计字数"><a href="#3-4-8-统计字数" class="headerlink" title="3.4.8 统计字数"></a>3.4.8 统计字数</h4><ol><li>打开站点目录，运行Git Bash，安装<code>hexo-symbols-count-time</code>插件</li></ol><pre><code>$ npm install hexo-symbols-count-time --save</code></pre><ol><li>修改<strong>站点配置文件</strong>，找到<code>symbols_count_time</code>字段。</li></ol><pre><code>symbols_count_time:  symbols: true  time: true  total_symbols: true  total_time: true</code></pre><ol><li>打开<strong>主题配置文件</strong>，搜索<code>symbols_count_time</code>，按以下方式修改：</li></ol><pre><code>symbols_count_time:  separated_meta: true  item_text_post: true    # 文章是否显示文字（本文字数|阅读时长）  item_text_total: true   # 网页底部是否显示文字（站点总字数|站点阅读时长）   awl: 4  wpm: 275</code></pre><h4 id="3-4-9-添加动态背景"><a href="#3-4-9-添加动态背景" class="headerlink" title="3.4.9 添加动态背景"></a>3.4.9 添加动态背景</h4><p>  新版的Next已集成了该功能。打开<strong>主题配置文件</strong>，选择动态背景，enable设置为true。</p><pre><code>canvas_nest:  enable: true  onmobile: true # display on mobile or not  color: "0,0,255" # RGB values, use ',' to separate  opacity: 0.5 # the opacity of line: 0~1  zIndex: -1 # z-index property of the background  count: 99 # the number of lines# JavaScript 3D library.# Dependencies: https://github.com/theme-next/theme-next-three# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Canvas-ribbon# Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon:  enable: false  size: 300  alpha: 0.6  zIndex: -1</code></pre><h4 id="3-4-10-添加页面宠物"><a href="#3-4-10-添加页面宠物" class="headerlink" title="3.4.10 添加页面宠物"></a>3.4.10 添加页面宠物</h4><ol><li>安装hexo-helper-live2d插件</li></ol><pre><code>npm install -save hexo-helper-live2d</code></pre><ol><li>打开<strong>站点配置文件</strong>，添加：</li></ol><pre><code>live2d:  enable: true  scriptFrom: local  pluginRootPath: live2dw/  pluginJsPath: lib/  pluginModelPath: assets/  tagMode: false  model:    use: live2d-widget-model-wanko  #选择哪种模型  display: #放置位置和大小    position: right    width: 150    height: 300  mobile:    show: false #是否在手机端显示</code></pre><ol><li>下载<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">模型</a>，我安装的是live2d-widget-model-wanko。</li></ol><pre><code>$ npm install live2d-widget-model-wanko</code></pre><h4 id="3-4-11-文章末尾添加版权声明"><a href="#3-4-11-文章末尾添加版权声明" class="headerlink" title="3.4.11 文章末尾添加版权声明"></a>3.4.11 文章末尾添加版权声明</h4><p>  打开<strong>主题配置文件</strong>，找到creative_commons字段。</p><pre><code>creative_commons:  license: by-nc-sa  sidebar: false  post: true  language:</code></pre><p>修改URL，在页面底端的本文链接修改为自己的博客域名。</p><pre><code># URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://linwang93.cnroot: /permalink: :year/:month/:day/:title/permalink_defaults:</code></pre><h4 id="3-4-12-点击图片实现全屏查看"><a href="#3-4-12-点击图片实现全屏查看" class="headerlink" title="3.4.12  点击图片实现全屏查看"></a>3.4.12  点击图片实现全屏查看</h4><ol><li>切换到lib目录，路径：…/themes/next/source/lib</li><li>下载fancybox插件</li></ol><pre><code>$ git clone https://github.com/theme-next/theme-next-fancybox3 fancybox</code></pre><ol><li>更改<strong>主题配置文件</strong>，找到fancybox字段，修改为true。</li></ol><pre><code>$ fancybox: true</code></pre><h4 id="3-4-13-设置代码块样式"><a href="#3-4-13-设置代码块样式" class="headerlink" title="3.4.13 设置代码块样式"></a>3.4.13 设置代码块样式</h4><p>  打开<strong>主题配置文件</strong>，修改代码样式。</p><pre><code># Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night   # normal</code></pre><h4 id="3-4-14-文章结束标志"><a href="#3-4-14-文章结束标志" class="headerlink" title="3.4.14 文章结束标志"></a>3.4.14 文章结束标志</h4><ol><li>在…\\themes\next\layout_macro路径下新建<code>passage-end-tag.swig</code>文件，并添加以下内容：</li></ol><pre><code>&lt;div&gt;    {% if not is_index %}        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束 <i class="fa fa-paw"> </i>感谢您的阅读-------------</div>    {% endif %}&lt;/div&gt;</code></pre><ol><li>打开…\\themes\next\layout_macro路径下的post.wing文件，在<code>post-body</code> 之后(<code>END POST BODY</code>)， <code>post-footer</code> 之前添加如代码：</li></ol><pre><code>  &lt;div&gt;    {% if not is_index %}      {% include 'passage-end-tag.swig' %}    {% endif %}  &lt;/div&gt;</code></pre><ol><li>打开主题配置文件，添加如下内容：</li></ol><pre><code># 文章末尾添加“本文结束”标记passage_end_tag:  enabled: true</code></pre><h4 id="3-4-15-设置博客底部布局"><a href="#3-4-15-设置博客底部布局" class="headerlink" title="3.4.15 设置博客底部布局"></a>3.4.15 设置博客底部布局</h4><blockquote><p>建站时间、作者、访客人数、访问量等等。</p></blockquote><ol><li>设置建站时间、作者等。</li></ol><pre><code>footer:  since: 2019  icon:    name: user    animated: true    # Change the color of icon, using Hex Code.    color: "#808080"  copyright: Lin Wang  powered:    # Hexo link (Powered by Hexo).    enable: false    # Version info of Hexo after Hexo link (vX.X.X).    version: false  theme:    # Theme &amp; scheme info link (Theme - NexT.scheme).    enable: false    # Version info of NexT after scheme info (vX.X.X).    version: false</code></pre><ol><li>添加访客人数和访问量</li></ol><p>  NexT提供了busuanzi来统计。打开<strong>主题配置文件</strong>，找到busuanzi_count字段。</p><pre><code>busuanzi_count:  enable: true  total_visitors: true  total_visitors_icon: user  total_views: true  total_views_icon: eye  post_views: true  post_views_icon: eye</code></pre><h4 id="3-4-16-给页面、侧边栏添加背景图片"><a href="#3-4-16-给页面、侧边栏添加背景图片" class="headerlink" title="3.4.16 给页面、侧边栏添加背景图片"></a>3.4.16 给页面、侧边栏添加背景图片</h4><p>  打开<code>theme/next/source/css/_custom/custom.styl</code>，添加以下代码：</p><pre><code>// Custom styles.body {    background:url(/images/background.jpg);   # 背景图片    background-repeat: no-repeat;    background-attachment:fixed;    background-position:50% 50%;    background-size:cover;}</code></pre><h4 id="3-4-17-设置个人社交图标链接"><a href="#3-4-17-设置个人社交图标链接" class="headerlink" title="3.4.17 设置个人社交图标链接"></a>3.4.17 设置个人社交图标链接</h4><p>  打开<strong>主题配置文件</strong>，找到social字段，修改如下内容。这里仅展示了简书和E-mail两个，如果添加其他项，取消注释即可。</p><pre><code>social:  简书: https://www.jianshu.com/u/90e6990238e4  #GitHub: https://github.com/yourname || github  E-Mail: mailto:lwang1407@163.com || envelope  #Weibo: https://weibo.com/yourname || weibo  #Google: https://plus.google.com/yourname || google  #Twitter: https://twitter.com/yourname || twitter  #FB Page: https://www.facebook.com/yourname || facebook  #VK Group: https://vk.com/yourname || vk  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow  #YouTube: https://youtube.com/yourname || youtube  #Instagram: https://instagram.com/yourname || instagram  #Skype: skype:yourname?call|chat || skypesocial_icons:  enable: true  icons_only: false  transition: false  简书: book</code></pre><h4 id="3-4-18-设置左上角或右上角的fork-me-on-github效果"><a href="#3-4-18-设置左上角或右上角的fork-me-on-github效果" class="headerlink" title="3.4.18 设置左上角或右上角的fork me on github效果"></a>3.4.18 设置左上角或右上角的fork me on github效果</h4><p>  选择需要的<a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">GitHub Ribbons</a>效果，复制所选择效果的代码。然后打开…/themes/next/layout/_layout.swig，将复制的代码粘贴到<code>&lt;div class="headband"&gt;&lt;/div&gt;</code>之间。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Hexo_20190505/3.png" alt></p><hr><p><strong>到这里,Hexo博客的基础搭建与配置就介绍完了。具体效果可以访问我的博客：<a href="https://www.linwang93.cn/">https://www.linwang93.cn/</a></strong></p><h2 id="4-Hexo多电脑同步"><a href="#4-Hexo多电脑同步" class="headerlink" title="4. Hexo多电脑同步"></a>4. Hexo多电脑同步</h2><p>  我们经常有一个需求：在不同电脑上撰写博客文章并发布，这就涉及了如何在多台电脑的同步问题。这里参考了一些博客，总结了Hexo的多电脑同步方法，并亲测了方法的有效。</p><p>  主要思路:（1）Hexo私有仓库—保存Hexo源文件；（2）master公开仓库—保存Hexo生成的博客文件。</p><h3 id="4-1-创建私有仓库"><a href="#4-1-创建私有仓库" class="headerlink" title="4.1 创建私有仓库"></a>4.1 创建私有仓库</h3><p>  首先，已利用Hexo和github构建了博客，在本地有hexo配置源文件，在github中创建了仓库用于保存Hexo生成的博客文件。在github中再创建一个私有仓库，用于保存hexo配置源文件，我的仓库名为hexo-private。</p><h3 id="4-2-建立本地git仓库"><a href="#4-2-建立本地git仓库" class="headerlink" title="4.2 建立本地git仓库"></a>4.2 建立本地git仓库</h3><ol><li>删除已有的Hexo文件夹中的主题git配置，比如我使用的是Next主题，删除该主题文件夹中的.git文件夹。如果存在多个主题文件夹，则需要都删除。</li></ol><pre><code>rm -rf ./themes/next/.git/</code></pre><ol><li>创建一个.gitignore文件，并放在Hexo的根目录。.gitignore文件夹在Hexo根目录可能已经存在了，如果存在了，则无需再创建，检查.gitignore文件中的内容，内容为</li></ol><pre><code>.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre><ol><li>建立本地git仓库</li></ol><p>  进入Hexo根目录，执行如下命令：</p><pre><code>git init</code></pre><h3 id="4-3-本地仓库push到私有仓库"><a href="#4-3-本地仓库push到私有仓库" class="headerlink" title="4.3 本地仓库push到私有仓库"></a>4.3 本地仓库push到私有仓库</h3><pre><code>git remote add origin git@github.com:&lt;yourname&gt;/hexo-private.gitgit add .git commit -m "my first private hexo"git push -u origin master</code></pre><p>执行以上命令后，就完成了本地Hexo配置文件的备份。</p><p><strong>注：</strong>Hexo根目录中的.gitignore文件没有忽略到theme这文件夹，但是使用的Next主题文件夹原来是用git管理的，里面还有一个.gitigore文件，把themes/next/source/lib目录下的很多文件忽略掉了，这就导致上传到私有仓库时，themes/next/source/lib目录下的很多必要文件给忽略掉了，并没有上传。当在新电脑中，将该私有仓库拉下来，执行hexo g、hexo s命令后，会发现页面不能正常显示。<u>为了解决这个问题，在新电脑中将私有仓库Hexo配置源文件clone下来后，需要将原电脑Hexo文件夹下themes/next/source/lib/目录下所有文件全部复制粘贴到新电脑对应的themes/next/source/lib/目录下，这样就可以正常预览了。</u></p><h3 id="4-4-新电脑上Hexo配置"><a href="#4-4-新电脑上Hexo配置" class="headerlink" title="4.4 新电脑上Hexo配置"></a>4.4 新电脑上Hexo配置</h3><p>  在新电脑上使用Hexo撰写博客时，首先需要搭建并配置好node/npm/git/hexo等环境。node/npm/git等配置可百度查询安装配置。</p><ol><li>从私有仓库拉取Hexo配置源文件</li></ol><pre><code>git clone git@github.com:&lt;yourname&gt;/hexo-private.git</code></pre><ol><li>在Hexo-private目录下，在命令行（Git bash）执行如下命令安装配置hexo所需的环境</li></ol><pre><code>npm install -g hexo-clinpm install</code></pre><ol><li>撰写博客并发布</li></ol><p>  在新电脑上撰写博客文章，在本地预览。</p><pre><code>hexo ghexo s</code></pre><p>  在本地预览无误后，将博客文件推送到github博客公开仓库。</p><pre><code>hexo d</code></pre><p>  执行git status检查更改的文件，并将配置源文件push到私有仓库，完成Hexo配置源文件私有仓库同步更新。</p><pre><code>git statusgit add .git commit -m 'message自定义'git push</code></pre><p><strong>注：</strong>在用hexo d部署时，需要将新电脑上的ssh密钥添加到github中。</p><h3 id="4-5-Hexo仓库更新"><a href="#4-5-Hexo仓库更新" class="headerlink" title="4.5 Hexo仓库更新"></a>4.5 Hexo仓库更新</h3><p>  在其他电脑可能对私有仓库中的Hexo配置源文件作了修改，因此在新电脑上每次要先把远程私有仓库最新的配置源文件拉到本地。</p><pre><code>git fetch --all #将git上所有文件拉取到本地git reset --hard origin/master  #强制将本地内容指向刚刚同步git云端内容</code></pre><hr><p>参考: </p><p>[1] <a href="http://ricky.moe/2017/01/13/hexo-perfect-synchronize/" target="_blank" rel="noopener">http://ricky.moe/2017/01/13/hexo-perfect-synchronize/</a></p><p>[2] <a href="https://www.alankeene.com/2019/0102/hexo-perfect-synchronize.html" target="_blank" rel="noopener">https://www.alankeene.com/2019/0102/hexo-perfect-synchronize.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件安装与配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora使用教程</title>
      <link href="/posts/64297bf3.html"/>
      <url>/posts/64297bf3.html</url>
      
        <content type="html"><![CDATA[<p>  说明：Markdown是一种<strong>轻量级</strong>标记语言，允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。</p><hr><h1 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h1><h2 id="1-1-内容目录"><a href="#1-1-内容目录" class="headerlink" title="1.1 内容目录"></a>1.1 内容目录</h2><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">[toc]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-2-标题"><a href="#1-2-标题" class="headerlink" title="1.2 标题"></a>1.2 标题</h2><pre class="line-numbers language-lang-markdown"><code class="language-lang-markdown">＃　　　　　　　　　一级标题＃＃　　　　　　　　二级标题＃＃＃　　　　　　　三级标题＃＃＃＃　　　　　　四级标题＃＃＃＃＃　　　　　五级标题＃＃＃＃＃＃　　　　六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-引用"><a href="#1-3-引用" class="headerlink" title="1.3 引用"></a>1.3 引用</h2><pre><code>&gt;引用1&gt;&gt;引用2</code></pre><h2 id="1-4-无序列表"><a href="#1-4-无序列表" class="headerlink" title="1.4 无序列表"></a>1.4 无序列表</h2><ul><li>内容1</li><li>内容2</li></ul><pre><code>-空格 或 +空格 或 *空格。</code></pre><h2 id="1-5-有序列表"><a href="#1-5-有序列表" class="headerlink" title="1.5 有序列表"></a>1.5 有序列表</h2><pre><code>.后面有一个空格</code></pre><ol><li><p>内容1</p></li><li><p>内容2</p></li></ol><h2 id="1-6-任务列表"><a href="#1-6-任务列表" class="headerlink" title="1.6 任务列表"></a>1.6 任务列表</h2><pre><code>用[ ]（完成）或[x]（未完成）表示列表，通过点击复选框来更改状态。- [ ]- [x]</code></pre><ul><li><p>[ ] 内容1</p></li><li><p>[x] 内容2</p></li></ul><h2 id="1-7-表格"><a href="#1-7-表格" class="headerlink" title="1.7 表格"></a>1.7 表格</h2><pre><code>1. 快捷键：Ctrl+T，出现一个表格设置，预先设定行数和列数2. |姓名|性别|年龄|，按回车键</code></pre><div class="table-container"><table><thead><tr><th>姓名</th><th>性别</th><th>年龄</th></tr></thead><tbody><tr><td>张三</td><td>男</td><td>23</td></tr><tr><td>李四</td><td>男</td><td>21</td></tr><tr><td>王五</td><td>男</td><td>24</td></tr></tbody></table></div><h2 id="1-8-代码块"><a href="#1-8-代码块" class="headerlink" title="1.8 代码块"></a>1.8 代码块</h2><pre><code>~~~语言 回车​```语言 回车</code></pre><pre class="line-numbers language-lang-python"><code class="language-lang-python">print('hello world!')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-9-图片"><a href="#1-9-图片" class="headerlink" title="1.9 图片"></a>1.9 图片</h2><pre><code>![timg.jpg](https://upload-images.jianshu.io/upload_images/6226097-1613f3353bb9ec89.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&lt;img src="链接" width="50%"&gt; 可以设置图片尺寸</code></pre><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/Img/1.jpg" style="zoom:80%;"></p><h2 id="1-10-超链接"><a href="#1-10-超链接" class="headerlink" title="1.10 超链接"></a>1.10 超链接</h2><pre><code>[百度][https://www.baidu.com/][简书](http://www.jianshu.com)</code></pre><p>[百度][<a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a>]</p><p><a href="http://www.jianshu.com" target="_blank" rel="noopener">简书</a></p><pre><code>[CSDN][CSDN网址][CSDN网址]:https://www.csdn.net/</code></pre><p><a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a></p><h1 id="2-格式"><a href="#2-格式" class="headerlink" title="2. 格式"></a>2. 格式</h1><h2 id="2-1-强调"><a href="#2-1-强调" class="headerlink" title="2.1 强调"></a>2.1 强调</h2><pre><code>*content*</code></pre><p><em>content</em></p><h2 id="2-2-加粗"><a href="#2-2-加粗" class="headerlink" title="2.2 加粗"></a>2.2 加粗</h2><pre><code>**content**</code></pre><p><strong>content</strong></p><h2 id="2-3-删除线"><a href="#2-3-删除线" class="headerlink" title="2.3 删除线"></a>2.3 删除线</h2><pre><code>~~content~~</code></pre><p><del>content</del></p><h2 id="2-4-下划线"><a href="#2-4-下划线" class="headerlink" title="2.4 下划线"></a>2.4 下划线</h2><pre><code>&lt;u&gt;content&lt;/u&gt;</code></pre><p><u>content</u></p><h2 id="2-5-Emoji表情"><a href="#2-5-Emoji表情" class="headerlink" title="2.5 Emoji表情"></a>2.5 Emoji表情</h2><pre><code>用两个::包含单词，:happy:</code></pre><p>:happy:</p><h2 id="2-6-高亮"><a href="#2-6-高亮" class="headerlink" title="2.6 高亮"></a>2.6 高亮</h2><pre><code>==content==，这个功能默认是关闭的，选择Typora文件-&gt;偏好设置-&gt;markdown高亮复选框</code></pre><p>==content==</p><h2 id="2-7-斜体"><a href="#2-7-斜体" class="headerlink" title="2.7 斜体"></a>2.7 斜体</h2><pre><code>*content*_content_</code></pre><p>_content_</p><h2 id="2-8-分割线"><a href="#2-8-分割线" class="headerlink" title="2.8 分割线"></a>2.8 分割线</h2><pre><code>***---</code></pre><hr><h2 id="2-9-特殊字符"><a href="#2-9-特殊字符" class="headerlink" title="2.9 特殊字符"></a>2.9 特殊字符</h2><pre><code>&amp;copy;      版权      &amp;reg;       注册商标&amp;trade;     商标&amp;nbsp;      空格&amp;amp;       和号&amp;quot;      引号&amp;apos;      撇号&amp;lt;        小于号&amp;gt;        大于号&amp;ne;        不等号&amp;le;        小于等于&amp;ge;        大于等于&amp;cent;      分&amp;pound;     磅&amp;euro;      欧元&amp;yen;       元&amp;sect;      节&amp;times;     乘号&amp;divide;    除号&amp;plusmn;    正负号</code></pre><h2 id="2-10-换行"><a href="#2-10-换行" class="headerlink" title="2.10 换行"></a>2.10 换行</h2><pre><code>方法1：连续两个空格+回车方法2：使用html语言换行标签：&lt;br&gt;</code></pre><h2 id="2-11-首行缩进两个字符"><a href="#2-11-首行缩进两个字符" class="headerlink" title="2.11 首行缩进两个字符"></a>2.11 首行缩进两个字符</h2><pre><code>每个表示一个空格，连续使用两个即可&amp;ensp; 半角的空格&amp;emsp; 全角的空格</code></pre><h2 id="2-12-字体、字号与颜色"><a href="#2-12-字体、字号与颜色" class="headerlink" title="2.12 字体、字号与颜色"></a>2.12 字体、字号与颜色</h2><pre><code>&lt;font face="黑体"&gt;黑体&lt;/font&gt;&lt;font color=#0099ff size=5 face="黑体"&gt;color=#0099ff size=72 face="黑体"&lt;/font&gt;</code></pre><font face="黑体">黑体</font><font color="#0099ff" size="5" face="黑体">color=#0099ff size=72 face="黑体"</font><h2 id="2-13-背景色"><a href="#2-13-背景色" class="headerlink" title="2.13 背景色"></a>2.13 背景色</h2><pre><code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色是：blue&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></pre><table><tbody><tr><td bgcolor="orange">背景色是：blue</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10平台下MySQL5.7安装和配置</title>
      <link href="/posts/e8fca04b.html"/>
      <url>/posts/e8fca04b.html</url>
      
        <content type="html"><![CDATA[<p>  本文介绍在Win10系统下MySQL数据库管理系统的下载、安装和配置，并利用Navicat连接MySQL。</p><h2 id="1-下载MySQL5-7安装文件"><a href="#1-下载MySQL5-7安装文件" class="headerlink" title="1. 下载MySQL5.7安装文件"></a>1. 下载MySQL5.7安装文件</h2><p>  进入<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL Community Server</a>，找到MySQL5.7版本。打开网站，页面显示的是MySQL8.0版本，可以点击页面中<a href="https://dev.mysql.com/downloads/mysql/5.7.html" target="_blank" rel="noopener">Looking for previous GA version?</a>转到之前的一些版本。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/1-1.png" style="zoom:50%;"></p><p>  官网提供两种安装方式：一是MySQL Installer图形化安装包；另一个是免安装的Zip压缩包。我主要使用两种图形化安装包，并根据安装向导完成安装，下载Windows(x86，32bit)，MSI Installer。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/1-2.png" style="zoom:45%;"></p><p>  在下载页面，可以不用登录，直接点击<code>No thanks, just start my download</code>进行下载。</p><p><img src="https://gitee.com/linwang0714/ImgHosting/raw/master/article_img//mysql.png" style="zoom:40%;"></p><h2 id="2-安装MySQL5-7"><a href="#2-安装MySQL5-7" class="headerlink" title="2. 安装MySQL5.7"></a>2. 安装MySQL5.7</h2><p>  MySQL下载完成后，找到下载文件，双击进行安装，具体操作步骤如下：</p><p>步骤01：双击安装包，打开【License Agreement】(用户许可证协议)窗口，选中【I accept the license terms】,单击【Next】进入下一步。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/2-1.png" style="zoom:55%;"></p><p>步骤02：打开安装类型选择窗口，在其中列出了几种安装类型，这里选择自定义安装类型，然后点击【Next】。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/2-2.png" style="zoom:55%;"></p><p>步骤03：打开【Select Products and Features】窗口，依次选择MySQL Servers-&gt;MySQL Server-&gt;MySQL Server 5.7-&gt;MySQL Server 5.7.25-X64(若是32位系统，可选择X86).采用同样的流程，添加MySQL Workbench，Samples and Examples，MySQL Documentation等，然后点击【Next】。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/2-3.png" style="zoom:55%;"></p><p>步骤04：检查安装所需环境，点击【Execute】，若缺少Microsoft Visual C++ 2013 Redistributable,按提示安装。然后点击【Next】进入下一步。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/2-4.png" style="zoom:55%;"></p><p>步骤05：开始安装MySQL，点击【Execute】执行结束后，点击【Next】进入下一步。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/2-5.png" style="zoom:55%;"></p><p>步骤06：点击【Next】，开始配置MySQL5.7。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/2-6.png" style="zoom:55%;"></p><h2 id="3-配置MySQL5-7"><a href="#3-配置MySQL5-7" class="headerlink" title="3. 配置MySQL5.7"></a>3. 配置MySQL5.7</h2><p>  MySQL安装结束后，开始配置，直至安装完成。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/3-1.png" style="zoom:55%;"></p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/3-2.png" style="zoom:55%;"></p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/3-3.png" style="zoom:55%;"></p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/3-4.png" style="zoom:55%;"></p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/3-5.png" style="zoom:55%;"></p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/3-6.png" style="zoom:55%;"></p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/3-7.png" style="zoom:55%;"></p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/3-8.png" style="zoom:55%;"></p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/3-9.png" style="zoom:55%;"></p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/3-10.png" style="zoom:55%;"></p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/3-11.png" style="zoom:55%;"></p><h2 id="4-启动服务并登录MySQL数据库"><a href="#4-启动服务并登录MySQL数据库" class="headerlink" title="4. 启动服务并登录MySQL数据库"></a>4. 启动服务并登录MySQL数据库</h2><p>  点击开始菜单，在搜索框输入services.msc查看MySQL服务是否启动，未启动则在搜索框输入cmd，在命令提示符界面（以管理员身份运行）输入net start MySQL57（服务名）则启动服务；停止服务命令为：net stop MySQL57。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/4-1.png" style="zoom:55%;"></p><p>登录MySQL数据库：</p><p>首先，将MySQL安装目录中的bin目录位置C:\Program Files\MySQL\MySQL Server 5.7\bin，加入到系统环境变量Path中。然后，登录MySQL数据库。有两种登录方式：</p><ol><li>以Windows命令行方式登录</li></ol><p>  在命令提示符界面，输入mysql -h localhost -u root -p，按回车（Enter），系统提示输入数据库密码，输入正确后即可登录到MySQL数据库。注：-h后面参数为服务器主机地址，这里客户端和服务器在同一台机器上，所以输入localhost或IP地址127.0.0.1，-u后面是登录数据库的用户名，这里为root，-p后面是密码。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/4-2.png" style="zoom:55%;"></p><ol><li>使用MySQL Command Line Client登录</li></ol><p>  打开MySQL Command Line Client，输入正确密码即可登录到MySQL数据库。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/4-3.png" style="zoom:55%;"></p><h2 id="5、Navicat连接MySQL5-7"><a href="#5、Navicat连接MySQL5-7" class="headerlink" title="5、Navicat连接MySQL5.7"></a>5、Navicat连接MySQL5.7</h2><p>  MySQL图像化管理工具极大方便了数据库的操作与管理，这里仅介绍Navicat连接MySQL5.7。打开Navicat Premium，点击文件-&gt;新建连接-&gt;MySQL，界面中有五个框要填，然后点击确定即可。</p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/5-1.png" style="zoom:55%;"></p><p><img src="https://cdn.jsdelivr.net/gh/weylin0714/ImgHosting/mysql_20190429/5-2.png" style="zoom:55%;"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
